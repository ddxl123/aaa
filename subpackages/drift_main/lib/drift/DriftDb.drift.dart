// ignore_for_file: type=lint
part of 'DriftDb.dart';

mixin _$GeneralQueryDAOMixin on DatabaseAccessor<DriftDb> {
  $UsersTable get users => attachedDatabase.users;
  $ClientSyncInfosTable get clientSyncInfos => attachedDatabase.clientSyncInfos;
  $SyncsTable get syncs => attachedDatabase.syncs;
  $FragmentMemoryInfosTable get fragmentMemoryInfos =>
      attachedDatabase.fragmentMemoryInfos;
  $RDocument2DocumentGroupsTable get rDocument2DocumentGroups =>
      attachedDatabase.rDocument2DocumentGroups;
  $RFragment2FragmentGroupsTable get rFragment2FragmentGroups =>
      attachedDatabase.rFragment2FragmentGroups;
  $RNote2NoteGroupsTable get rNote2NoteGroups =>
      attachedDatabase.rNote2NoteGroups;
  $Test2sTable get test2s => attachedDatabase.test2s;
  $TestsTable get tests => attachedDatabase.tests;
  $DocumentsTable get documents => attachedDatabase.documents;
  $FragmentTemplatesTable get fragmentTemplates =>
      attachedDatabase.fragmentTemplates;
  $FragmentsTable get fragments => attachedDatabase.fragments;
  $MemoryGroupsTable get memoryGroups => attachedDatabase.memoryGroups;
  $MemoryModelsTable get memoryModels => attachedDatabase.memoryModels;
  $NotesTable get notes => attachedDatabase.notes;
  $DocumentGroupsTable get documentGroups => attachedDatabase.documentGroups;
  $FragmentGroupsTable get fragmentGroups => attachedDatabase.fragmentGroups;
  $NoteGroupsTable get noteGroups => attachedDatabase.noteGroups;
}
mixin _$InsertDAOMixin on DatabaseAccessor<DriftDb> {
  $UsersTable get users => attachedDatabase.users;
  $ClientSyncInfosTable get clientSyncInfos => attachedDatabase.clientSyncInfos;
  $SyncsTable get syncs => attachedDatabase.syncs;
  $FragmentMemoryInfosTable get fragmentMemoryInfos =>
      attachedDatabase.fragmentMemoryInfos;
  $RDocument2DocumentGroupsTable get rDocument2DocumentGroups =>
      attachedDatabase.rDocument2DocumentGroups;
  $RFragment2FragmentGroupsTable get rFragment2FragmentGroups =>
      attachedDatabase.rFragment2FragmentGroups;
  $RNote2NoteGroupsTable get rNote2NoteGroups =>
      attachedDatabase.rNote2NoteGroups;
  $Test2sTable get test2s => attachedDatabase.test2s;
  $TestsTable get tests => attachedDatabase.tests;
  $DocumentsTable get documents => attachedDatabase.documents;
  $FragmentTemplatesTable get fragmentTemplates =>
      attachedDatabase.fragmentTemplates;
  $FragmentsTable get fragments => attachedDatabase.fragments;
  $MemoryGroupsTable get memoryGroups => attachedDatabase.memoryGroups;
  $MemoryModelsTable get memoryModels => attachedDatabase.memoryModels;
  $NotesTable get notes => attachedDatabase.notes;
  $DocumentGroupsTable get documentGroups => attachedDatabase.documentGroups;
  $FragmentGroupsTable get fragmentGroups => attachedDatabase.fragmentGroups;
  $NoteGroupsTable get noteGroups => attachedDatabase.noteGroups;
}
mixin _$RawDAOMixin on DatabaseAccessor<DriftDb> {
  $UsersTable get users => attachedDatabase.users;
  $ClientSyncInfosTable get clientSyncInfos => attachedDatabase.clientSyncInfos;
  $SyncsTable get syncs => attachedDatabase.syncs;
  $FragmentMemoryInfosTable get fragmentMemoryInfos =>
      attachedDatabase.fragmentMemoryInfos;
  $RDocument2DocumentGroupsTable get rDocument2DocumentGroups =>
      attachedDatabase.rDocument2DocumentGroups;
  $RFragment2FragmentGroupsTable get rFragment2FragmentGroups =>
      attachedDatabase.rFragment2FragmentGroups;
  $RNote2NoteGroupsTable get rNote2NoteGroups =>
      attachedDatabase.rNote2NoteGroups;
  $Test2sTable get test2s => attachedDatabase.test2s;
  $TestsTable get tests => attachedDatabase.tests;
  $DocumentsTable get documents => attachedDatabase.documents;
  $FragmentTemplatesTable get fragmentTemplates =>
      attachedDatabase.fragmentTemplates;
  $FragmentsTable get fragments => attachedDatabase.fragments;
  $MemoryGroupsTable get memoryGroups => attachedDatabase.memoryGroups;
  $MemoryModelsTable get memoryModels => attachedDatabase.memoryModels;
  $NotesTable get notes => attachedDatabase.notes;
  $DocumentGroupsTable get documentGroups => attachedDatabase.documentGroups;
  $FragmentGroupsTable get fragmentGroups => attachedDatabase.fragmentGroups;
  $NoteGroupsTable get noteGroups => attachedDatabase.noteGroups;
}
mixin _$RegisterOrLoginDAOMixin on DatabaseAccessor<DriftDb> {
  $UsersTable get users => attachedDatabase.users;
  $ClientSyncInfosTable get clientSyncInfos => attachedDatabase.clientSyncInfos;
  $SyncsTable get syncs => attachedDatabase.syncs;
  $FragmentMemoryInfosTable get fragmentMemoryInfos =>
      attachedDatabase.fragmentMemoryInfos;
  $RDocument2DocumentGroupsTable get rDocument2DocumentGroups =>
      attachedDatabase.rDocument2DocumentGroups;
  $RFragment2FragmentGroupsTable get rFragment2FragmentGroups =>
      attachedDatabase.rFragment2FragmentGroups;
  $RNote2NoteGroupsTable get rNote2NoteGroups =>
      attachedDatabase.rNote2NoteGroups;
  $Test2sTable get test2s => attachedDatabase.test2s;
  $TestsTable get tests => attachedDatabase.tests;
  $DocumentsTable get documents => attachedDatabase.documents;
  $FragmentTemplatesTable get fragmentTemplates =>
      attachedDatabase.fragmentTemplates;
  $FragmentsTable get fragments => attachedDatabase.fragments;
  $MemoryGroupsTable get memoryGroups => attachedDatabase.memoryGroups;
  $MemoryModelsTable get memoryModels => attachedDatabase.memoryModels;
  $NotesTable get notes => attachedDatabase.notes;
  $DocumentGroupsTable get documentGroups => attachedDatabase.documentGroups;
  $FragmentGroupsTable get fragmentGroups => attachedDatabase.fragmentGroups;
  $NoteGroupsTable get noteGroups => attachedDatabase.noteGroups;
}
mixin _$UpdateDAOMixin on DatabaseAccessor<DriftDb> {
  $UsersTable get users => attachedDatabase.users;
  $ClientSyncInfosTable get clientSyncInfos => attachedDatabase.clientSyncInfos;
  $SyncsTable get syncs => attachedDatabase.syncs;
  $FragmentMemoryInfosTable get fragmentMemoryInfos =>
      attachedDatabase.fragmentMemoryInfos;
  $RDocument2DocumentGroupsTable get rDocument2DocumentGroups =>
      attachedDatabase.rDocument2DocumentGroups;
  $RFragment2FragmentGroupsTable get rFragment2FragmentGroups =>
      attachedDatabase.rFragment2FragmentGroups;
  $RNote2NoteGroupsTable get rNote2NoteGroups =>
      attachedDatabase.rNote2NoteGroups;
  $Test2sTable get test2s => attachedDatabase.test2s;
  $TestsTable get tests => attachedDatabase.tests;
  $DocumentsTable get documents => attachedDatabase.documents;
  $FragmentTemplatesTable get fragmentTemplates =>
      attachedDatabase.fragmentTemplates;
  $FragmentsTable get fragments => attachedDatabase.fragments;
  $MemoryGroupsTable get memoryGroups => attachedDatabase.memoryGroups;
  $MemoryModelsTable get memoryModels => attachedDatabase.memoryModels;
  $NotesTable get notes => attachedDatabase.notes;
  $DocumentGroupsTable get documentGroups => attachedDatabase.documentGroups;
  $FragmentGroupsTable get fragmentGroups => attachedDatabase.fragmentGroups;
  $NoteGroupsTable get noteGroups => attachedDatabase.noteGroups;
}
mixin _$DeleteDAOMixin on DatabaseAccessor<DriftDb> {
  $UsersTable get users => attachedDatabase.users;
  $ClientSyncInfosTable get clientSyncInfos => attachedDatabase.clientSyncInfos;
  $SyncsTable get syncs => attachedDatabase.syncs;
  $FragmentMemoryInfosTable get fragmentMemoryInfos =>
      attachedDatabase.fragmentMemoryInfos;
  $RDocument2DocumentGroupsTable get rDocument2DocumentGroups =>
      attachedDatabase.rDocument2DocumentGroups;
  $RFragment2FragmentGroupsTable get rFragment2FragmentGroups =>
      attachedDatabase.rFragment2FragmentGroups;
  $RNote2NoteGroupsTable get rNote2NoteGroups =>
      attachedDatabase.rNote2NoteGroups;
  $Test2sTable get test2s => attachedDatabase.test2s;
  $TestsTable get tests => attachedDatabase.tests;
  $DocumentsTable get documents => attachedDatabase.documents;
  $FragmentTemplatesTable get fragmentTemplates =>
      attachedDatabase.fragmentTemplates;
  $FragmentsTable get fragments => attachedDatabase.fragments;
  $MemoryGroupsTable get memoryGroups => attachedDatabase.memoryGroups;
  $MemoryModelsTable get memoryModels => attachedDatabase.memoryModels;
  $NotesTable get notes => attachedDatabase.notes;
  $DocumentGroupsTable get documentGroups => attachedDatabase.documentGroups;
  $FragmentGroupsTable get fragmentGroups => attachedDatabase.fragmentGroups;
  $NoteGroupsTable get noteGroups => attachedDatabase.noteGroups;
}

class User extends DataClass implements Insertable<User> {
  int? age;
  String? email;
  String? password;
  String? phone;
  String username;
  DateTime created_at;
  int id;
  DateTime updated_at;
  User(
      {this.age,
      this.email,
      this.password,
      this.phone,
      required this.username,
      required this.created_at,
      required this.id,
      required this.updated_at});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || age != null) {
      map['age'] = Variable<int>(age);
    }
    if (!nullToAbsent || email != null) {
      map['email'] = Variable<String>(email);
    }
    if (!nullToAbsent || password != null) {
      map['password'] = Variable<String>(password);
    }
    if (!nullToAbsent || phone != null) {
      map['phone'] = Variable<String>(phone);
    }
    map['username'] = Variable<String>(username);
    map['created_at'] = Variable<DateTime>(created_at);
    map['id'] = Variable<int>(id);
    map['updated_at'] = Variable<DateTime>(updated_at);
    return map;
  }

  UsersCompanion toCompanion(bool nullToAbsent) {
    return UsersCompanion(
      age: age == null && nullToAbsent ? const Value.absent() : Value(age),
      email:
          email == null && nullToAbsent ? const Value.absent() : Value(email),
      password: password == null && nullToAbsent
          ? const Value.absent()
          : Value(password),
      phone:
          phone == null && nullToAbsent ? const Value.absent() : Value(phone),
      username: Value(username),
      created_at: Value(created_at),
      id: Value(id),
      updated_at: Value(updated_at),
    );
  }

  factory User.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return User(
      age: serializer.fromJson<int?>(json['age']),
      email: serializer.fromJson<String?>(json['email']),
      password: serializer.fromJson<String?>(json['password']),
      phone: serializer.fromJson<String?>(json['phone']),
      username: serializer.fromJson<String>(json['username']),
      created_at: serializer.fromJson<DateTime>(json['created_at']),
      id: serializer.fromJson<int>(json['id']),
      updated_at: serializer.fromJson<DateTime>(json['updated_at']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'age': serializer.toJson<int?>(age),
      'email': serializer.toJson<String?>(email),
      'password': serializer.toJson<String?>(password),
      'phone': serializer.toJson<String?>(phone),
      'username': serializer.toJson<String>(username),
      'created_at': serializer.toJson<DateTime>(created_at),
      'id': serializer.toJson<int>(id),
      'updated_at': serializer.toJson<DateTime>(updated_at),
    };
  }

  User copyWith(
          {Value<int?> age = const Value.absent(),
          Value<String?> email = const Value.absent(),
          Value<String?> password = const Value.absent(),
          Value<String?> phone = const Value.absent(),
          String? username,
          DateTime? created_at,
          int? id,
          DateTime? updated_at}) =>
      User(
        age: age.present ? age.value : this.age,
        email: email.present ? email.value : this.email,
        password: password.present ? password.value : this.password,
        phone: phone.present ? phone.value : this.phone,
        username: username ?? this.username,
        created_at: created_at ?? this.created_at,
        id: id ?? this.id,
        updated_at: updated_at ?? this.updated_at,
      );
  @override
  String toString() {
    return (StringBuffer('User(')
          ..write('age: $age, ')
          ..write('email: $email, ')
          ..write('password: $password, ')
          ..write('phone: $phone, ')
          ..write('username: $username, ')
          ..write('created_at: $created_at, ')
          ..write('id: $id, ')
          ..write('updated_at: $updated_at')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      age, email, password, phone, username, created_at, id, updated_at);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is User &&
          other.age == this.age &&
          other.email == this.email &&
          other.password == this.password &&
          other.phone == this.phone &&
          other.username == this.username &&
          other.created_at == this.created_at &&
          other.id == this.id &&
          other.updated_at == this.updated_at);
}

class UsersCompanion extends UpdateCompanion<User> {
  Value<int?> age;
  Value<String?> email;
  Value<String?> password;
  Value<String?> phone;
  Value<String> username;
  Value<DateTime> created_at;
  Value<int> id;
  Value<DateTime> updated_at;
  UsersCompanion({
    this.age = const Value.absent(),
    this.email = const Value.absent(),
    this.password = const Value.absent(),
    this.phone = const Value.absent(),
    this.username = const Value.absent(),
    this.created_at = const Value.absent(),
    this.id = const Value.absent(),
    this.updated_at = const Value.absent(),
  });
  UsersCompanion.insert({
    this.age = const Value.absent(),
    this.email = const Value.absent(),
    this.password = const Value.absent(),
    this.phone = const Value.absent(),
    required String username,
    required DateTime created_at,
    this.id = const Value.absent(),
    required DateTime updated_at,
  })  : username = Value(username),
        created_at = Value(created_at),
        updated_at = Value(updated_at);
  static Insertable<User> custom({
    Expression<int>? age,
    Expression<String>? email,
    Expression<String>? password,
    Expression<String>? phone,
    Expression<String>? username,
    Expression<DateTime>? created_at,
    Expression<int>? id,
    Expression<DateTime>? updated_at,
  }) {
    return RawValuesInsertable({
      if (age != null) 'age': age,
      if (email != null) 'email': email,
      if (password != null) 'password': password,
      if (phone != null) 'phone': phone,
      if (username != null) 'username': username,
      if (created_at != null) 'created_at': created_at,
      if (id != null) 'id': id,
      if (updated_at != null) 'updated_at': updated_at,
    });
  }

  UsersCompanion copyWith(
      {Value<int?>? age,
      Value<String?>? email,
      Value<String?>? password,
      Value<String?>? phone,
      Value<String>? username,
      Value<DateTime>? created_at,
      Value<int>? id,
      Value<DateTime>? updated_at}) {
    return UsersCompanion(
      age: age ?? this.age,
      email: email ?? this.email,
      password: password ?? this.password,
      phone: phone ?? this.phone,
      username: username ?? this.username,
      created_at: created_at ?? this.created_at,
      id: id ?? this.id,
      updated_at: updated_at ?? this.updated_at,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (age.present) {
      map['age'] = Variable<int>(age.value);
    }
    if (email.present) {
      map['email'] = Variable<String>(email.value);
    }
    if (password.present) {
      map['password'] = Variable<String>(password.value);
    }
    if (phone.present) {
      map['phone'] = Variable<String>(phone.value);
    }
    if (username.present) {
      map['username'] = Variable<String>(username.value);
    }
    if (created_at.present) {
      map['created_at'] = Variable<DateTime>(created_at.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (updated_at.present) {
      map['updated_at'] = Variable<DateTime>(updated_at.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('UsersCompanion(')
          ..write('age: $age, ')
          ..write('email: $email, ')
          ..write('password: $password, ')
          ..write('phone: $phone, ')
          ..write('username: $username, ')
          ..write('created_at: $created_at, ')
          ..write('id: $id, ')
          ..write('updated_at: $updated_at')
          ..write(')'))
        .toString();
  }
}

class $UsersTable extends Users with TableInfo<$UsersTable, User> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $UsersTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _ageMeta = const VerificationMeta('age');
  @override
  late final GeneratedColumn<int> age = GeneratedColumn<int>(
      'age', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _emailMeta = const VerificationMeta('email');
  @override
  late final GeneratedColumn<String> email = GeneratedColumn<String>(
      'email', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _passwordMeta =
      const VerificationMeta('password');
  @override
  late final GeneratedColumn<String> password = GeneratedColumn<String>(
      'password', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _phoneMeta = const VerificationMeta('phone');
  @override
  late final GeneratedColumn<String> phone = GeneratedColumn<String>(
      'phone', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _usernameMeta =
      const VerificationMeta('username');
  @override
  late final GeneratedColumn<String> username = GeneratedColumn<String>(
      'username', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _created_atMeta =
      const VerificationMeta('created_at');
  @override
  late final GeneratedColumn<DateTime> created_at = GeneratedColumn<DateTime>(
      'created_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _updated_atMeta =
      const VerificationMeta('updated_at');
  @override
  late final GeneratedColumn<DateTime> updated_at = GeneratedColumn<DateTime>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns =>
      [age, email, password, phone, username, created_at, id, updated_at];
  @override
  String get aliasedName => _alias ?? 'users';
  @override
  String get actualTableName => 'users';
  @override
  VerificationContext validateIntegrity(Insertable<User> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('age')) {
      context.handle(
          _ageMeta, age.isAcceptableOrUnknown(data['age']!, _ageMeta));
    }
    if (data.containsKey('email')) {
      context.handle(
          _emailMeta, email.isAcceptableOrUnknown(data['email']!, _emailMeta));
    }
    if (data.containsKey('password')) {
      context.handle(_passwordMeta,
          password.isAcceptableOrUnknown(data['password']!, _passwordMeta));
    }
    if (data.containsKey('phone')) {
      context.handle(
          _phoneMeta, phone.isAcceptableOrUnknown(data['phone']!, _phoneMeta));
    }
    if (data.containsKey('username')) {
      context.handle(_usernameMeta,
          username.isAcceptableOrUnknown(data['username']!, _usernameMeta));
    } else if (isInserting) {
      context.missing(_usernameMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(
          _created_atMeta,
          created_at.isAcceptableOrUnknown(
              data['created_at']!, _created_atMeta));
    } else if (isInserting) {
      context.missing(_created_atMeta);
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('updated_at')) {
      context.handle(
          _updated_atMeta,
          updated_at.isAcceptableOrUnknown(
              data['updated_at']!, _updated_atMeta));
    } else if (isInserting) {
      context.missing(_updated_atMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  User map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return User(
      age: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}age']),
      email: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}email']),
      password: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}password']),
      phone: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}phone']),
      username: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}username'])!,
      created_at: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_at'])!,
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      updated_at: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}updated_at'])!,
    );
  }

  @override
  $UsersTable createAlias(String alias) {
    return $UsersTable(attachedDatabase, alias);
  }
}

class ClientSyncInfo extends DataClass implements Insertable<ClientSyncInfo> {
  String device_info;
  DateTime? recent_sync_time;
  String? token;
  DateTime created_at;
  int id;
  DateTime updated_at;
  ClientSyncInfo(
      {required this.device_info,
      this.recent_sync_time,
      this.token,
      required this.created_at,
      required this.id,
      required this.updated_at});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['device_info'] = Variable<String>(device_info);
    if (!nullToAbsent || recent_sync_time != null) {
      map['recent_sync_time'] = Variable<DateTime>(recent_sync_time);
    }
    if (!nullToAbsent || token != null) {
      map['token'] = Variable<String>(token);
    }
    map['created_at'] = Variable<DateTime>(created_at);
    map['id'] = Variable<int>(id);
    map['updated_at'] = Variable<DateTime>(updated_at);
    return map;
  }

  ClientSyncInfosCompanion toCompanion(bool nullToAbsent) {
    return ClientSyncInfosCompanion(
      device_info: Value(device_info),
      recent_sync_time: recent_sync_time == null && nullToAbsent
          ? const Value.absent()
          : Value(recent_sync_time),
      token:
          token == null && nullToAbsent ? const Value.absent() : Value(token),
      created_at: Value(created_at),
      id: Value(id),
      updated_at: Value(updated_at),
    );
  }

  factory ClientSyncInfo.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ClientSyncInfo(
      device_info: serializer.fromJson<String>(json['device_info']),
      recent_sync_time:
          serializer.fromJson<DateTime?>(json['recent_sync_time']),
      token: serializer.fromJson<String?>(json['token']),
      created_at: serializer.fromJson<DateTime>(json['created_at']),
      id: serializer.fromJson<int>(json['id']),
      updated_at: serializer.fromJson<DateTime>(json['updated_at']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'device_info': serializer.toJson<String>(device_info),
      'recent_sync_time': serializer.toJson<DateTime?>(recent_sync_time),
      'token': serializer.toJson<String?>(token),
      'created_at': serializer.toJson<DateTime>(created_at),
      'id': serializer.toJson<int>(id),
      'updated_at': serializer.toJson<DateTime>(updated_at),
    };
  }

  ClientSyncInfo copyWith(
          {String? device_info,
          Value<DateTime?> recent_sync_time = const Value.absent(),
          Value<String?> token = const Value.absent(),
          DateTime? created_at,
          int? id,
          DateTime? updated_at}) =>
      ClientSyncInfo(
        device_info: device_info ?? this.device_info,
        recent_sync_time: recent_sync_time.present
            ? recent_sync_time.value
            : this.recent_sync_time,
        token: token.present ? token.value : this.token,
        created_at: created_at ?? this.created_at,
        id: id ?? this.id,
        updated_at: updated_at ?? this.updated_at,
      );
  @override
  String toString() {
    return (StringBuffer('ClientSyncInfo(')
          ..write('device_info: $device_info, ')
          ..write('recent_sync_time: $recent_sync_time, ')
          ..write('token: $token, ')
          ..write('created_at: $created_at, ')
          ..write('id: $id, ')
          ..write('updated_at: $updated_at')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      device_info, recent_sync_time, token, created_at, id, updated_at);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ClientSyncInfo &&
          other.device_info == this.device_info &&
          other.recent_sync_time == this.recent_sync_time &&
          other.token == this.token &&
          other.created_at == this.created_at &&
          other.id == this.id &&
          other.updated_at == this.updated_at);
}

class ClientSyncInfosCompanion extends UpdateCompanion<ClientSyncInfo> {
  Value<String> device_info;
  Value<DateTime?> recent_sync_time;
  Value<String?> token;
  Value<DateTime> created_at;
  Value<int> id;
  Value<DateTime> updated_at;
  ClientSyncInfosCompanion({
    this.device_info = const Value.absent(),
    this.recent_sync_time = const Value.absent(),
    this.token = const Value.absent(),
    this.created_at = const Value.absent(),
    this.id = const Value.absent(),
    this.updated_at = const Value.absent(),
  });
  ClientSyncInfosCompanion.insert({
    required String device_info,
    this.recent_sync_time = const Value.absent(),
    this.token = const Value.absent(),
    required DateTime created_at,
    this.id = const Value.absent(),
    required DateTime updated_at,
  })  : device_info = Value(device_info),
        created_at = Value(created_at),
        updated_at = Value(updated_at);
  static Insertable<ClientSyncInfo> custom({
    Expression<String>? device_info,
    Expression<DateTime>? recent_sync_time,
    Expression<String>? token,
    Expression<DateTime>? created_at,
    Expression<int>? id,
    Expression<DateTime>? updated_at,
  }) {
    return RawValuesInsertable({
      if (device_info != null) 'device_info': device_info,
      if (recent_sync_time != null) 'recent_sync_time': recent_sync_time,
      if (token != null) 'token': token,
      if (created_at != null) 'created_at': created_at,
      if (id != null) 'id': id,
      if (updated_at != null) 'updated_at': updated_at,
    });
  }

  ClientSyncInfosCompanion copyWith(
      {Value<String>? device_info,
      Value<DateTime?>? recent_sync_time,
      Value<String?>? token,
      Value<DateTime>? created_at,
      Value<int>? id,
      Value<DateTime>? updated_at}) {
    return ClientSyncInfosCompanion(
      device_info: device_info ?? this.device_info,
      recent_sync_time: recent_sync_time ?? this.recent_sync_time,
      token: token ?? this.token,
      created_at: created_at ?? this.created_at,
      id: id ?? this.id,
      updated_at: updated_at ?? this.updated_at,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (device_info.present) {
      map['device_info'] = Variable<String>(device_info.value);
    }
    if (recent_sync_time.present) {
      map['recent_sync_time'] = Variable<DateTime>(recent_sync_time.value);
    }
    if (token.present) {
      map['token'] = Variable<String>(token.value);
    }
    if (created_at.present) {
      map['created_at'] = Variable<DateTime>(created_at.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (updated_at.present) {
      map['updated_at'] = Variable<DateTime>(updated_at.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ClientSyncInfosCompanion(')
          ..write('device_info: $device_info, ')
          ..write('recent_sync_time: $recent_sync_time, ')
          ..write('token: $token, ')
          ..write('created_at: $created_at, ')
          ..write('id: $id, ')
          ..write('updated_at: $updated_at')
          ..write(')'))
        .toString();
  }
}

class $ClientSyncInfosTable extends ClientSyncInfos
    with TableInfo<$ClientSyncInfosTable, ClientSyncInfo> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ClientSyncInfosTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _device_infoMeta =
      const VerificationMeta('device_info');
  @override
  late final GeneratedColumn<String> device_info = GeneratedColumn<String>(
      'device_info', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _recent_sync_timeMeta =
      const VerificationMeta('recent_sync_time');
  @override
  late final GeneratedColumn<DateTime> recent_sync_time =
      GeneratedColumn<DateTime>('recent_sync_time', aliasedName, true,
          type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _tokenMeta = const VerificationMeta('token');
  @override
  late final GeneratedColumn<String> token = GeneratedColumn<String>(
      'token', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _created_atMeta =
      const VerificationMeta('created_at');
  @override
  late final GeneratedColumn<DateTime> created_at = GeneratedColumn<DateTime>(
      'created_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _updated_atMeta =
      const VerificationMeta('updated_at');
  @override
  late final GeneratedColumn<DateTime> updated_at = GeneratedColumn<DateTime>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns =>
      [device_info, recent_sync_time, token, created_at, id, updated_at];
  @override
  String get aliasedName => _alias ?? 'client_sync_infos';
  @override
  String get actualTableName => 'client_sync_infos';
  @override
  VerificationContext validateIntegrity(Insertable<ClientSyncInfo> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('device_info')) {
      context.handle(
          _device_infoMeta,
          device_info.isAcceptableOrUnknown(
              data['device_info']!, _device_infoMeta));
    } else if (isInserting) {
      context.missing(_device_infoMeta);
    }
    if (data.containsKey('recent_sync_time')) {
      context.handle(
          _recent_sync_timeMeta,
          recent_sync_time.isAcceptableOrUnknown(
              data['recent_sync_time']!, _recent_sync_timeMeta));
    }
    if (data.containsKey('token')) {
      context.handle(
          _tokenMeta, token.isAcceptableOrUnknown(data['token']!, _tokenMeta));
    }
    if (data.containsKey('created_at')) {
      context.handle(
          _created_atMeta,
          created_at.isAcceptableOrUnknown(
              data['created_at']!, _created_atMeta));
    } else if (isInserting) {
      context.missing(_created_atMeta);
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('updated_at')) {
      context.handle(
          _updated_atMeta,
          updated_at.isAcceptableOrUnknown(
              data['updated_at']!, _updated_atMeta));
    } else if (isInserting) {
      context.missing(_updated_atMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  ClientSyncInfo map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ClientSyncInfo(
      device_info: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}device_info'])!,
      recent_sync_time: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}recent_sync_time']),
      token: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}token']),
      created_at: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_at'])!,
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      updated_at: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}updated_at'])!,
    );
  }

  @override
  $ClientSyncInfosTable createAlias(String alias) {
    return $ClientSyncInfosTable(attachedDatabase, alias);
  }
}

class Sync extends DataClass implements Insertable<Sync> {
  String row_id;
  SyncCurdType sync_curd_type;
  String sync_table_name;
  int tag;
  DateTime created_at;
  int id;
  DateTime updated_at;
  Sync(
      {required this.row_id,
      required this.sync_curd_type,
      required this.sync_table_name,
      required this.tag,
      required this.created_at,
      required this.id,
      required this.updated_at});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['row_id'] = Variable<String>(row_id);
    {
      final converter = $SyncsTable.$convertersync_curd_type;
      map['sync_curd_type'] = Variable<int>(converter.toSql(sync_curd_type));
    }
    map['sync_table_name'] = Variable<String>(sync_table_name);
    map['tag'] = Variable<int>(tag);
    map['created_at'] = Variable<DateTime>(created_at);
    map['id'] = Variable<int>(id);
    map['updated_at'] = Variable<DateTime>(updated_at);
    return map;
  }

  SyncsCompanion toCompanion(bool nullToAbsent) {
    return SyncsCompanion(
      row_id: Value(row_id),
      sync_curd_type: Value(sync_curd_type),
      sync_table_name: Value(sync_table_name),
      tag: Value(tag),
      created_at: Value(created_at),
      id: Value(id),
      updated_at: Value(updated_at),
    );
  }

  factory Sync.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Sync(
      row_id: serializer.fromJson<String>(json['row_id']),
      sync_curd_type: $SyncsTable.$convertersync_curd_type
          .fromJson(serializer.fromJson<int>(json['sync_curd_type'])),
      sync_table_name: serializer.fromJson<String>(json['sync_table_name']),
      tag: serializer.fromJson<int>(json['tag']),
      created_at: serializer.fromJson<DateTime>(json['created_at']),
      id: serializer.fromJson<int>(json['id']),
      updated_at: serializer.fromJson<DateTime>(json['updated_at']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'row_id': serializer.toJson<String>(row_id),
      'sync_curd_type': serializer.toJson<int>(
          $SyncsTable.$convertersync_curd_type.toJson(sync_curd_type)),
      'sync_table_name': serializer.toJson<String>(sync_table_name),
      'tag': serializer.toJson<int>(tag),
      'created_at': serializer.toJson<DateTime>(created_at),
      'id': serializer.toJson<int>(id),
      'updated_at': serializer.toJson<DateTime>(updated_at),
    };
  }

  Sync copyWith(
          {String? row_id,
          SyncCurdType? sync_curd_type,
          String? sync_table_name,
          int? tag,
          DateTime? created_at,
          int? id,
          DateTime? updated_at}) =>
      Sync(
        row_id: row_id ?? this.row_id,
        sync_curd_type: sync_curd_type ?? this.sync_curd_type,
        sync_table_name: sync_table_name ?? this.sync_table_name,
        tag: tag ?? this.tag,
        created_at: created_at ?? this.created_at,
        id: id ?? this.id,
        updated_at: updated_at ?? this.updated_at,
      );
  @override
  String toString() {
    return (StringBuffer('Sync(')
          ..write('row_id: $row_id, ')
          ..write('sync_curd_type: $sync_curd_type, ')
          ..write('sync_table_name: $sync_table_name, ')
          ..write('tag: $tag, ')
          ..write('created_at: $created_at, ')
          ..write('id: $id, ')
          ..write('updated_at: $updated_at')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      row_id, sync_curd_type, sync_table_name, tag, created_at, id, updated_at);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Sync &&
          other.row_id == this.row_id &&
          other.sync_curd_type == this.sync_curd_type &&
          other.sync_table_name == this.sync_table_name &&
          other.tag == this.tag &&
          other.created_at == this.created_at &&
          other.id == this.id &&
          other.updated_at == this.updated_at);
}

class SyncsCompanion extends UpdateCompanion<Sync> {
  Value<String> row_id;
  Value<SyncCurdType> sync_curd_type;
  Value<String> sync_table_name;
  Value<int> tag;
  Value<DateTime> created_at;
  Value<int> id;
  Value<DateTime> updated_at;
  SyncsCompanion({
    this.row_id = const Value.absent(),
    this.sync_curd_type = const Value.absent(),
    this.sync_table_name = const Value.absent(),
    this.tag = const Value.absent(),
    this.created_at = const Value.absent(),
    this.id = const Value.absent(),
    this.updated_at = const Value.absent(),
  });
  SyncsCompanion.insert({
    required String row_id,
    required SyncCurdType sync_curd_type,
    required String sync_table_name,
    required int tag,
    required DateTime created_at,
    this.id = const Value.absent(),
    required DateTime updated_at,
  })  : row_id = Value(row_id),
        sync_curd_type = Value(sync_curd_type),
        sync_table_name = Value(sync_table_name),
        tag = Value(tag),
        created_at = Value(created_at),
        updated_at = Value(updated_at);
  static Insertable<Sync> custom({
    Expression<String>? row_id,
    Expression<int>? sync_curd_type,
    Expression<String>? sync_table_name,
    Expression<int>? tag,
    Expression<DateTime>? created_at,
    Expression<int>? id,
    Expression<DateTime>? updated_at,
  }) {
    return RawValuesInsertable({
      if (row_id != null) 'row_id': row_id,
      if (sync_curd_type != null) 'sync_curd_type': sync_curd_type,
      if (sync_table_name != null) 'sync_table_name': sync_table_name,
      if (tag != null) 'tag': tag,
      if (created_at != null) 'created_at': created_at,
      if (id != null) 'id': id,
      if (updated_at != null) 'updated_at': updated_at,
    });
  }

  SyncsCompanion copyWith(
      {Value<String>? row_id,
      Value<SyncCurdType>? sync_curd_type,
      Value<String>? sync_table_name,
      Value<int>? tag,
      Value<DateTime>? created_at,
      Value<int>? id,
      Value<DateTime>? updated_at}) {
    return SyncsCompanion(
      row_id: row_id ?? this.row_id,
      sync_curd_type: sync_curd_type ?? this.sync_curd_type,
      sync_table_name: sync_table_name ?? this.sync_table_name,
      tag: tag ?? this.tag,
      created_at: created_at ?? this.created_at,
      id: id ?? this.id,
      updated_at: updated_at ?? this.updated_at,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (row_id.present) {
      map['row_id'] = Variable<String>(row_id.value);
    }
    if (sync_curd_type.present) {
      final converter = $SyncsTable.$convertersync_curd_type;
      map['sync_curd_type'] =
          Variable<int>(converter.toSql(sync_curd_type.value));
    }
    if (sync_table_name.present) {
      map['sync_table_name'] = Variable<String>(sync_table_name.value);
    }
    if (tag.present) {
      map['tag'] = Variable<int>(tag.value);
    }
    if (created_at.present) {
      map['created_at'] = Variable<DateTime>(created_at.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (updated_at.present) {
      map['updated_at'] = Variable<DateTime>(updated_at.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SyncsCompanion(')
          ..write('row_id: $row_id, ')
          ..write('sync_curd_type: $sync_curd_type, ')
          ..write('sync_table_name: $sync_table_name, ')
          ..write('tag: $tag, ')
          ..write('created_at: $created_at, ')
          ..write('id: $id, ')
          ..write('updated_at: $updated_at')
          ..write(')'))
        .toString();
  }
}

class $SyncsTable extends Syncs with TableInfo<$SyncsTable, Sync> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SyncsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _row_idMeta = const VerificationMeta('row_id');
  @override
  late final GeneratedColumn<String> row_id = GeneratedColumn<String>(
      'row_id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _sync_curd_typeMeta =
      const VerificationMeta('sync_curd_type');
  @override
  late final GeneratedColumnWithTypeConverter<SyncCurdType, int>
      sync_curd_type = GeneratedColumn<int>(
              'sync_curd_type', aliasedName, false,
              type: DriftSqlType.int, requiredDuringInsert: true)
          .withConverter<SyncCurdType>($SyncsTable.$convertersync_curd_type);
  static const VerificationMeta _sync_table_nameMeta =
      const VerificationMeta('sync_table_name');
  @override
  late final GeneratedColumn<String> sync_table_name = GeneratedColumn<String>(
      'sync_table_name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _tagMeta = const VerificationMeta('tag');
  @override
  late final GeneratedColumn<int> tag = GeneratedColumn<int>(
      'tag', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _created_atMeta =
      const VerificationMeta('created_at');
  @override
  late final GeneratedColumn<DateTime> created_at = GeneratedColumn<DateTime>(
      'created_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _updated_atMeta =
      const VerificationMeta('updated_at');
  @override
  late final GeneratedColumn<DateTime> updated_at = GeneratedColumn<DateTime>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns => [
        row_id,
        sync_curd_type,
        sync_table_name,
        tag,
        created_at,
        id,
        updated_at
      ];
  @override
  String get aliasedName => _alias ?? 'syncs';
  @override
  String get actualTableName => 'syncs';
  @override
  VerificationContext validateIntegrity(Insertable<Sync> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('row_id')) {
      context.handle(_row_idMeta,
          row_id.isAcceptableOrUnknown(data['row_id']!, _row_idMeta));
    } else if (isInserting) {
      context.missing(_row_idMeta);
    }
    context.handle(_sync_curd_typeMeta, const VerificationResult.success());
    if (data.containsKey('sync_table_name')) {
      context.handle(
          _sync_table_nameMeta,
          sync_table_name.isAcceptableOrUnknown(
              data['sync_table_name']!, _sync_table_nameMeta));
    } else if (isInserting) {
      context.missing(_sync_table_nameMeta);
    }
    if (data.containsKey('tag')) {
      context.handle(
          _tagMeta, tag.isAcceptableOrUnknown(data['tag']!, _tagMeta));
    } else if (isInserting) {
      context.missing(_tagMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(
          _created_atMeta,
          created_at.isAcceptableOrUnknown(
              data['created_at']!, _created_atMeta));
    } else if (isInserting) {
      context.missing(_created_atMeta);
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('updated_at')) {
      context.handle(
          _updated_atMeta,
          updated_at.isAcceptableOrUnknown(
              data['updated_at']!, _updated_atMeta));
    } else if (isInserting) {
      context.missing(_updated_atMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Sync map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Sync(
      row_id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}row_id'])!,
      sync_curd_type: $SyncsTable.$convertersync_curd_type.fromSql(
          attachedDatabase.typeMapping.read(
              DriftSqlType.int, data['${effectivePrefix}sync_curd_type'])!),
      sync_table_name: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}sync_table_name'])!,
      tag: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}tag'])!,
      created_at: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_at'])!,
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      updated_at: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}updated_at'])!,
    );
  }

  @override
  $SyncsTable createAlias(String alias) {
    return $SyncsTable(attachedDatabase, alias);
  }

  static JsonTypeConverter2<SyncCurdType, int, int> $convertersync_curd_type =
      const EnumIndexConverter<SyncCurdType>(SyncCurdType.values);
}

class FragmentMemoryInfo extends DataClass
    implements Insertable<FragmentMemoryInfo> {
  String? click_time;
  String? click_value;
  int creator_user_id;
  String? current_actual_show_time;
  String fragment_id;
  String memory_group_id;
  String? next_plan_show_time;
  String? show_familiarity;
  DateTime created_at;
  String id;
  DateTime updated_at;
  FragmentMemoryInfo(
      {this.click_time,
      this.click_value,
      required this.creator_user_id,
      this.current_actual_show_time,
      required this.fragment_id,
      required this.memory_group_id,
      this.next_plan_show_time,
      this.show_familiarity,
      required this.created_at,
      required this.id,
      required this.updated_at});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || click_time != null) {
      map['click_time'] = Variable<String>(click_time);
    }
    if (!nullToAbsent || click_value != null) {
      map['click_value'] = Variable<String>(click_value);
    }
    map['creator_user_id'] = Variable<int>(creator_user_id);
    if (!nullToAbsent || current_actual_show_time != null) {
      map['current_actual_show_time'] =
          Variable<String>(current_actual_show_time);
    }
    map['fragment_id'] = Variable<String>(fragment_id);
    map['memory_group_id'] = Variable<String>(memory_group_id);
    if (!nullToAbsent || next_plan_show_time != null) {
      map['next_plan_show_time'] = Variable<String>(next_plan_show_time);
    }
    if (!nullToAbsent || show_familiarity != null) {
      map['show_familiarity'] = Variable<String>(show_familiarity);
    }
    map['created_at'] = Variable<DateTime>(created_at);
    map['id'] = Variable<String>(id);
    map['updated_at'] = Variable<DateTime>(updated_at);
    return map;
  }

  FragmentMemoryInfosCompanion toCompanion(bool nullToAbsent) {
    return FragmentMemoryInfosCompanion(
      click_time: click_time == null && nullToAbsent
          ? const Value.absent()
          : Value(click_time),
      click_value: click_value == null && nullToAbsent
          ? const Value.absent()
          : Value(click_value),
      creator_user_id: Value(creator_user_id),
      current_actual_show_time: current_actual_show_time == null && nullToAbsent
          ? const Value.absent()
          : Value(current_actual_show_time),
      fragment_id: Value(fragment_id),
      memory_group_id: Value(memory_group_id),
      next_plan_show_time: next_plan_show_time == null && nullToAbsent
          ? const Value.absent()
          : Value(next_plan_show_time),
      show_familiarity: show_familiarity == null && nullToAbsent
          ? const Value.absent()
          : Value(show_familiarity),
      created_at: Value(created_at),
      id: Value(id),
      updated_at: Value(updated_at),
    );
  }

  factory FragmentMemoryInfo.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return FragmentMemoryInfo(
      click_time: serializer.fromJson<String?>(json['click_time']),
      click_value: serializer.fromJson<String?>(json['click_value']),
      creator_user_id: serializer.fromJson<int>(json['creator_user_id']),
      current_actual_show_time:
          serializer.fromJson<String?>(json['current_actual_show_time']),
      fragment_id: serializer.fromJson<String>(json['fragment_id']),
      memory_group_id: serializer.fromJson<String>(json['memory_group_id']),
      next_plan_show_time:
          serializer.fromJson<String?>(json['next_plan_show_time']),
      show_familiarity: serializer.fromJson<String?>(json['show_familiarity']),
      created_at: serializer.fromJson<DateTime>(json['created_at']),
      id: serializer.fromJson<String>(json['id']),
      updated_at: serializer.fromJson<DateTime>(json['updated_at']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'click_time': serializer.toJson<String?>(click_time),
      'click_value': serializer.toJson<String?>(click_value),
      'creator_user_id': serializer.toJson<int>(creator_user_id),
      'current_actual_show_time':
          serializer.toJson<String?>(current_actual_show_time),
      'fragment_id': serializer.toJson<String>(fragment_id),
      'memory_group_id': serializer.toJson<String>(memory_group_id),
      'next_plan_show_time': serializer.toJson<String?>(next_plan_show_time),
      'show_familiarity': serializer.toJson<String?>(show_familiarity),
      'created_at': serializer.toJson<DateTime>(created_at),
      'id': serializer.toJson<String>(id),
      'updated_at': serializer.toJson<DateTime>(updated_at),
    };
  }

  FragmentMemoryInfo copyWith(
          {Value<String?> click_time = const Value.absent(),
          Value<String?> click_value = const Value.absent(),
          int? creator_user_id,
          Value<String?> current_actual_show_time = const Value.absent(),
          String? fragment_id,
          String? memory_group_id,
          Value<String?> next_plan_show_time = const Value.absent(),
          Value<String?> show_familiarity = const Value.absent(),
          DateTime? created_at,
          String? id,
          DateTime? updated_at}) =>
      FragmentMemoryInfo(
        click_time: click_time.present ? click_time.value : this.click_time,
        click_value: click_value.present ? click_value.value : this.click_value,
        creator_user_id: creator_user_id ?? this.creator_user_id,
        current_actual_show_time: current_actual_show_time.present
            ? current_actual_show_time.value
            : this.current_actual_show_time,
        fragment_id: fragment_id ?? this.fragment_id,
        memory_group_id: memory_group_id ?? this.memory_group_id,
        next_plan_show_time: next_plan_show_time.present
            ? next_plan_show_time.value
            : this.next_plan_show_time,
        show_familiarity: show_familiarity.present
            ? show_familiarity.value
            : this.show_familiarity,
        created_at: created_at ?? this.created_at,
        id: id ?? this.id,
        updated_at: updated_at ?? this.updated_at,
      );
  @override
  String toString() {
    return (StringBuffer('FragmentMemoryInfo(')
          ..write('click_time: $click_time, ')
          ..write('click_value: $click_value, ')
          ..write('creator_user_id: $creator_user_id, ')
          ..write('current_actual_show_time: $current_actual_show_time, ')
          ..write('fragment_id: $fragment_id, ')
          ..write('memory_group_id: $memory_group_id, ')
          ..write('next_plan_show_time: $next_plan_show_time, ')
          ..write('show_familiarity: $show_familiarity, ')
          ..write('created_at: $created_at, ')
          ..write('id: $id, ')
          ..write('updated_at: $updated_at')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      click_time,
      click_value,
      creator_user_id,
      current_actual_show_time,
      fragment_id,
      memory_group_id,
      next_plan_show_time,
      show_familiarity,
      created_at,
      id,
      updated_at);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is FragmentMemoryInfo &&
          other.click_time == this.click_time &&
          other.click_value == this.click_value &&
          other.creator_user_id == this.creator_user_id &&
          other.current_actual_show_time == this.current_actual_show_time &&
          other.fragment_id == this.fragment_id &&
          other.memory_group_id == this.memory_group_id &&
          other.next_plan_show_time == this.next_plan_show_time &&
          other.show_familiarity == this.show_familiarity &&
          other.created_at == this.created_at &&
          other.id == this.id &&
          other.updated_at == this.updated_at);
}

class FragmentMemoryInfosCompanion extends UpdateCompanion<FragmentMemoryInfo> {
  Value<String?> click_time;
  Value<String?> click_value;
  Value<int> creator_user_id;
  Value<String?> current_actual_show_time;
  Value<String> fragment_id;
  Value<String> memory_group_id;
  Value<String?> next_plan_show_time;
  Value<String?> show_familiarity;
  Value<DateTime> created_at;
  Value<String> id;
  Value<DateTime> updated_at;
  FragmentMemoryInfosCompanion({
    this.click_time = const Value.absent(),
    this.click_value = const Value.absent(),
    this.creator_user_id = const Value.absent(),
    this.current_actual_show_time = const Value.absent(),
    this.fragment_id = const Value.absent(),
    this.memory_group_id = const Value.absent(),
    this.next_plan_show_time = const Value.absent(),
    this.show_familiarity = const Value.absent(),
    this.created_at = const Value.absent(),
    this.id = const Value.absent(),
    this.updated_at = const Value.absent(),
  });
  FragmentMemoryInfosCompanion.insert({
    this.click_time = const Value.absent(),
    this.click_value = const Value.absent(),
    required int creator_user_id,
    this.current_actual_show_time = const Value.absent(),
    required String fragment_id,
    required String memory_group_id,
    this.next_plan_show_time = const Value.absent(),
    this.show_familiarity = const Value.absent(),
    required DateTime created_at,
    required String id,
    required DateTime updated_at,
  })  : creator_user_id = Value(creator_user_id),
        fragment_id = Value(fragment_id),
        memory_group_id = Value(memory_group_id),
        created_at = Value(created_at),
        id = Value(id),
        updated_at = Value(updated_at);
  static Insertable<FragmentMemoryInfo> custom({
    Expression<String>? click_time,
    Expression<String>? click_value,
    Expression<int>? creator_user_id,
    Expression<String>? current_actual_show_time,
    Expression<String>? fragment_id,
    Expression<String>? memory_group_id,
    Expression<String>? next_plan_show_time,
    Expression<String>? show_familiarity,
    Expression<DateTime>? created_at,
    Expression<String>? id,
    Expression<DateTime>? updated_at,
  }) {
    return RawValuesInsertable({
      if (click_time != null) 'click_time': click_time,
      if (click_value != null) 'click_value': click_value,
      if (creator_user_id != null) 'creator_user_id': creator_user_id,
      if (current_actual_show_time != null)
        'current_actual_show_time': current_actual_show_time,
      if (fragment_id != null) 'fragment_id': fragment_id,
      if (memory_group_id != null) 'memory_group_id': memory_group_id,
      if (next_plan_show_time != null)
        'next_plan_show_time': next_plan_show_time,
      if (show_familiarity != null) 'show_familiarity': show_familiarity,
      if (created_at != null) 'created_at': created_at,
      if (id != null) 'id': id,
      if (updated_at != null) 'updated_at': updated_at,
    });
  }

  FragmentMemoryInfosCompanion copyWith(
      {Value<String?>? click_time,
      Value<String?>? click_value,
      Value<int>? creator_user_id,
      Value<String?>? current_actual_show_time,
      Value<String>? fragment_id,
      Value<String>? memory_group_id,
      Value<String?>? next_plan_show_time,
      Value<String?>? show_familiarity,
      Value<DateTime>? created_at,
      Value<String>? id,
      Value<DateTime>? updated_at}) {
    return FragmentMemoryInfosCompanion(
      click_time: click_time ?? this.click_time,
      click_value: click_value ?? this.click_value,
      creator_user_id: creator_user_id ?? this.creator_user_id,
      current_actual_show_time:
          current_actual_show_time ?? this.current_actual_show_time,
      fragment_id: fragment_id ?? this.fragment_id,
      memory_group_id: memory_group_id ?? this.memory_group_id,
      next_plan_show_time: next_plan_show_time ?? this.next_plan_show_time,
      show_familiarity: show_familiarity ?? this.show_familiarity,
      created_at: created_at ?? this.created_at,
      id: id ?? this.id,
      updated_at: updated_at ?? this.updated_at,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (click_time.present) {
      map['click_time'] = Variable<String>(click_time.value);
    }
    if (click_value.present) {
      map['click_value'] = Variable<String>(click_value.value);
    }
    if (creator_user_id.present) {
      map['creator_user_id'] = Variable<int>(creator_user_id.value);
    }
    if (current_actual_show_time.present) {
      map['current_actual_show_time'] =
          Variable<String>(current_actual_show_time.value);
    }
    if (fragment_id.present) {
      map['fragment_id'] = Variable<String>(fragment_id.value);
    }
    if (memory_group_id.present) {
      map['memory_group_id'] = Variable<String>(memory_group_id.value);
    }
    if (next_plan_show_time.present) {
      map['next_plan_show_time'] = Variable<String>(next_plan_show_time.value);
    }
    if (show_familiarity.present) {
      map['show_familiarity'] = Variable<String>(show_familiarity.value);
    }
    if (created_at.present) {
      map['created_at'] = Variable<DateTime>(created_at.value);
    }
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (updated_at.present) {
      map['updated_at'] = Variable<DateTime>(updated_at.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('FragmentMemoryInfosCompanion(')
          ..write('click_time: $click_time, ')
          ..write('click_value: $click_value, ')
          ..write('creator_user_id: $creator_user_id, ')
          ..write('current_actual_show_time: $current_actual_show_time, ')
          ..write('fragment_id: $fragment_id, ')
          ..write('memory_group_id: $memory_group_id, ')
          ..write('next_plan_show_time: $next_plan_show_time, ')
          ..write('show_familiarity: $show_familiarity, ')
          ..write('created_at: $created_at, ')
          ..write('id: $id, ')
          ..write('updated_at: $updated_at')
          ..write(')'))
        .toString();
  }
}

class $FragmentMemoryInfosTable extends FragmentMemoryInfos
    with TableInfo<$FragmentMemoryInfosTable, FragmentMemoryInfo> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $FragmentMemoryInfosTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _click_timeMeta =
      const VerificationMeta('click_time');
  @override
  late final GeneratedColumn<String> click_time = GeneratedColumn<String>(
      'click_time', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _click_valueMeta =
      const VerificationMeta('click_value');
  @override
  late final GeneratedColumn<String> click_value = GeneratedColumn<String>(
      'click_value', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _creator_user_idMeta =
      const VerificationMeta('creator_user_id');
  @override
  late final GeneratedColumn<int> creator_user_id = GeneratedColumn<int>(
      'creator_user_id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _current_actual_show_timeMeta =
      const VerificationMeta('current_actual_show_time');
  @override
  late final GeneratedColumn<String> current_actual_show_time =
      GeneratedColumn<String>('current_actual_show_time', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _fragment_idMeta =
      const VerificationMeta('fragment_id');
  @override
  late final GeneratedColumn<String> fragment_id = GeneratedColumn<String>(
      'fragment_id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _memory_group_idMeta =
      const VerificationMeta('memory_group_id');
  @override
  late final GeneratedColumn<String> memory_group_id = GeneratedColumn<String>(
      'memory_group_id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _next_plan_show_timeMeta =
      const VerificationMeta('next_plan_show_time');
  @override
  late final GeneratedColumn<String> next_plan_show_time =
      GeneratedColumn<String>('next_plan_show_time', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _show_familiarityMeta =
      const VerificationMeta('show_familiarity');
  @override
  late final GeneratedColumn<String> show_familiarity = GeneratedColumn<String>(
      'show_familiarity', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _created_atMeta =
      const VerificationMeta('created_at');
  @override
  late final GeneratedColumn<DateTime> created_at = GeneratedColumn<DateTime>(
      'created_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _updated_atMeta =
      const VerificationMeta('updated_at');
  @override
  late final GeneratedColumn<DateTime> updated_at = GeneratedColumn<DateTime>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns => [
        click_time,
        click_value,
        creator_user_id,
        current_actual_show_time,
        fragment_id,
        memory_group_id,
        next_plan_show_time,
        show_familiarity,
        created_at,
        id,
        updated_at
      ];
  @override
  String get aliasedName => _alias ?? 'fragment_memory_infos';
  @override
  String get actualTableName => 'fragment_memory_infos';
  @override
  VerificationContext validateIntegrity(Insertable<FragmentMemoryInfo> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('click_time')) {
      context.handle(
          _click_timeMeta,
          click_time.isAcceptableOrUnknown(
              data['click_time']!, _click_timeMeta));
    }
    if (data.containsKey('click_value')) {
      context.handle(
          _click_valueMeta,
          click_value.isAcceptableOrUnknown(
              data['click_value']!, _click_valueMeta));
    }
    if (data.containsKey('creator_user_id')) {
      context.handle(
          _creator_user_idMeta,
          creator_user_id.isAcceptableOrUnknown(
              data['creator_user_id']!, _creator_user_idMeta));
    } else if (isInserting) {
      context.missing(_creator_user_idMeta);
    }
    if (data.containsKey('current_actual_show_time')) {
      context.handle(
          _current_actual_show_timeMeta,
          current_actual_show_time.isAcceptableOrUnknown(
              data['current_actual_show_time']!,
              _current_actual_show_timeMeta));
    }
    if (data.containsKey('fragment_id')) {
      context.handle(
          _fragment_idMeta,
          fragment_id.isAcceptableOrUnknown(
              data['fragment_id']!, _fragment_idMeta));
    } else if (isInserting) {
      context.missing(_fragment_idMeta);
    }
    if (data.containsKey('memory_group_id')) {
      context.handle(
          _memory_group_idMeta,
          memory_group_id.isAcceptableOrUnknown(
              data['memory_group_id']!, _memory_group_idMeta));
    } else if (isInserting) {
      context.missing(_memory_group_idMeta);
    }
    if (data.containsKey('next_plan_show_time')) {
      context.handle(
          _next_plan_show_timeMeta,
          next_plan_show_time.isAcceptableOrUnknown(
              data['next_plan_show_time']!, _next_plan_show_timeMeta));
    }
    if (data.containsKey('show_familiarity')) {
      context.handle(
          _show_familiarityMeta,
          show_familiarity.isAcceptableOrUnknown(
              data['show_familiarity']!, _show_familiarityMeta));
    }
    if (data.containsKey('created_at')) {
      context.handle(
          _created_atMeta,
          created_at.isAcceptableOrUnknown(
              data['created_at']!, _created_atMeta));
    } else if (isInserting) {
      context.missing(_created_atMeta);
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
          _updated_atMeta,
          updated_at.isAcceptableOrUnknown(
              data['updated_at']!, _updated_atMeta));
    } else if (isInserting) {
      context.missing(_updated_atMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  FragmentMemoryInfo map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return FragmentMemoryInfo(
      click_time: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}click_time']),
      click_value: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}click_value']),
      creator_user_id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}creator_user_id'])!,
      current_actual_show_time: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}current_actual_show_time']),
      fragment_id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}fragment_id'])!,
      memory_group_id: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}memory_group_id'])!,
      next_plan_show_time: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}next_plan_show_time']),
      show_familiarity: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}show_familiarity']),
      created_at: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_at'])!,
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id'])!,
      updated_at: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}updated_at'])!,
    );
  }

  @override
  $FragmentMemoryInfosTable createAlias(String alias) {
    return $FragmentMemoryInfosTable(attachedDatabase, alias);
  }
}

class RDocument2DocumentGroup extends DataClass
    implements Insertable<RDocument2DocumentGroup> {
  int creator_user_id;
  String? document_group_id;
  String document_id;
  DateTime created_at;
  String id;
  DateTime updated_at;
  RDocument2DocumentGroup(
      {required this.creator_user_id,
      this.document_group_id,
      required this.document_id,
      required this.created_at,
      required this.id,
      required this.updated_at});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['creator_user_id'] = Variable<int>(creator_user_id);
    if (!nullToAbsent || document_group_id != null) {
      map['document_group_id'] = Variable<String>(document_group_id);
    }
    map['document_id'] = Variable<String>(document_id);
    map['created_at'] = Variable<DateTime>(created_at);
    map['id'] = Variable<String>(id);
    map['updated_at'] = Variable<DateTime>(updated_at);
    return map;
  }

  RDocument2DocumentGroupsCompanion toCompanion(bool nullToAbsent) {
    return RDocument2DocumentGroupsCompanion(
      creator_user_id: Value(creator_user_id),
      document_group_id: document_group_id == null && nullToAbsent
          ? const Value.absent()
          : Value(document_group_id),
      document_id: Value(document_id),
      created_at: Value(created_at),
      id: Value(id),
      updated_at: Value(updated_at),
    );
  }

  factory RDocument2DocumentGroup.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return RDocument2DocumentGroup(
      creator_user_id: serializer.fromJson<int>(json['creator_user_id']),
      document_group_id:
          serializer.fromJson<String?>(json['document_group_id']),
      document_id: serializer.fromJson<String>(json['document_id']),
      created_at: serializer.fromJson<DateTime>(json['created_at']),
      id: serializer.fromJson<String>(json['id']),
      updated_at: serializer.fromJson<DateTime>(json['updated_at']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'creator_user_id': serializer.toJson<int>(creator_user_id),
      'document_group_id': serializer.toJson<String?>(document_group_id),
      'document_id': serializer.toJson<String>(document_id),
      'created_at': serializer.toJson<DateTime>(created_at),
      'id': serializer.toJson<String>(id),
      'updated_at': serializer.toJson<DateTime>(updated_at),
    };
  }

  RDocument2DocumentGroup copyWith(
          {int? creator_user_id,
          Value<String?> document_group_id = const Value.absent(),
          String? document_id,
          DateTime? created_at,
          String? id,
          DateTime? updated_at}) =>
      RDocument2DocumentGroup(
        creator_user_id: creator_user_id ?? this.creator_user_id,
        document_group_id: document_group_id.present
            ? document_group_id.value
            : this.document_group_id,
        document_id: document_id ?? this.document_id,
        created_at: created_at ?? this.created_at,
        id: id ?? this.id,
        updated_at: updated_at ?? this.updated_at,
      );
  @override
  String toString() {
    return (StringBuffer('RDocument2DocumentGroup(')
          ..write('creator_user_id: $creator_user_id, ')
          ..write('document_group_id: $document_group_id, ')
          ..write('document_id: $document_id, ')
          ..write('created_at: $created_at, ')
          ..write('id: $id, ')
          ..write('updated_at: $updated_at')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(creator_user_id, document_group_id,
      document_id, created_at, id, updated_at);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is RDocument2DocumentGroup &&
          other.creator_user_id == this.creator_user_id &&
          other.document_group_id == this.document_group_id &&
          other.document_id == this.document_id &&
          other.created_at == this.created_at &&
          other.id == this.id &&
          other.updated_at == this.updated_at);
}

class RDocument2DocumentGroupsCompanion
    extends UpdateCompanion<RDocument2DocumentGroup> {
  Value<int> creator_user_id;
  Value<String?> document_group_id;
  Value<String> document_id;
  Value<DateTime> created_at;
  Value<String> id;
  Value<DateTime> updated_at;
  RDocument2DocumentGroupsCompanion({
    this.creator_user_id = const Value.absent(),
    this.document_group_id = const Value.absent(),
    this.document_id = const Value.absent(),
    this.created_at = const Value.absent(),
    this.id = const Value.absent(),
    this.updated_at = const Value.absent(),
  });
  RDocument2DocumentGroupsCompanion.insert({
    required int creator_user_id,
    this.document_group_id = const Value.absent(),
    required String document_id,
    required DateTime created_at,
    required String id,
    required DateTime updated_at,
  })  : creator_user_id = Value(creator_user_id),
        document_id = Value(document_id),
        created_at = Value(created_at),
        id = Value(id),
        updated_at = Value(updated_at);
  static Insertable<RDocument2DocumentGroup> custom({
    Expression<int>? creator_user_id,
    Expression<String>? document_group_id,
    Expression<String>? document_id,
    Expression<DateTime>? created_at,
    Expression<String>? id,
    Expression<DateTime>? updated_at,
  }) {
    return RawValuesInsertable({
      if (creator_user_id != null) 'creator_user_id': creator_user_id,
      if (document_group_id != null) 'document_group_id': document_group_id,
      if (document_id != null) 'document_id': document_id,
      if (created_at != null) 'created_at': created_at,
      if (id != null) 'id': id,
      if (updated_at != null) 'updated_at': updated_at,
    });
  }

  RDocument2DocumentGroupsCompanion copyWith(
      {Value<int>? creator_user_id,
      Value<String?>? document_group_id,
      Value<String>? document_id,
      Value<DateTime>? created_at,
      Value<String>? id,
      Value<DateTime>? updated_at}) {
    return RDocument2DocumentGroupsCompanion(
      creator_user_id: creator_user_id ?? this.creator_user_id,
      document_group_id: document_group_id ?? this.document_group_id,
      document_id: document_id ?? this.document_id,
      created_at: created_at ?? this.created_at,
      id: id ?? this.id,
      updated_at: updated_at ?? this.updated_at,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (creator_user_id.present) {
      map['creator_user_id'] = Variable<int>(creator_user_id.value);
    }
    if (document_group_id.present) {
      map['document_group_id'] = Variable<String>(document_group_id.value);
    }
    if (document_id.present) {
      map['document_id'] = Variable<String>(document_id.value);
    }
    if (created_at.present) {
      map['created_at'] = Variable<DateTime>(created_at.value);
    }
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (updated_at.present) {
      map['updated_at'] = Variable<DateTime>(updated_at.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('RDocument2DocumentGroupsCompanion(')
          ..write('creator_user_id: $creator_user_id, ')
          ..write('document_group_id: $document_group_id, ')
          ..write('document_id: $document_id, ')
          ..write('created_at: $created_at, ')
          ..write('id: $id, ')
          ..write('updated_at: $updated_at')
          ..write(')'))
        .toString();
  }
}

class $RDocument2DocumentGroupsTable extends RDocument2DocumentGroups
    with TableInfo<$RDocument2DocumentGroupsTable, RDocument2DocumentGroup> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $RDocument2DocumentGroupsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _creator_user_idMeta =
      const VerificationMeta('creator_user_id');
  @override
  late final GeneratedColumn<int> creator_user_id = GeneratedColumn<int>(
      'creator_user_id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _document_group_idMeta =
      const VerificationMeta('document_group_id');
  @override
  late final GeneratedColumn<String> document_group_id =
      GeneratedColumn<String>('document_group_id', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _document_idMeta =
      const VerificationMeta('document_id');
  @override
  late final GeneratedColumn<String> document_id = GeneratedColumn<String>(
      'document_id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _created_atMeta =
      const VerificationMeta('created_at');
  @override
  late final GeneratedColumn<DateTime> created_at = GeneratedColumn<DateTime>(
      'created_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _updated_atMeta =
      const VerificationMeta('updated_at');
  @override
  late final GeneratedColumn<DateTime> updated_at = GeneratedColumn<DateTime>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns => [
        creator_user_id,
        document_group_id,
        document_id,
        created_at,
        id,
        updated_at
      ];
  @override
  String get aliasedName => _alias ?? 'r_document2_document_groups';
  @override
  String get actualTableName => 'r_document2_document_groups';
  @override
  VerificationContext validateIntegrity(
      Insertable<RDocument2DocumentGroup> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('creator_user_id')) {
      context.handle(
          _creator_user_idMeta,
          creator_user_id.isAcceptableOrUnknown(
              data['creator_user_id']!, _creator_user_idMeta));
    } else if (isInserting) {
      context.missing(_creator_user_idMeta);
    }
    if (data.containsKey('document_group_id')) {
      context.handle(
          _document_group_idMeta,
          document_group_id.isAcceptableOrUnknown(
              data['document_group_id']!, _document_group_idMeta));
    }
    if (data.containsKey('document_id')) {
      context.handle(
          _document_idMeta,
          document_id.isAcceptableOrUnknown(
              data['document_id']!, _document_idMeta));
    } else if (isInserting) {
      context.missing(_document_idMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(
          _created_atMeta,
          created_at.isAcceptableOrUnknown(
              data['created_at']!, _created_atMeta));
    } else if (isInserting) {
      context.missing(_created_atMeta);
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
          _updated_atMeta,
          updated_at.isAcceptableOrUnknown(
              data['updated_at']!, _updated_atMeta));
    } else if (isInserting) {
      context.missing(_updated_atMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  RDocument2DocumentGroup map(Map<String, dynamic> data,
      {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return RDocument2DocumentGroup(
      creator_user_id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}creator_user_id'])!,
      document_group_id: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}document_group_id']),
      document_id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}document_id'])!,
      created_at: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_at'])!,
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id'])!,
      updated_at: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}updated_at'])!,
    );
  }

  @override
  $RDocument2DocumentGroupsTable createAlias(String alias) {
    return $RDocument2DocumentGroupsTable(attachedDatabase, alias);
  }
}

class RFragment2FragmentGroup extends DataClass
    implements Insertable<RFragment2FragmentGroup> {
  int creator_user_id;
  String? fragment_group_id;
  String fragment_id;
  DateTime created_at;
  String id;
  DateTime updated_at;
  RFragment2FragmentGroup(
      {required this.creator_user_id,
      this.fragment_group_id,
      required this.fragment_id,
      required this.created_at,
      required this.id,
      required this.updated_at});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['creator_user_id'] = Variable<int>(creator_user_id);
    if (!nullToAbsent || fragment_group_id != null) {
      map['fragment_group_id'] = Variable<String>(fragment_group_id);
    }
    map['fragment_id'] = Variable<String>(fragment_id);
    map['created_at'] = Variable<DateTime>(created_at);
    map['id'] = Variable<String>(id);
    map['updated_at'] = Variable<DateTime>(updated_at);
    return map;
  }

  RFragment2FragmentGroupsCompanion toCompanion(bool nullToAbsent) {
    return RFragment2FragmentGroupsCompanion(
      creator_user_id: Value(creator_user_id),
      fragment_group_id: fragment_group_id == null && nullToAbsent
          ? const Value.absent()
          : Value(fragment_group_id),
      fragment_id: Value(fragment_id),
      created_at: Value(created_at),
      id: Value(id),
      updated_at: Value(updated_at),
    );
  }

  factory RFragment2FragmentGroup.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return RFragment2FragmentGroup(
      creator_user_id: serializer.fromJson<int>(json['creator_user_id']),
      fragment_group_id:
          serializer.fromJson<String?>(json['fragment_group_id']),
      fragment_id: serializer.fromJson<String>(json['fragment_id']),
      created_at: serializer.fromJson<DateTime>(json['created_at']),
      id: serializer.fromJson<String>(json['id']),
      updated_at: serializer.fromJson<DateTime>(json['updated_at']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'creator_user_id': serializer.toJson<int>(creator_user_id),
      'fragment_group_id': serializer.toJson<String?>(fragment_group_id),
      'fragment_id': serializer.toJson<String>(fragment_id),
      'created_at': serializer.toJson<DateTime>(created_at),
      'id': serializer.toJson<String>(id),
      'updated_at': serializer.toJson<DateTime>(updated_at),
    };
  }

  RFragment2FragmentGroup copyWith(
          {int? creator_user_id,
          Value<String?> fragment_group_id = const Value.absent(),
          String? fragment_id,
          DateTime? created_at,
          String? id,
          DateTime? updated_at}) =>
      RFragment2FragmentGroup(
        creator_user_id: creator_user_id ?? this.creator_user_id,
        fragment_group_id: fragment_group_id.present
            ? fragment_group_id.value
            : this.fragment_group_id,
        fragment_id: fragment_id ?? this.fragment_id,
        created_at: created_at ?? this.created_at,
        id: id ?? this.id,
        updated_at: updated_at ?? this.updated_at,
      );
  @override
  String toString() {
    return (StringBuffer('RFragment2FragmentGroup(')
          ..write('creator_user_id: $creator_user_id, ')
          ..write('fragment_group_id: $fragment_group_id, ')
          ..write('fragment_id: $fragment_id, ')
          ..write('created_at: $created_at, ')
          ..write('id: $id, ')
          ..write('updated_at: $updated_at')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(creator_user_id, fragment_group_id,
      fragment_id, created_at, id, updated_at);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is RFragment2FragmentGroup &&
          other.creator_user_id == this.creator_user_id &&
          other.fragment_group_id == this.fragment_group_id &&
          other.fragment_id == this.fragment_id &&
          other.created_at == this.created_at &&
          other.id == this.id &&
          other.updated_at == this.updated_at);
}

class RFragment2FragmentGroupsCompanion
    extends UpdateCompanion<RFragment2FragmentGroup> {
  Value<int> creator_user_id;
  Value<String?> fragment_group_id;
  Value<String> fragment_id;
  Value<DateTime> created_at;
  Value<String> id;
  Value<DateTime> updated_at;
  RFragment2FragmentGroupsCompanion({
    this.creator_user_id = const Value.absent(),
    this.fragment_group_id = const Value.absent(),
    this.fragment_id = const Value.absent(),
    this.created_at = const Value.absent(),
    this.id = const Value.absent(),
    this.updated_at = const Value.absent(),
  });
  RFragment2FragmentGroupsCompanion.insert({
    required int creator_user_id,
    this.fragment_group_id = const Value.absent(),
    required String fragment_id,
    required DateTime created_at,
    required String id,
    required DateTime updated_at,
  })  : creator_user_id = Value(creator_user_id),
        fragment_id = Value(fragment_id),
        created_at = Value(created_at),
        id = Value(id),
        updated_at = Value(updated_at);
  static Insertable<RFragment2FragmentGroup> custom({
    Expression<int>? creator_user_id,
    Expression<String>? fragment_group_id,
    Expression<String>? fragment_id,
    Expression<DateTime>? created_at,
    Expression<String>? id,
    Expression<DateTime>? updated_at,
  }) {
    return RawValuesInsertable({
      if (creator_user_id != null) 'creator_user_id': creator_user_id,
      if (fragment_group_id != null) 'fragment_group_id': fragment_group_id,
      if (fragment_id != null) 'fragment_id': fragment_id,
      if (created_at != null) 'created_at': created_at,
      if (id != null) 'id': id,
      if (updated_at != null) 'updated_at': updated_at,
    });
  }

  RFragment2FragmentGroupsCompanion copyWith(
      {Value<int>? creator_user_id,
      Value<String?>? fragment_group_id,
      Value<String>? fragment_id,
      Value<DateTime>? created_at,
      Value<String>? id,
      Value<DateTime>? updated_at}) {
    return RFragment2FragmentGroupsCompanion(
      creator_user_id: creator_user_id ?? this.creator_user_id,
      fragment_group_id: fragment_group_id ?? this.fragment_group_id,
      fragment_id: fragment_id ?? this.fragment_id,
      created_at: created_at ?? this.created_at,
      id: id ?? this.id,
      updated_at: updated_at ?? this.updated_at,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (creator_user_id.present) {
      map['creator_user_id'] = Variable<int>(creator_user_id.value);
    }
    if (fragment_group_id.present) {
      map['fragment_group_id'] = Variable<String>(fragment_group_id.value);
    }
    if (fragment_id.present) {
      map['fragment_id'] = Variable<String>(fragment_id.value);
    }
    if (created_at.present) {
      map['created_at'] = Variable<DateTime>(created_at.value);
    }
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (updated_at.present) {
      map['updated_at'] = Variable<DateTime>(updated_at.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('RFragment2FragmentGroupsCompanion(')
          ..write('creator_user_id: $creator_user_id, ')
          ..write('fragment_group_id: $fragment_group_id, ')
          ..write('fragment_id: $fragment_id, ')
          ..write('created_at: $created_at, ')
          ..write('id: $id, ')
          ..write('updated_at: $updated_at')
          ..write(')'))
        .toString();
  }
}

class $RFragment2FragmentGroupsTable extends RFragment2FragmentGroups
    with TableInfo<$RFragment2FragmentGroupsTable, RFragment2FragmentGroup> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $RFragment2FragmentGroupsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _creator_user_idMeta =
      const VerificationMeta('creator_user_id');
  @override
  late final GeneratedColumn<int> creator_user_id = GeneratedColumn<int>(
      'creator_user_id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _fragment_group_idMeta =
      const VerificationMeta('fragment_group_id');
  @override
  late final GeneratedColumn<String> fragment_group_id =
      GeneratedColumn<String>('fragment_group_id', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _fragment_idMeta =
      const VerificationMeta('fragment_id');
  @override
  late final GeneratedColumn<String> fragment_id = GeneratedColumn<String>(
      'fragment_id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _created_atMeta =
      const VerificationMeta('created_at');
  @override
  late final GeneratedColumn<DateTime> created_at = GeneratedColumn<DateTime>(
      'created_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _updated_atMeta =
      const VerificationMeta('updated_at');
  @override
  late final GeneratedColumn<DateTime> updated_at = GeneratedColumn<DateTime>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns => [
        creator_user_id,
        fragment_group_id,
        fragment_id,
        created_at,
        id,
        updated_at
      ];
  @override
  String get aliasedName => _alias ?? 'r_fragment2_fragment_groups';
  @override
  String get actualTableName => 'r_fragment2_fragment_groups';
  @override
  VerificationContext validateIntegrity(
      Insertable<RFragment2FragmentGroup> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('creator_user_id')) {
      context.handle(
          _creator_user_idMeta,
          creator_user_id.isAcceptableOrUnknown(
              data['creator_user_id']!, _creator_user_idMeta));
    } else if (isInserting) {
      context.missing(_creator_user_idMeta);
    }
    if (data.containsKey('fragment_group_id')) {
      context.handle(
          _fragment_group_idMeta,
          fragment_group_id.isAcceptableOrUnknown(
              data['fragment_group_id']!, _fragment_group_idMeta));
    }
    if (data.containsKey('fragment_id')) {
      context.handle(
          _fragment_idMeta,
          fragment_id.isAcceptableOrUnknown(
              data['fragment_id']!, _fragment_idMeta));
    } else if (isInserting) {
      context.missing(_fragment_idMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(
          _created_atMeta,
          created_at.isAcceptableOrUnknown(
              data['created_at']!, _created_atMeta));
    } else if (isInserting) {
      context.missing(_created_atMeta);
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
          _updated_atMeta,
          updated_at.isAcceptableOrUnknown(
              data['updated_at']!, _updated_atMeta));
    } else if (isInserting) {
      context.missing(_updated_atMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  RFragment2FragmentGroup map(Map<String, dynamic> data,
      {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return RFragment2FragmentGroup(
      creator_user_id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}creator_user_id'])!,
      fragment_group_id: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}fragment_group_id']),
      fragment_id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}fragment_id'])!,
      created_at: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_at'])!,
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id'])!,
      updated_at: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}updated_at'])!,
    );
  }

  @override
  $RFragment2FragmentGroupsTable createAlias(String alias) {
    return $RFragment2FragmentGroupsTable(attachedDatabase, alias);
  }
}

class RNote2NoteGroup extends DataClass implements Insertable<RNote2NoteGroup> {
  int creator_user_id;
  String? note_group_id;
  String note_id;
  DateTime created_at;
  String id;
  DateTime updated_at;
  RNote2NoteGroup(
      {required this.creator_user_id,
      this.note_group_id,
      required this.note_id,
      required this.created_at,
      required this.id,
      required this.updated_at});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['creator_user_id'] = Variable<int>(creator_user_id);
    if (!nullToAbsent || note_group_id != null) {
      map['note_group_id'] = Variable<String>(note_group_id);
    }
    map['note_id'] = Variable<String>(note_id);
    map['created_at'] = Variable<DateTime>(created_at);
    map['id'] = Variable<String>(id);
    map['updated_at'] = Variable<DateTime>(updated_at);
    return map;
  }

  RNote2NoteGroupsCompanion toCompanion(bool nullToAbsent) {
    return RNote2NoteGroupsCompanion(
      creator_user_id: Value(creator_user_id),
      note_group_id: note_group_id == null && nullToAbsent
          ? const Value.absent()
          : Value(note_group_id),
      note_id: Value(note_id),
      created_at: Value(created_at),
      id: Value(id),
      updated_at: Value(updated_at),
    );
  }

  factory RNote2NoteGroup.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return RNote2NoteGroup(
      creator_user_id: serializer.fromJson<int>(json['creator_user_id']),
      note_group_id: serializer.fromJson<String?>(json['note_group_id']),
      note_id: serializer.fromJson<String>(json['note_id']),
      created_at: serializer.fromJson<DateTime>(json['created_at']),
      id: serializer.fromJson<String>(json['id']),
      updated_at: serializer.fromJson<DateTime>(json['updated_at']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'creator_user_id': serializer.toJson<int>(creator_user_id),
      'note_group_id': serializer.toJson<String?>(note_group_id),
      'note_id': serializer.toJson<String>(note_id),
      'created_at': serializer.toJson<DateTime>(created_at),
      'id': serializer.toJson<String>(id),
      'updated_at': serializer.toJson<DateTime>(updated_at),
    };
  }

  RNote2NoteGroup copyWith(
          {int? creator_user_id,
          Value<String?> note_group_id = const Value.absent(),
          String? note_id,
          DateTime? created_at,
          String? id,
          DateTime? updated_at}) =>
      RNote2NoteGroup(
        creator_user_id: creator_user_id ?? this.creator_user_id,
        note_group_id:
            note_group_id.present ? note_group_id.value : this.note_group_id,
        note_id: note_id ?? this.note_id,
        created_at: created_at ?? this.created_at,
        id: id ?? this.id,
        updated_at: updated_at ?? this.updated_at,
      );
  @override
  String toString() {
    return (StringBuffer('RNote2NoteGroup(')
          ..write('creator_user_id: $creator_user_id, ')
          ..write('note_group_id: $note_group_id, ')
          ..write('note_id: $note_id, ')
          ..write('created_at: $created_at, ')
          ..write('id: $id, ')
          ..write('updated_at: $updated_at')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      creator_user_id, note_group_id, note_id, created_at, id, updated_at);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is RNote2NoteGroup &&
          other.creator_user_id == this.creator_user_id &&
          other.note_group_id == this.note_group_id &&
          other.note_id == this.note_id &&
          other.created_at == this.created_at &&
          other.id == this.id &&
          other.updated_at == this.updated_at);
}

class RNote2NoteGroupsCompanion extends UpdateCompanion<RNote2NoteGroup> {
  Value<int> creator_user_id;
  Value<String?> note_group_id;
  Value<String> note_id;
  Value<DateTime> created_at;
  Value<String> id;
  Value<DateTime> updated_at;
  RNote2NoteGroupsCompanion({
    this.creator_user_id = const Value.absent(),
    this.note_group_id = const Value.absent(),
    this.note_id = const Value.absent(),
    this.created_at = const Value.absent(),
    this.id = const Value.absent(),
    this.updated_at = const Value.absent(),
  });
  RNote2NoteGroupsCompanion.insert({
    required int creator_user_id,
    this.note_group_id = const Value.absent(),
    required String note_id,
    required DateTime created_at,
    required String id,
    required DateTime updated_at,
  })  : creator_user_id = Value(creator_user_id),
        note_id = Value(note_id),
        created_at = Value(created_at),
        id = Value(id),
        updated_at = Value(updated_at);
  static Insertable<RNote2NoteGroup> custom({
    Expression<int>? creator_user_id,
    Expression<String>? note_group_id,
    Expression<String>? note_id,
    Expression<DateTime>? created_at,
    Expression<String>? id,
    Expression<DateTime>? updated_at,
  }) {
    return RawValuesInsertable({
      if (creator_user_id != null) 'creator_user_id': creator_user_id,
      if (note_group_id != null) 'note_group_id': note_group_id,
      if (note_id != null) 'note_id': note_id,
      if (created_at != null) 'created_at': created_at,
      if (id != null) 'id': id,
      if (updated_at != null) 'updated_at': updated_at,
    });
  }

  RNote2NoteGroupsCompanion copyWith(
      {Value<int>? creator_user_id,
      Value<String?>? note_group_id,
      Value<String>? note_id,
      Value<DateTime>? created_at,
      Value<String>? id,
      Value<DateTime>? updated_at}) {
    return RNote2NoteGroupsCompanion(
      creator_user_id: creator_user_id ?? this.creator_user_id,
      note_group_id: note_group_id ?? this.note_group_id,
      note_id: note_id ?? this.note_id,
      created_at: created_at ?? this.created_at,
      id: id ?? this.id,
      updated_at: updated_at ?? this.updated_at,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (creator_user_id.present) {
      map['creator_user_id'] = Variable<int>(creator_user_id.value);
    }
    if (note_group_id.present) {
      map['note_group_id'] = Variable<String>(note_group_id.value);
    }
    if (note_id.present) {
      map['note_id'] = Variable<String>(note_id.value);
    }
    if (created_at.present) {
      map['created_at'] = Variable<DateTime>(created_at.value);
    }
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (updated_at.present) {
      map['updated_at'] = Variable<DateTime>(updated_at.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('RNote2NoteGroupsCompanion(')
          ..write('creator_user_id: $creator_user_id, ')
          ..write('note_group_id: $note_group_id, ')
          ..write('note_id: $note_id, ')
          ..write('created_at: $created_at, ')
          ..write('id: $id, ')
          ..write('updated_at: $updated_at')
          ..write(')'))
        .toString();
  }
}

class $RNote2NoteGroupsTable extends RNote2NoteGroups
    with TableInfo<$RNote2NoteGroupsTable, RNote2NoteGroup> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $RNote2NoteGroupsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _creator_user_idMeta =
      const VerificationMeta('creator_user_id');
  @override
  late final GeneratedColumn<int> creator_user_id = GeneratedColumn<int>(
      'creator_user_id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _note_group_idMeta =
      const VerificationMeta('note_group_id');
  @override
  late final GeneratedColumn<String> note_group_id = GeneratedColumn<String>(
      'note_group_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _note_idMeta =
      const VerificationMeta('note_id');
  @override
  late final GeneratedColumn<String> note_id = GeneratedColumn<String>(
      'note_id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _created_atMeta =
      const VerificationMeta('created_at');
  @override
  late final GeneratedColumn<DateTime> created_at = GeneratedColumn<DateTime>(
      'created_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _updated_atMeta =
      const VerificationMeta('updated_at');
  @override
  late final GeneratedColumn<DateTime> updated_at = GeneratedColumn<DateTime>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns =>
      [creator_user_id, note_group_id, note_id, created_at, id, updated_at];
  @override
  String get aliasedName => _alias ?? 'r_note2_note_groups';
  @override
  String get actualTableName => 'r_note2_note_groups';
  @override
  VerificationContext validateIntegrity(Insertable<RNote2NoteGroup> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('creator_user_id')) {
      context.handle(
          _creator_user_idMeta,
          creator_user_id.isAcceptableOrUnknown(
              data['creator_user_id']!, _creator_user_idMeta));
    } else if (isInserting) {
      context.missing(_creator_user_idMeta);
    }
    if (data.containsKey('note_group_id')) {
      context.handle(
          _note_group_idMeta,
          note_group_id.isAcceptableOrUnknown(
              data['note_group_id']!, _note_group_idMeta));
    }
    if (data.containsKey('note_id')) {
      context.handle(_note_idMeta,
          note_id.isAcceptableOrUnknown(data['note_id']!, _note_idMeta));
    } else if (isInserting) {
      context.missing(_note_idMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(
          _created_atMeta,
          created_at.isAcceptableOrUnknown(
              data['created_at']!, _created_atMeta));
    } else if (isInserting) {
      context.missing(_created_atMeta);
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
          _updated_atMeta,
          updated_at.isAcceptableOrUnknown(
              data['updated_at']!, _updated_atMeta));
    } else if (isInserting) {
      context.missing(_updated_atMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  RNote2NoteGroup map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return RNote2NoteGroup(
      creator_user_id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}creator_user_id'])!,
      note_group_id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}note_group_id']),
      note_id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}note_id'])!,
      created_at: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_at'])!,
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id'])!,
      updated_at: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}updated_at'])!,
    );
  }

  @override
  $RNote2NoteGroupsTable createAlias(String alias) {
    return $RNote2NoteGroupsTable(attachedDatabase, alias);
  }
}

class Test2 extends DataClass implements Insertable<Test2> {
  String client_content;
  DateTime created_at;
  int id;
  DateTime updated_at;
  Test2(
      {required this.client_content,
      required this.created_at,
      required this.id,
      required this.updated_at});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['client_content'] = Variable<String>(client_content);
    map['created_at'] = Variable<DateTime>(created_at);
    map['id'] = Variable<int>(id);
    map['updated_at'] = Variable<DateTime>(updated_at);
    return map;
  }

  Test2sCompanion toCompanion(bool nullToAbsent) {
    return Test2sCompanion(
      client_content: Value(client_content),
      created_at: Value(created_at),
      id: Value(id),
      updated_at: Value(updated_at),
    );
  }

  factory Test2.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Test2(
      client_content: serializer.fromJson<String>(json['client_content']),
      created_at: serializer.fromJson<DateTime>(json['created_at']),
      id: serializer.fromJson<int>(json['id']),
      updated_at: serializer.fromJson<DateTime>(json['updated_at']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'client_content': serializer.toJson<String>(client_content),
      'created_at': serializer.toJson<DateTime>(created_at),
      'id': serializer.toJson<int>(id),
      'updated_at': serializer.toJson<DateTime>(updated_at),
    };
  }

  Test2 copyWith(
          {String? client_content,
          DateTime? created_at,
          int? id,
          DateTime? updated_at}) =>
      Test2(
        client_content: client_content ?? this.client_content,
        created_at: created_at ?? this.created_at,
        id: id ?? this.id,
        updated_at: updated_at ?? this.updated_at,
      );
  @override
  String toString() {
    return (StringBuffer('Test2(')
          ..write('client_content: $client_content, ')
          ..write('created_at: $created_at, ')
          ..write('id: $id, ')
          ..write('updated_at: $updated_at')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(client_content, created_at, id, updated_at);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Test2 &&
          other.client_content == this.client_content &&
          other.created_at == this.created_at &&
          other.id == this.id &&
          other.updated_at == this.updated_at);
}

class Test2sCompanion extends UpdateCompanion<Test2> {
  Value<String> client_content;
  Value<DateTime> created_at;
  Value<int> id;
  Value<DateTime> updated_at;
  Test2sCompanion({
    this.client_content = const Value.absent(),
    this.created_at = const Value.absent(),
    this.id = const Value.absent(),
    this.updated_at = const Value.absent(),
  });
  Test2sCompanion.insert({
    required String client_content,
    required DateTime created_at,
    this.id = const Value.absent(),
    required DateTime updated_at,
  })  : client_content = Value(client_content),
        created_at = Value(created_at),
        updated_at = Value(updated_at);
  static Insertable<Test2> custom({
    Expression<String>? client_content,
    Expression<DateTime>? created_at,
    Expression<int>? id,
    Expression<DateTime>? updated_at,
  }) {
    return RawValuesInsertable({
      if (client_content != null) 'client_content': client_content,
      if (created_at != null) 'created_at': created_at,
      if (id != null) 'id': id,
      if (updated_at != null) 'updated_at': updated_at,
    });
  }

  Test2sCompanion copyWith(
      {Value<String>? client_content,
      Value<DateTime>? created_at,
      Value<int>? id,
      Value<DateTime>? updated_at}) {
    return Test2sCompanion(
      client_content: client_content ?? this.client_content,
      created_at: created_at ?? this.created_at,
      id: id ?? this.id,
      updated_at: updated_at ?? this.updated_at,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (client_content.present) {
      map['client_content'] = Variable<String>(client_content.value);
    }
    if (created_at.present) {
      map['created_at'] = Variable<DateTime>(created_at.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (updated_at.present) {
      map['updated_at'] = Variable<DateTime>(updated_at.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('Test2sCompanion(')
          ..write('client_content: $client_content, ')
          ..write('created_at: $created_at, ')
          ..write('id: $id, ')
          ..write('updated_at: $updated_at')
          ..write(')'))
        .toString();
  }
}

class $Test2sTable extends Test2s with TableInfo<$Test2sTable, Test2> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $Test2sTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _client_contentMeta =
      const VerificationMeta('client_content');
  @override
  late final GeneratedColumn<String> client_content = GeneratedColumn<String>(
      'client_content', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _created_atMeta =
      const VerificationMeta('created_at');
  @override
  late final GeneratedColumn<DateTime> created_at = GeneratedColumn<DateTime>(
      'created_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _updated_atMeta =
      const VerificationMeta('updated_at');
  @override
  late final GeneratedColumn<DateTime> updated_at = GeneratedColumn<DateTime>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns =>
      [client_content, created_at, id, updated_at];
  @override
  String get aliasedName => _alias ?? 'test2s';
  @override
  String get actualTableName => 'test2s';
  @override
  VerificationContext validateIntegrity(Insertable<Test2> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('client_content')) {
      context.handle(
          _client_contentMeta,
          client_content.isAcceptableOrUnknown(
              data['client_content']!, _client_contentMeta));
    } else if (isInserting) {
      context.missing(_client_contentMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(
          _created_atMeta,
          created_at.isAcceptableOrUnknown(
              data['created_at']!, _created_atMeta));
    } else if (isInserting) {
      context.missing(_created_atMeta);
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('updated_at')) {
      context.handle(
          _updated_atMeta,
          updated_at.isAcceptableOrUnknown(
              data['updated_at']!, _updated_atMeta));
    } else if (isInserting) {
      context.missing(_updated_atMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Test2 map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Test2(
      client_content: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}client_content'])!,
      created_at: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_at'])!,
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      updated_at: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}updated_at'])!,
    );
  }

  @override
  $Test2sTable createAlias(String alias) {
    return $Test2sTable(attachedDatabase, alias);
  }
}

class Test extends DataClass implements Insertable<Test> {
  String client_a;
  String client_content;
  DateTime created_at;
  int id;
  DateTime updated_at;
  Test(
      {required this.client_a,
      required this.client_content,
      required this.created_at,
      required this.id,
      required this.updated_at});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['client_a'] = Variable<String>(client_a);
    map['client_content'] = Variable<String>(client_content);
    map['created_at'] = Variable<DateTime>(created_at);
    map['id'] = Variable<int>(id);
    map['updated_at'] = Variable<DateTime>(updated_at);
    return map;
  }

  TestsCompanion toCompanion(bool nullToAbsent) {
    return TestsCompanion(
      client_a: Value(client_a),
      client_content: Value(client_content),
      created_at: Value(created_at),
      id: Value(id),
      updated_at: Value(updated_at),
    );
  }

  factory Test.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Test(
      client_a: serializer.fromJson<String>(json['client_a']),
      client_content: serializer.fromJson<String>(json['client_content']),
      created_at: serializer.fromJson<DateTime>(json['created_at']),
      id: serializer.fromJson<int>(json['id']),
      updated_at: serializer.fromJson<DateTime>(json['updated_at']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'client_a': serializer.toJson<String>(client_a),
      'client_content': serializer.toJson<String>(client_content),
      'created_at': serializer.toJson<DateTime>(created_at),
      'id': serializer.toJson<int>(id),
      'updated_at': serializer.toJson<DateTime>(updated_at),
    };
  }

  Test copyWith(
          {String? client_a,
          String? client_content,
          DateTime? created_at,
          int? id,
          DateTime? updated_at}) =>
      Test(
        client_a: client_a ?? this.client_a,
        client_content: client_content ?? this.client_content,
        created_at: created_at ?? this.created_at,
        id: id ?? this.id,
        updated_at: updated_at ?? this.updated_at,
      );
  @override
  String toString() {
    return (StringBuffer('Test(')
          ..write('client_a: $client_a, ')
          ..write('client_content: $client_content, ')
          ..write('created_at: $created_at, ')
          ..write('id: $id, ')
          ..write('updated_at: $updated_at')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(client_a, client_content, created_at, id, updated_at);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Test &&
          other.client_a == this.client_a &&
          other.client_content == this.client_content &&
          other.created_at == this.created_at &&
          other.id == this.id &&
          other.updated_at == this.updated_at);
}

class TestsCompanion extends UpdateCompanion<Test> {
  Value<String> client_a;
  Value<String> client_content;
  Value<DateTime> created_at;
  Value<int> id;
  Value<DateTime> updated_at;
  TestsCompanion({
    this.client_a = const Value.absent(),
    this.client_content = const Value.absent(),
    this.created_at = const Value.absent(),
    this.id = const Value.absent(),
    this.updated_at = const Value.absent(),
  });
  TestsCompanion.insert({
    required String client_a,
    required String client_content,
    required DateTime created_at,
    this.id = const Value.absent(),
    required DateTime updated_at,
  })  : client_a = Value(client_a),
        client_content = Value(client_content),
        created_at = Value(created_at),
        updated_at = Value(updated_at);
  static Insertable<Test> custom({
    Expression<String>? client_a,
    Expression<String>? client_content,
    Expression<DateTime>? created_at,
    Expression<int>? id,
    Expression<DateTime>? updated_at,
  }) {
    return RawValuesInsertable({
      if (client_a != null) 'client_a': client_a,
      if (client_content != null) 'client_content': client_content,
      if (created_at != null) 'created_at': created_at,
      if (id != null) 'id': id,
      if (updated_at != null) 'updated_at': updated_at,
    });
  }

  TestsCompanion copyWith(
      {Value<String>? client_a,
      Value<String>? client_content,
      Value<DateTime>? created_at,
      Value<int>? id,
      Value<DateTime>? updated_at}) {
    return TestsCompanion(
      client_a: client_a ?? this.client_a,
      client_content: client_content ?? this.client_content,
      created_at: created_at ?? this.created_at,
      id: id ?? this.id,
      updated_at: updated_at ?? this.updated_at,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (client_a.present) {
      map['client_a'] = Variable<String>(client_a.value);
    }
    if (client_content.present) {
      map['client_content'] = Variable<String>(client_content.value);
    }
    if (created_at.present) {
      map['created_at'] = Variable<DateTime>(created_at.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (updated_at.present) {
      map['updated_at'] = Variable<DateTime>(updated_at.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('TestsCompanion(')
          ..write('client_a: $client_a, ')
          ..write('client_content: $client_content, ')
          ..write('created_at: $created_at, ')
          ..write('id: $id, ')
          ..write('updated_at: $updated_at')
          ..write(')'))
        .toString();
  }
}

class $TestsTable extends Tests with TableInfo<$TestsTable, Test> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $TestsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _client_aMeta =
      const VerificationMeta('client_a');
  @override
  late final GeneratedColumn<String> client_a = GeneratedColumn<String>(
      'client_a', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _client_contentMeta =
      const VerificationMeta('client_content');
  @override
  late final GeneratedColumn<String> client_content = GeneratedColumn<String>(
      'client_content', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _created_atMeta =
      const VerificationMeta('created_at');
  @override
  late final GeneratedColumn<DateTime> created_at = GeneratedColumn<DateTime>(
      'created_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _updated_atMeta =
      const VerificationMeta('updated_at');
  @override
  late final GeneratedColumn<DateTime> updated_at = GeneratedColumn<DateTime>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns =>
      [client_a, client_content, created_at, id, updated_at];
  @override
  String get aliasedName => _alias ?? 'tests';
  @override
  String get actualTableName => 'tests';
  @override
  VerificationContext validateIntegrity(Insertable<Test> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('client_a')) {
      context.handle(_client_aMeta,
          client_a.isAcceptableOrUnknown(data['client_a']!, _client_aMeta));
    } else if (isInserting) {
      context.missing(_client_aMeta);
    }
    if (data.containsKey('client_content')) {
      context.handle(
          _client_contentMeta,
          client_content.isAcceptableOrUnknown(
              data['client_content']!, _client_contentMeta));
    } else if (isInserting) {
      context.missing(_client_contentMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(
          _created_atMeta,
          created_at.isAcceptableOrUnknown(
              data['created_at']!, _created_atMeta));
    } else if (isInserting) {
      context.missing(_created_atMeta);
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('updated_at')) {
      context.handle(
          _updated_atMeta,
          updated_at.isAcceptableOrUnknown(
              data['updated_at']!, _updated_atMeta));
    } else if (isInserting) {
      context.missing(_updated_atMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Test map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Test(
      client_a: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}client_a'])!,
      client_content: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}client_content'])!,
      created_at: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_at'])!,
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      updated_at: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}updated_at'])!,
    );
  }

  @override
  $TestsTable createAlias(String alias) {
    return $TestsTable(attachedDatabase, alias);
  }
}

class Document extends DataClass implements Insertable<Document> {
  String content;
  int creator_user_id;
  DateTime created_at;
  String id;
  DateTime updated_at;
  Document(
      {required this.content,
      required this.creator_user_id,
      required this.created_at,
      required this.id,
      required this.updated_at});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['content'] = Variable<String>(content);
    map['creator_user_id'] = Variable<int>(creator_user_id);
    map['created_at'] = Variable<DateTime>(created_at);
    map['id'] = Variable<String>(id);
    map['updated_at'] = Variable<DateTime>(updated_at);
    return map;
  }

  DocumentsCompanion toCompanion(bool nullToAbsent) {
    return DocumentsCompanion(
      content: Value(content),
      creator_user_id: Value(creator_user_id),
      created_at: Value(created_at),
      id: Value(id),
      updated_at: Value(updated_at),
    );
  }

  factory Document.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Document(
      content: serializer.fromJson<String>(json['content']),
      creator_user_id: serializer.fromJson<int>(json['creator_user_id']),
      created_at: serializer.fromJson<DateTime>(json['created_at']),
      id: serializer.fromJson<String>(json['id']),
      updated_at: serializer.fromJson<DateTime>(json['updated_at']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'content': serializer.toJson<String>(content),
      'creator_user_id': serializer.toJson<int>(creator_user_id),
      'created_at': serializer.toJson<DateTime>(created_at),
      'id': serializer.toJson<String>(id),
      'updated_at': serializer.toJson<DateTime>(updated_at),
    };
  }

  Document copyWith(
          {String? content,
          int? creator_user_id,
          DateTime? created_at,
          String? id,
          DateTime? updated_at}) =>
      Document(
        content: content ?? this.content,
        creator_user_id: creator_user_id ?? this.creator_user_id,
        created_at: created_at ?? this.created_at,
        id: id ?? this.id,
        updated_at: updated_at ?? this.updated_at,
      );
  @override
  String toString() {
    return (StringBuffer('Document(')
          ..write('content: $content, ')
          ..write('creator_user_id: $creator_user_id, ')
          ..write('created_at: $created_at, ')
          ..write('id: $id, ')
          ..write('updated_at: $updated_at')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(content, creator_user_id, created_at, id, updated_at);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Document &&
          other.content == this.content &&
          other.creator_user_id == this.creator_user_id &&
          other.created_at == this.created_at &&
          other.id == this.id &&
          other.updated_at == this.updated_at);
}

class DocumentsCompanion extends UpdateCompanion<Document> {
  Value<String> content;
  Value<int> creator_user_id;
  Value<DateTime> created_at;
  Value<String> id;
  Value<DateTime> updated_at;
  DocumentsCompanion({
    this.content = const Value.absent(),
    this.creator_user_id = const Value.absent(),
    this.created_at = const Value.absent(),
    this.id = const Value.absent(),
    this.updated_at = const Value.absent(),
  });
  DocumentsCompanion.insert({
    required String content,
    required int creator_user_id,
    required DateTime created_at,
    required String id,
    required DateTime updated_at,
  })  : content = Value(content),
        creator_user_id = Value(creator_user_id),
        created_at = Value(created_at),
        id = Value(id),
        updated_at = Value(updated_at);
  static Insertable<Document> custom({
    Expression<String>? content,
    Expression<int>? creator_user_id,
    Expression<DateTime>? created_at,
    Expression<String>? id,
    Expression<DateTime>? updated_at,
  }) {
    return RawValuesInsertable({
      if (content != null) 'content': content,
      if (creator_user_id != null) 'creator_user_id': creator_user_id,
      if (created_at != null) 'created_at': created_at,
      if (id != null) 'id': id,
      if (updated_at != null) 'updated_at': updated_at,
    });
  }

  DocumentsCompanion copyWith(
      {Value<String>? content,
      Value<int>? creator_user_id,
      Value<DateTime>? created_at,
      Value<String>? id,
      Value<DateTime>? updated_at}) {
    return DocumentsCompanion(
      content: content ?? this.content,
      creator_user_id: creator_user_id ?? this.creator_user_id,
      created_at: created_at ?? this.created_at,
      id: id ?? this.id,
      updated_at: updated_at ?? this.updated_at,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (content.present) {
      map['content'] = Variable<String>(content.value);
    }
    if (creator_user_id.present) {
      map['creator_user_id'] = Variable<int>(creator_user_id.value);
    }
    if (created_at.present) {
      map['created_at'] = Variable<DateTime>(created_at.value);
    }
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (updated_at.present) {
      map['updated_at'] = Variable<DateTime>(updated_at.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('DocumentsCompanion(')
          ..write('content: $content, ')
          ..write('creator_user_id: $creator_user_id, ')
          ..write('created_at: $created_at, ')
          ..write('id: $id, ')
          ..write('updated_at: $updated_at')
          ..write(')'))
        .toString();
  }
}

class $DocumentsTable extends Documents
    with TableInfo<$DocumentsTable, Document> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $DocumentsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _contentMeta =
      const VerificationMeta('content');
  @override
  late final GeneratedColumn<String> content = GeneratedColumn<String>(
      'content', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _creator_user_idMeta =
      const VerificationMeta('creator_user_id');
  @override
  late final GeneratedColumn<int> creator_user_id = GeneratedColumn<int>(
      'creator_user_id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _created_atMeta =
      const VerificationMeta('created_at');
  @override
  late final GeneratedColumn<DateTime> created_at = GeneratedColumn<DateTime>(
      'created_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _updated_atMeta =
      const VerificationMeta('updated_at');
  @override
  late final GeneratedColumn<DateTime> updated_at = GeneratedColumn<DateTime>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns =>
      [content, creator_user_id, created_at, id, updated_at];
  @override
  String get aliasedName => _alias ?? 'documents';
  @override
  String get actualTableName => 'documents';
  @override
  VerificationContext validateIntegrity(Insertable<Document> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('content')) {
      context.handle(_contentMeta,
          content.isAcceptableOrUnknown(data['content']!, _contentMeta));
    } else if (isInserting) {
      context.missing(_contentMeta);
    }
    if (data.containsKey('creator_user_id')) {
      context.handle(
          _creator_user_idMeta,
          creator_user_id.isAcceptableOrUnknown(
              data['creator_user_id']!, _creator_user_idMeta));
    } else if (isInserting) {
      context.missing(_creator_user_idMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(
          _created_atMeta,
          created_at.isAcceptableOrUnknown(
              data['created_at']!, _created_atMeta));
    } else if (isInserting) {
      context.missing(_created_atMeta);
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
          _updated_atMeta,
          updated_at.isAcceptableOrUnknown(
              data['updated_at']!, _updated_atMeta));
    } else if (isInserting) {
      context.missing(_updated_atMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Document map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Document(
      content: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}content'])!,
      creator_user_id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}creator_user_id'])!,
      created_at: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_at'])!,
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id'])!,
      updated_at: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}updated_at'])!,
    );
  }

  @override
  $DocumentsTable createAlias(String alias) {
    return $DocumentsTable(attachedDatabase, alias);
  }
}

class FragmentTemplate extends DataClass
    implements Insertable<FragmentTemplate> {
  String content;
  int owner_user_id;
  FragmentTemplateType type;
  DateTime created_at;
  String id;
  DateTime updated_at;
  FragmentTemplate(
      {required this.content,
      required this.owner_user_id,
      required this.type,
      required this.created_at,
      required this.id,
      required this.updated_at});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['content'] = Variable<String>(content);
    map['owner_user_id'] = Variable<int>(owner_user_id);
    {
      final converter = $FragmentTemplatesTable.$convertertype;
      map['type'] = Variable<int>(converter.toSql(type));
    }
    map['created_at'] = Variable<DateTime>(created_at);
    map['id'] = Variable<String>(id);
    map['updated_at'] = Variable<DateTime>(updated_at);
    return map;
  }

  FragmentTemplatesCompanion toCompanion(bool nullToAbsent) {
    return FragmentTemplatesCompanion(
      content: Value(content),
      owner_user_id: Value(owner_user_id),
      type: Value(type),
      created_at: Value(created_at),
      id: Value(id),
      updated_at: Value(updated_at),
    );
  }

  factory FragmentTemplate.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return FragmentTemplate(
      content: serializer.fromJson<String>(json['content']),
      owner_user_id: serializer.fromJson<int>(json['owner_user_id']),
      type: $FragmentTemplatesTable.$convertertype
          .fromJson(serializer.fromJson<int>(json['type'])),
      created_at: serializer.fromJson<DateTime>(json['created_at']),
      id: serializer.fromJson<String>(json['id']),
      updated_at: serializer.fromJson<DateTime>(json['updated_at']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'content': serializer.toJson<String>(content),
      'owner_user_id': serializer.toJson<int>(owner_user_id),
      'type': serializer
          .toJson<int>($FragmentTemplatesTable.$convertertype.toJson(type)),
      'created_at': serializer.toJson<DateTime>(created_at),
      'id': serializer.toJson<String>(id),
      'updated_at': serializer.toJson<DateTime>(updated_at),
    };
  }

  FragmentTemplate copyWith(
          {String? content,
          int? owner_user_id,
          FragmentTemplateType? type,
          DateTime? created_at,
          String? id,
          DateTime? updated_at}) =>
      FragmentTemplate(
        content: content ?? this.content,
        owner_user_id: owner_user_id ?? this.owner_user_id,
        type: type ?? this.type,
        created_at: created_at ?? this.created_at,
        id: id ?? this.id,
        updated_at: updated_at ?? this.updated_at,
      );
  @override
  String toString() {
    return (StringBuffer('FragmentTemplate(')
          ..write('content: $content, ')
          ..write('owner_user_id: $owner_user_id, ')
          ..write('type: $type, ')
          ..write('created_at: $created_at, ')
          ..write('id: $id, ')
          ..write('updated_at: $updated_at')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(content, owner_user_id, type, created_at, id, updated_at);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is FragmentTemplate &&
          other.content == this.content &&
          other.owner_user_id == this.owner_user_id &&
          other.type == this.type &&
          other.created_at == this.created_at &&
          other.id == this.id &&
          other.updated_at == this.updated_at);
}

class FragmentTemplatesCompanion extends UpdateCompanion<FragmentTemplate> {
  Value<String> content;
  Value<int> owner_user_id;
  Value<FragmentTemplateType> type;
  Value<DateTime> created_at;
  Value<String> id;
  Value<DateTime> updated_at;
  FragmentTemplatesCompanion({
    this.content = const Value.absent(),
    this.owner_user_id = const Value.absent(),
    this.type = const Value.absent(),
    this.created_at = const Value.absent(),
    this.id = const Value.absent(),
    this.updated_at = const Value.absent(),
  });
  FragmentTemplatesCompanion.insert({
    required String content,
    required int owner_user_id,
    required FragmentTemplateType type,
    required DateTime created_at,
    required String id,
    required DateTime updated_at,
  })  : content = Value(content),
        owner_user_id = Value(owner_user_id),
        type = Value(type),
        created_at = Value(created_at),
        id = Value(id),
        updated_at = Value(updated_at);
  static Insertable<FragmentTemplate> custom({
    Expression<String>? content,
    Expression<int>? owner_user_id,
    Expression<int>? type,
    Expression<DateTime>? created_at,
    Expression<String>? id,
    Expression<DateTime>? updated_at,
  }) {
    return RawValuesInsertable({
      if (content != null) 'content': content,
      if (owner_user_id != null) 'owner_user_id': owner_user_id,
      if (type != null) 'type': type,
      if (created_at != null) 'created_at': created_at,
      if (id != null) 'id': id,
      if (updated_at != null) 'updated_at': updated_at,
    });
  }

  FragmentTemplatesCompanion copyWith(
      {Value<String>? content,
      Value<int>? owner_user_id,
      Value<FragmentTemplateType>? type,
      Value<DateTime>? created_at,
      Value<String>? id,
      Value<DateTime>? updated_at}) {
    return FragmentTemplatesCompanion(
      content: content ?? this.content,
      owner_user_id: owner_user_id ?? this.owner_user_id,
      type: type ?? this.type,
      created_at: created_at ?? this.created_at,
      id: id ?? this.id,
      updated_at: updated_at ?? this.updated_at,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (content.present) {
      map['content'] = Variable<String>(content.value);
    }
    if (owner_user_id.present) {
      map['owner_user_id'] = Variable<int>(owner_user_id.value);
    }
    if (type.present) {
      final converter = $FragmentTemplatesTable.$convertertype;
      map['type'] = Variable<int>(converter.toSql(type.value));
    }
    if (created_at.present) {
      map['created_at'] = Variable<DateTime>(created_at.value);
    }
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (updated_at.present) {
      map['updated_at'] = Variable<DateTime>(updated_at.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('FragmentTemplatesCompanion(')
          ..write('content: $content, ')
          ..write('owner_user_id: $owner_user_id, ')
          ..write('type: $type, ')
          ..write('created_at: $created_at, ')
          ..write('id: $id, ')
          ..write('updated_at: $updated_at')
          ..write(')'))
        .toString();
  }
}

class $FragmentTemplatesTable extends FragmentTemplates
    with TableInfo<$FragmentTemplatesTable, FragmentTemplate> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $FragmentTemplatesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _contentMeta =
      const VerificationMeta('content');
  @override
  late final GeneratedColumn<String> content = GeneratedColumn<String>(
      'content', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _owner_user_idMeta =
      const VerificationMeta('owner_user_id');
  @override
  late final GeneratedColumn<int> owner_user_id = GeneratedColumn<int>(
      'owner_user_id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _typeMeta = const VerificationMeta('type');
  @override
  late final GeneratedColumnWithTypeConverter<FragmentTemplateType, int> type =
      GeneratedColumn<int>('type', aliasedName, false,
              type: DriftSqlType.int, requiredDuringInsert: true)
          .withConverter<FragmentTemplateType>(
              $FragmentTemplatesTable.$convertertype);
  static const VerificationMeta _created_atMeta =
      const VerificationMeta('created_at');
  @override
  late final GeneratedColumn<DateTime> created_at = GeneratedColumn<DateTime>(
      'created_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _updated_atMeta =
      const VerificationMeta('updated_at');
  @override
  late final GeneratedColumn<DateTime> updated_at = GeneratedColumn<DateTime>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns =>
      [content, owner_user_id, type, created_at, id, updated_at];
  @override
  String get aliasedName => _alias ?? 'fragment_templates';
  @override
  String get actualTableName => 'fragment_templates';
  @override
  VerificationContext validateIntegrity(Insertable<FragmentTemplate> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('content')) {
      context.handle(_contentMeta,
          content.isAcceptableOrUnknown(data['content']!, _contentMeta));
    } else if (isInserting) {
      context.missing(_contentMeta);
    }
    if (data.containsKey('owner_user_id')) {
      context.handle(
          _owner_user_idMeta,
          owner_user_id.isAcceptableOrUnknown(
              data['owner_user_id']!, _owner_user_idMeta));
    } else if (isInserting) {
      context.missing(_owner_user_idMeta);
    }
    context.handle(_typeMeta, const VerificationResult.success());
    if (data.containsKey('created_at')) {
      context.handle(
          _created_atMeta,
          created_at.isAcceptableOrUnknown(
              data['created_at']!, _created_atMeta));
    } else if (isInserting) {
      context.missing(_created_atMeta);
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
          _updated_atMeta,
          updated_at.isAcceptableOrUnknown(
              data['updated_at']!, _updated_atMeta));
    } else if (isInserting) {
      context.missing(_updated_atMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  FragmentTemplate map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return FragmentTemplate(
      content: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}content'])!,
      owner_user_id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}owner_user_id'])!,
      type: $FragmentTemplatesTable.$convertertype.fromSql(attachedDatabase
          .typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}type'])!),
      created_at: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_at'])!,
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id'])!,
      updated_at: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}updated_at'])!,
    );
  }

  @override
  $FragmentTemplatesTable createAlias(String alias) {
    return $FragmentTemplatesTable(attachedDatabase, alias);
  }

  static JsonTypeConverter2<FragmentTemplateType, int, int> $convertertype =
      const EnumIndexConverter<FragmentTemplateType>(
          FragmentTemplateType.values);
}

class Fragment extends DataClass implements Insertable<Fragment> {
  bool be_private;
  bool be_publish;
  bool client_be_selected;
  String content;
  int creator_user_id;
  String? father_fragment_id;
  String? fragment_template_id;
  String? note_id;
  String title;
  DateTime created_at;
  String id;
  DateTime updated_at;
  Fragment(
      {required this.be_private,
      required this.be_publish,
      required this.client_be_selected,
      required this.content,
      required this.creator_user_id,
      this.father_fragment_id,
      this.fragment_template_id,
      this.note_id,
      required this.title,
      required this.created_at,
      required this.id,
      required this.updated_at});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['be_private'] = Variable<bool>(be_private);
    map['be_publish'] = Variable<bool>(be_publish);
    map['client_be_selected'] = Variable<bool>(client_be_selected);
    map['content'] = Variable<String>(content);
    map['creator_user_id'] = Variable<int>(creator_user_id);
    if (!nullToAbsent || father_fragment_id != null) {
      map['father_fragment_id'] = Variable<String>(father_fragment_id);
    }
    if (!nullToAbsent || fragment_template_id != null) {
      map['fragment_template_id'] = Variable<String>(fragment_template_id);
    }
    if (!nullToAbsent || note_id != null) {
      map['note_id'] = Variable<String>(note_id);
    }
    map['title'] = Variable<String>(title);
    map['created_at'] = Variable<DateTime>(created_at);
    map['id'] = Variable<String>(id);
    map['updated_at'] = Variable<DateTime>(updated_at);
    return map;
  }

  FragmentsCompanion toCompanion(bool nullToAbsent) {
    return FragmentsCompanion(
      be_private: Value(be_private),
      be_publish: Value(be_publish),
      client_be_selected: Value(client_be_selected),
      content: Value(content),
      creator_user_id: Value(creator_user_id),
      father_fragment_id: father_fragment_id == null && nullToAbsent
          ? const Value.absent()
          : Value(father_fragment_id),
      fragment_template_id: fragment_template_id == null && nullToAbsent
          ? const Value.absent()
          : Value(fragment_template_id),
      note_id: note_id == null && nullToAbsent
          ? const Value.absent()
          : Value(note_id),
      title: Value(title),
      created_at: Value(created_at),
      id: Value(id),
      updated_at: Value(updated_at),
    );
  }

  factory Fragment.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Fragment(
      be_private: serializer.fromJson<bool>(json['be_private']),
      be_publish: serializer.fromJson<bool>(json['be_publish']),
      client_be_selected: serializer.fromJson<bool>(json['client_be_selected']),
      content: serializer.fromJson<String>(json['content']),
      creator_user_id: serializer.fromJson<int>(json['creator_user_id']),
      father_fragment_id:
          serializer.fromJson<String?>(json['father_fragment_id']),
      fragment_template_id:
          serializer.fromJson<String?>(json['fragment_template_id']),
      note_id: serializer.fromJson<String?>(json['note_id']),
      title: serializer.fromJson<String>(json['title']),
      created_at: serializer.fromJson<DateTime>(json['created_at']),
      id: serializer.fromJson<String>(json['id']),
      updated_at: serializer.fromJson<DateTime>(json['updated_at']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'be_private': serializer.toJson<bool>(be_private),
      'be_publish': serializer.toJson<bool>(be_publish),
      'client_be_selected': serializer.toJson<bool>(client_be_selected),
      'content': serializer.toJson<String>(content),
      'creator_user_id': serializer.toJson<int>(creator_user_id),
      'father_fragment_id': serializer.toJson<String?>(father_fragment_id),
      'fragment_template_id': serializer.toJson<String?>(fragment_template_id),
      'note_id': serializer.toJson<String?>(note_id),
      'title': serializer.toJson<String>(title),
      'created_at': serializer.toJson<DateTime>(created_at),
      'id': serializer.toJson<String>(id),
      'updated_at': serializer.toJson<DateTime>(updated_at),
    };
  }

  Fragment copyWith(
          {bool? be_private,
          bool? be_publish,
          bool? client_be_selected,
          String? content,
          int? creator_user_id,
          Value<String?> father_fragment_id = const Value.absent(),
          Value<String?> fragment_template_id = const Value.absent(),
          Value<String?> note_id = const Value.absent(),
          String? title,
          DateTime? created_at,
          String? id,
          DateTime? updated_at}) =>
      Fragment(
        be_private: be_private ?? this.be_private,
        be_publish: be_publish ?? this.be_publish,
        client_be_selected: client_be_selected ?? this.client_be_selected,
        content: content ?? this.content,
        creator_user_id: creator_user_id ?? this.creator_user_id,
        father_fragment_id: father_fragment_id.present
            ? father_fragment_id.value
            : this.father_fragment_id,
        fragment_template_id: fragment_template_id.present
            ? fragment_template_id.value
            : this.fragment_template_id,
        note_id: note_id.present ? note_id.value : this.note_id,
        title: title ?? this.title,
        created_at: created_at ?? this.created_at,
        id: id ?? this.id,
        updated_at: updated_at ?? this.updated_at,
      );
  @override
  String toString() {
    return (StringBuffer('Fragment(')
          ..write('be_private: $be_private, ')
          ..write('be_publish: $be_publish, ')
          ..write('client_be_selected: $client_be_selected, ')
          ..write('content: $content, ')
          ..write('creator_user_id: $creator_user_id, ')
          ..write('father_fragment_id: $father_fragment_id, ')
          ..write('fragment_template_id: $fragment_template_id, ')
          ..write('note_id: $note_id, ')
          ..write('title: $title, ')
          ..write('created_at: $created_at, ')
          ..write('id: $id, ')
          ..write('updated_at: $updated_at')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      be_private,
      be_publish,
      client_be_selected,
      content,
      creator_user_id,
      father_fragment_id,
      fragment_template_id,
      note_id,
      title,
      created_at,
      id,
      updated_at);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Fragment &&
          other.be_private == this.be_private &&
          other.be_publish == this.be_publish &&
          other.client_be_selected == this.client_be_selected &&
          other.content == this.content &&
          other.creator_user_id == this.creator_user_id &&
          other.father_fragment_id == this.father_fragment_id &&
          other.fragment_template_id == this.fragment_template_id &&
          other.note_id == this.note_id &&
          other.title == this.title &&
          other.created_at == this.created_at &&
          other.id == this.id &&
          other.updated_at == this.updated_at);
}

class FragmentsCompanion extends UpdateCompanion<Fragment> {
  Value<bool> be_private;
  Value<bool> be_publish;
  Value<bool> client_be_selected;
  Value<String> content;
  Value<int> creator_user_id;
  Value<String?> father_fragment_id;
  Value<String?> fragment_template_id;
  Value<String?> note_id;
  Value<String> title;
  Value<DateTime> created_at;
  Value<String> id;
  Value<DateTime> updated_at;
  FragmentsCompanion({
    this.be_private = const Value.absent(),
    this.be_publish = const Value.absent(),
    this.client_be_selected = const Value.absent(),
    this.content = const Value.absent(),
    this.creator_user_id = const Value.absent(),
    this.father_fragment_id = const Value.absent(),
    this.fragment_template_id = const Value.absent(),
    this.note_id = const Value.absent(),
    this.title = const Value.absent(),
    this.created_at = const Value.absent(),
    this.id = const Value.absent(),
    this.updated_at = const Value.absent(),
  });
  FragmentsCompanion.insert({
    required bool be_private,
    required bool be_publish,
    required bool client_be_selected,
    required String content,
    required int creator_user_id,
    this.father_fragment_id = const Value.absent(),
    this.fragment_template_id = const Value.absent(),
    this.note_id = const Value.absent(),
    required String title,
    required DateTime created_at,
    required String id,
    required DateTime updated_at,
  })  : be_private = Value(be_private),
        be_publish = Value(be_publish),
        client_be_selected = Value(client_be_selected),
        content = Value(content),
        creator_user_id = Value(creator_user_id),
        title = Value(title),
        created_at = Value(created_at),
        id = Value(id),
        updated_at = Value(updated_at);
  static Insertable<Fragment> custom({
    Expression<bool>? be_private,
    Expression<bool>? be_publish,
    Expression<bool>? client_be_selected,
    Expression<String>? content,
    Expression<int>? creator_user_id,
    Expression<String>? father_fragment_id,
    Expression<String>? fragment_template_id,
    Expression<String>? note_id,
    Expression<String>? title,
    Expression<DateTime>? created_at,
    Expression<String>? id,
    Expression<DateTime>? updated_at,
  }) {
    return RawValuesInsertable({
      if (be_private != null) 'be_private': be_private,
      if (be_publish != null) 'be_publish': be_publish,
      if (client_be_selected != null) 'client_be_selected': client_be_selected,
      if (content != null) 'content': content,
      if (creator_user_id != null) 'creator_user_id': creator_user_id,
      if (father_fragment_id != null) 'father_fragment_id': father_fragment_id,
      if (fragment_template_id != null)
        'fragment_template_id': fragment_template_id,
      if (note_id != null) 'note_id': note_id,
      if (title != null) 'title': title,
      if (created_at != null) 'created_at': created_at,
      if (id != null) 'id': id,
      if (updated_at != null) 'updated_at': updated_at,
    });
  }

  FragmentsCompanion copyWith(
      {Value<bool>? be_private,
      Value<bool>? be_publish,
      Value<bool>? client_be_selected,
      Value<String>? content,
      Value<int>? creator_user_id,
      Value<String?>? father_fragment_id,
      Value<String?>? fragment_template_id,
      Value<String?>? note_id,
      Value<String>? title,
      Value<DateTime>? created_at,
      Value<String>? id,
      Value<DateTime>? updated_at}) {
    return FragmentsCompanion(
      be_private: be_private ?? this.be_private,
      be_publish: be_publish ?? this.be_publish,
      client_be_selected: client_be_selected ?? this.client_be_selected,
      content: content ?? this.content,
      creator_user_id: creator_user_id ?? this.creator_user_id,
      father_fragment_id: father_fragment_id ?? this.father_fragment_id,
      fragment_template_id: fragment_template_id ?? this.fragment_template_id,
      note_id: note_id ?? this.note_id,
      title: title ?? this.title,
      created_at: created_at ?? this.created_at,
      id: id ?? this.id,
      updated_at: updated_at ?? this.updated_at,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (be_private.present) {
      map['be_private'] = Variable<bool>(be_private.value);
    }
    if (be_publish.present) {
      map['be_publish'] = Variable<bool>(be_publish.value);
    }
    if (client_be_selected.present) {
      map['client_be_selected'] = Variable<bool>(client_be_selected.value);
    }
    if (content.present) {
      map['content'] = Variable<String>(content.value);
    }
    if (creator_user_id.present) {
      map['creator_user_id'] = Variable<int>(creator_user_id.value);
    }
    if (father_fragment_id.present) {
      map['father_fragment_id'] = Variable<String>(father_fragment_id.value);
    }
    if (fragment_template_id.present) {
      map['fragment_template_id'] =
          Variable<String>(fragment_template_id.value);
    }
    if (note_id.present) {
      map['note_id'] = Variable<String>(note_id.value);
    }
    if (title.present) {
      map['title'] = Variable<String>(title.value);
    }
    if (created_at.present) {
      map['created_at'] = Variable<DateTime>(created_at.value);
    }
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (updated_at.present) {
      map['updated_at'] = Variable<DateTime>(updated_at.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('FragmentsCompanion(')
          ..write('be_private: $be_private, ')
          ..write('be_publish: $be_publish, ')
          ..write('client_be_selected: $client_be_selected, ')
          ..write('content: $content, ')
          ..write('creator_user_id: $creator_user_id, ')
          ..write('father_fragment_id: $father_fragment_id, ')
          ..write('fragment_template_id: $fragment_template_id, ')
          ..write('note_id: $note_id, ')
          ..write('title: $title, ')
          ..write('created_at: $created_at, ')
          ..write('id: $id, ')
          ..write('updated_at: $updated_at')
          ..write(')'))
        .toString();
  }
}

class $FragmentsTable extends Fragments
    with TableInfo<$FragmentsTable, Fragment> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $FragmentsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _be_privateMeta =
      const VerificationMeta('be_private');
  @override
  late final GeneratedColumn<bool> be_private =
      GeneratedColumn<bool>('be_private', aliasedName, false,
          type: DriftSqlType.bool,
          requiredDuringInsert: true,
          defaultConstraints: GeneratedColumn.constraintsDependsOnDialect({
            SqlDialect.sqlite: 'CHECK ("be_private" IN (0, 1))',
            SqlDialect.mysql: '',
            SqlDialect.postgres: '',
          }));
  static const VerificationMeta _be_publishMeta =
      const VerificationMeta('be_publish');
  @override
  late final GeneratedColumn<bool> be_publish =
      GeneratedColumn<bool>('be_publish', aliasedName, false,
          type: DriftSqlType.bool,
          requiredDuringInsert: true,
          defaultConstraints: GeneratedColumn.constraintsDependsOnDialect({
            SqlDialect.sqlite: 'CHECK ("be_publish" IN (0, 1))',
            SqlDialect.mysql: '',
            SqlDialect.postgres: '',
          }));
  static const VerificationMeta _client_be_selectedMeta =
      const VerificationMeta('client_be_selected');
  @override
  late final GeneratedColumn<bool> client_be_selected =
      GeneratedColumn<bool>('client_be_selected', aliasedName, false,
          type: DriftSqlType.bool,
          requiredDuringInsert: true,
          defaultConstraints: GeneratedColumn.constraintsDependsOnDialect({
            SqlDialect.sqlite: 'CHECK ("client_be_selected" IN (0, 1))',
            SqlDialect.mysql: '',
            SqlDialect.postgres: '',
          }));
  static const VerificationMeta _contentMeta =
      const VerificationMeta('content');
  @override
  late final GeneratedColumn<String> content = GeneratedColumn<String>(
      'content', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _creator_user_idMeta =
      const VerificationMeta('creator_user_id');
  @override
  late final GeneratedColumn<int> creator_user_id = GeneratedColumn<int>(
      'creator_user_id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _father_fragment_idMeta =
      const VerificationMeta('father_fragment_id');
  @override
  late final GeneratedColumn<String> father_fragment_id =
      GeneratedColumn<String>('father_fragment_id', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _fragment_template_idMeta =
      const VerificationMeta('fragment_template_id');
  @override
  late final GeneratedColumn<String> fragment_template_id =
      GeneratedColumn<String>('fragment_template_id', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _note_idMeta =
      const VerificationMeta('note_id');
  @override
  late final GeneratedColumn<String> note_id = GeneratedColumn<String>(
      'note_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _titleMeta = const VerificationMeta('title');
  @override
  late final GeneratedColumn<String> title = GeneratedColumn<String>(
      'title', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _created_atMeta =
      const VerificationMeta('created_at');
  @override
  late final GeneratedColumn<DateTime> created_at = GeneratedColumn<DateTime>(
      'created_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _updated_atMeta =
      const VerificationMeta('updated_at');
  @override
  late final GeneratedColumn<DateTime> updated_at = GeneratedColumn<DateTime>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns => [
        be_private,
        be_publish,
        client_be_selected,
        content,
        creator_user_id,
        father_fragment_id,
        fragment_template_id,
        note_id,
        title,
        created_at,
        id,
        updated_at
      ];
  @override
  String get aliasedName => _alias ?? 'fragments';
  @override
  String get actualTableName => 'fragments';
  @override
  VerificationContext validateIntegrity(Insertable<Fragment> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('be_private')) {
      context.handle(
          _be_privateMeta,
          be_private.isAcceptableOrUnknown(
              data['be_private']!, _be_privateMeta));
    } else if (isInserting) {
      context.missing(_be_privateMeta);
    }
    if (data.containsKey('be_publish')) {
      context.handle(
          _be_publishMeta,
          be_publish.isAcceptableOrUnknown(
              data['be_publish']!, _be_publishMeta));
    } else if (isInserting) {
      context.missing(_be_publishMeta);
    }
    if (data.containsKey('client_be_selected')) {
      context.handle(
          _client_be_selectedMeta,
          client_be_selected.isAcceptableOrUnknown(
              data['client_be_selected']!, _client_be_selectedMeta));
    } else if (isInserting) {
      context.missing(_client_be_selectedMeta);
    }
    if (data.containsKey('content')) {
      context.handle(_contentMeta,
          content.isAcceptableOrUnknown(data['content']!, _contentMeta));
    } else if (isInserting) {
      context.missing(_contentMeta);
    }
    if (data.containsKey('creator_user_id')) {
      context.handle(
          _creator_user_idMeta,
          creator_user_id.isAcceptableOrUnknown(
              data['creator_user_id']!, _creator_user_idMeta));
    } else if (isInserting) {
      context.missing(_creator_user_idMeta);
    }
    if (data.containsKey('father_fragment_id')) {
      context.handle(
          _father_fragment_idMeta,
          father_fragment_id.isAcceptableOrUnknown(
              data['father_fragment_id']!, _father_fragment_idMeta));
    }
    if (data.containsKey('fragment_template_id')) {
      context.handle(
          _fragment_template_idMeta,
          fragment_template_id.isAcceptableOrUnknown(
              data['fragment_template_id']!, _fragment_template_idMeta));
    }
    if (data.containsKey('note_id')) {
      context.handle(_note_idMeta,
          note_id.isAcceptableOrUnknown(data['note_id']!, _note_idMeta));
    }
    if (data.containsKey('title')) {
      context.handle(
          _titleMeta, title.isAcceptableOrUnknown(data['title']!, _titleMeta));
    } else if (isInserting) {
      context.missing(_titleMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(
          _created_atMeta,
          created_at.isAcceptableOrUnknown(
              data['created_at']!, _created_atMeta));
    } else if (isInserting) {
      context.missing(_created_atMeta);
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
          _updated_atMeta,
          updated_at.isAcceptableOrUnknown(
              data['updated_at']!, _updated_atMeta));
    } else if (isInserting) {
      context.missing(_updated_atMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Fragment map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Fragment(
      be_private: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}be_private'])!,
      be_publish: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}be_publish'])!,
      client_be_selected: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}client_be_selected'])!,
      content: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}content'])!,
      creator_user_id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}creator_user_id'])!,
      father_fragment_id: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}father_fragment_id']),
      fragment_template_id: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}fragment_template_id']),
      note_id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}note_id']),
      title: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}title'])!,
      created_at: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_at'])!,
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id'])!,
      updated_at: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}updated_at'])!,
    );
  }

  @override
  $FragmentsTable createAlias(String alias) {
    return $FragmentsTable(attachedDatabase, alias);
  }
}

class MemoryGroup extends DataClass implements Insertable<MemoryGroup> {
  int creator_user_id;
  String? memory_model_id;
  NewDisplayOrder new_display_order;
  NewReviewDisplayOrder new_review_display_order;
  DateTime review_interval;
  DateTime? start_time;
  String title;
  int will_new_learn_count;
  DateTime created_at;
  String id;
  DateTime updated_at;
  MemoryGroup(
      {required this.creator_user_id,
      this.memory_model_id,
      required this.new_display_order,
      required this.new_review_display_order,
      required this.review_interval,
      this.start_time,
      required this.title,
      required this.will_new_learn_count,
      required this.created_at,
      required this.id,
      required this.updated_at});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['creator_user_id'] = Variable<int>(creator_user_id);
    if (!nullToAbsent || memory_model_id != null) {
      map['memory_model_id'] = Variable<String>(memory_model_id);
    }
    {
      final converter = $MemoryGroupsTable.$converternew_display_order;
      map['new_display_order'] =
          Variable<int>(converter.toSql(new_display_order));
    }
    {
      final converter = $MemoryGroupsTable.$converternew_review_display_order;
      map['new_review_display_order'] =
          Variable<int>(converter.toSql(new_review_display_order));
    }
    map['review_interval'] = Variable<DateTime>(review_interval);
    if (!nullToAbsent || start_time != null) {
      map['start_time'] = Variable<DateTime>(start_time);
    }
    map['title'] = Variable<String>(title);
    map['will_new_learn_count'] = Variable<int>(will_new_learn_count);
    map['created_at'] = Variable<DateTime>(created_at);
    map['id'] = Variable<String>(id);
    map['updated_at'] = Variable<DateTime>(updated_at);
    return map;
  }

  MemoryGroupsCompanion toCompanion(bool nullToAbsent) {
    return MemoryGroupsCompanion(
      creator_user_id: Value(creator_user_id),
      memory_model_id: memory_model_id == null && nullToAbsent
          ? const Value.absent()
          : Value(memory_model_id),
      new_display_order: Value(new_display_order),
      new_review_display_order: Value(new_review_display_order),
      review_interval: Value(review_interval),
      start_time: start_time == null && nullToAbsent
          ? const Value.absent()
          : Value(start_time),
      title: Value(title),
      will_new_learn_count: Value(will_new_learn_count),
      created_at: Value(created_at),
      id: Value(id),
      updated_at: Value(updated_at),
    );
  }

  factory MemoryGroup.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return MemoryGroup(
      creator_user_id: serializer.fromJson<int>(json['creator_user_id']),
      memory_model_id: serializer.fromJson<String?>(json['memory_model_id']),
      new_display_order: $MemoryGroupsTable.$converternew_display_order
          .fromJson(serializer.fromJson<int>(json['new_display_order'])),
      new_review_display_order: $MemoryGroupsTable
          .$converternew_review_display_order
          .fromJson(serializer.fromJson<int>(json['new_review_display_order'])),
      review_interval: serializer.fromJson<DateTime>(json['review_interval']),
      start_time: serializer.fromJson<DateTime?>(json['start_time']),
      title: serializer.fromJson<String>(json['title']),
      will_new_learn_count:
          serializer.fromJson<int>(json['will_new_learn_count']),
      created_at: serializer.fromJson<DateTime>(json['created_at']),
      id: serializer.fromJson<String>(json['id']),
      updated_at: serializer.fromJson<DateTime>(json['updated_at']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'creator_user_id': serializer.toJson<int>(creator_user_id),
      'memory_model_id': serializer.toJson<String?>(memory_model_id),
      'new_display_order': serializer.toJson<int>($MemoryGroupsTable
          .$converternew_display_order
          .toJson(new_display_order)),
      'new_review_display_order': serializer.toJson<int>($MemoryGroupsTable
          .$converternew_review_display_order
          .toJson(new_review_display_order)),
      'review_interval': serializer.toJson<DateTime>(review_interval),
      'start_time': serializer.toJson<DateTime?>(start_time),
      'title': serializer.toJson<String>(title),
      'will_new_learn_count': serializer.toJson<int>(will_new_learn_count),
      'created_at': serializer.toJson<DateTime>(created_at),
      'id': serializer.toJson<String>(id),
      'updated_at': serializer.toJson<DateTime>(updated_at),
    };
  }

  MemoryGroup copyWith(
          {int? creator_user_id,
          Value<String?> memory_model_id = const Value.absent(),
          NewDisplayOrder? new_display_order,
          NewReviewDisplayOrder? new_review_display_order,
          DateTime? review_interval,
          Value<DateTime?> start_time = const Value.absent(),
          String? title,
          int? will_new_learn_count,
          DateTime? created_at,
          String? id,
          DateTime? updated_at}) =>
      MemoryGroup(
        creator_user_id: creator_user_id ?? this.creator_user_id,
        memory_model_id: memory_model_id.present
            ? memory_model_id.value
            : this.memory_model_id,
        new_display_order: new_display_order ?? this.new_display_order,
        new_review_display_order:
            new_review_display_order ?? this.new_review_display_order,
        review_interval: review_interval ?? this.review_interval,
        start_time: start_time.present ? start_time.value : this.start_time,
        title: title ?? this.title,
        will_new_learn_count: will_new_learn_count ?? this.will_new_learn_count,
        created_at: created_at ?? this.created_at,
        id: id ?? this.id,
        updated_at: updated_at ?? this.updated_at,
      );
  @override
  String toString() {
    return (StringBuffer('MemoryGroup(')
          ..write('creator_user_id: $creator_user_id, ')
          ..write('memory_model_id: $memory_model_id, ')
          ..write('new_display_order: $new_display_order, ')
          ..write('new_review_display_order: $new_review_display_order, ')
          ..write('review_interval: $review_interval, ')
          ..write('start_time: $start_time, ')
          ..write('title: $title, ')
          ..write('will_new_learn_count: $will_new_learn_count, ')
          ..write('created_at: $created_at, ')
          ..write('id: $id, ')
          ..write('updated_at: $updated_at')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      creator_user_id,
      memory_model_id,
      new_display_order,
      new_review_display_order,
      review_interval,
      start_time,
      title,
      will_new_learn_count,
      created_at,
      id,
      updated_at);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is MemoryGroup &&
          other.creator_user_id == this.creator_user_id &&
          other.memory_model_id == this.memory_model_id &&
          other.new_display_order == this.new_display_order &&
          other.new_review_display_order == this.new_review_display_order &&
          other.review_interval == this.review_interval &&
          other.start_time == this.start_time &&
          other.title == this.title &&
          other.will_new_learn_count == this.will_new_learn_count &&
          other.created_at == this.created_at &&
          other.id == this.id &&
          other.updated_at == this.updated_at);
}

class MemoryGroupsCompanion extends UpdateCompanion<MemoryGroup> {
  Value<int> creator_user_id;
  Value<String?> memory_model_id;
  Value<NewDisplayOrder> new_display_order;
  Value<NewReviewDisplayOrder> new_review_display_order;
  Value<DateTime> review_interval;
  Value<DateTime?> start_time;
  Value<String> title;
  Value<int> will_new_learn_count;
  Value<DateTime> created_at;
  Value<String> id;
  Value<DateTime> updated_at;
  MemoryGroupsCompanion({
    this.creator_user_id = const Value.absent(),
    this.memory_model_id = const Value.absent(),
    this.new_display_order = const Value.absent(),
    this.new_review_display_order = const Value.absent(),
    this.review_interval = const Value.absent(),
    this.start_time = const Value.absent(),
    this.title = const Value.absent(),
    this.will_new_learn_count = const Value.absent(),
    this.created_at = const Value.absent(),
    this.id = const Value.absent(),
    this.updated_at = const Value.absent(),
  });
  MemoryGroupsCompanion.insert({
    required int creator_user_id,
    this.memory_model_id = const Value.absent(),
    required NewDisplayOrder new_display_order,
    required NewReviewDisplayOrder new_review_display_order,
    required DateTime review_interval,
    this.start_time = const Value.absent(),
    required String title,
    required int will_new_learn_count,
    required DateTime created_at,
    required String id,
    required DateTime updated_at,
  })  : creator_user_id = Value(creator_user_id),
        new_display_order = Value(new_display_order),
        new_review_display_order = Value(new_review_display_order),
        review_interval = Value(review_interval),
        title = Value(title),
        will_new_learn_count = Value(will_new_learn_count),
        created_at = Value(created_at),
        id = Value(id),
        updated_at = Value(updated_at);
  static Insertable<MemoryGroup> custom({
    Expression<int>? creator_user_id,
    Expression<String>? memory_model_id,
    Expression<int>? new_display_order,
    Expression<int>? new_review_display_order,
    Expression<DateTime>? review_interval,
    Expression<DateTime>? start_time,
    Expression<String>? title,
    Expression<int>? will_new_learn_count,
    Expression<DateTime>? created_at,
    Expression<String>? id,
    Expression<DateTime>? updated_at,
  }) {
    return RawValuesInsertable({
      if (creator_user_id != null) 'creator_user_id': creator_user_id,
      if (memory_model_id != null) 'memory_model_id': memory_model_id,
      if (new_display_order != null) 'new_display_order': new_display_order,
      if (new_review_display_order != null)
        'new_review_display_order': new_review_display_order,
      if (review_interval != null) 'review_interval': review_interval,
      if (start_time != null) 'start_time': start_time,
      if (title != null) 'title': title,
      if (will_new_learn_count != null)
        'will_new_learn_count': will_new_learn_count,
      if (created_at != null) 'created_at': created_at,
      if (id != null) 'id': id,
      if (updated_at != null) 'updated_at': updated_at,
    });
  }

  MemoryGroupsCompanion copyWith(
      {Value<int>? creator_user_id,
      Value<String?>? memory_model_id,
      Value<NewDisplayOrder>? new_display_order,
      Value<NewReviewDisplayOrder>? new_review_display_order,
      Value<DateTime>? review_interval,
      Value<DateTime?>? start_time,
      Value<String>? title,
      Value<int>? will_new_learn_count,
      Value<DateTime>? created_at,
      Value<String>? id,
      Value<DateTime>? updated_at}) {
    return MemoryGroupsCompanion(
      creator_user_id: creator_user_id ?? this.creator_user_id,
      memory_model_id: memory_model_id ?? this.memory_model_id,
      new_display_order: new_display_order ?? this.new_display_order,
      new_review_display_order:
          new_review_display_order ?? this.new_review_display_order,
      review_interval: review_interval ?? this.review_interval,
      start_time: start_time ?? this.start_time,
      title: title ?? this.title,
      will_new_learn_count: will_new_learn_count ?? this.will_new_learn_count,
      created_at: created_at ?? this.created_at,
      id: id ?? this.id,
      updated_at: updated_at ?? this.updated_at,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (creator_user_id.present) {
      map['creator_user_id'] = Variable<int>(creator_user_id.value);
    }
    if (memory_model_id.present) {
      map['memory_model_id'] = Variable<String>(memory_model_id.value);
    }
    if (new_display_order.present) {
      final converter = $MemoryGroupsTable.$converternew_display_order;
      map['new_display_order'] =
          Variable<int>(converter.toSql(new_display_order.value));
    }
    if (new_review_display_order.present) {
      final converter = $MemoryGroupsTable.$converternew_review_display_order;
      map['new_review_display_order'] =
          Variable<int>(converter.toSql(new_review_display_order.value));
    }
    if (review_interval.present) {
      map['review_interval'] = Variable<DateTime>(review_interval.value);
    }
    if (start_time.present) {
      map['start_time'] = Variable<DateTime>(start_time.value);
    }
    if (title.present) {
      map['title'] = Variable<String>(title.value);
    }
    if (will_new_learn_count.present) {
      map['will_new_learn_count'] = Variable<int>(will_new_learn_count.value);
    }
    if (created_at.present) {
      map['created_at'] = Variable<DateTime>(created_at.value);
    }
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (updated_at.present) {
      map['updated_at'] = Variable<DateTime>(updated_at.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('MemoryGroupsCompanion(')
          ..write('creator_user_id: $creator_user_id, ')
          ..write('memory_model_id: $memory_model_id, ')
          ..write('new_display_order: $new_display_order, ')
          ..write('new_review_display_order: $new_review_display_order, ')
          ..write('review_interval: $review_interval, ')
          ..write('start_time: $start_time, ')
          ..write('title: $title, ')
          ..write('will_new_learn_count: $will_new_learn_count, ')
          ..write('created_at: $created_at, ')
          ..write('id: $id, ')
          ..write('updated_at: $updated_at')
          ..write(')'))
        .toString();
  }
}

class $MemoryGroupsTable extends MemoryGroups
    with TableInfo<$MemoryGroupsTable, MemoryGroup> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $MemoryGroupsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _creator_user_idMeta =
      const VerificationMeta('creator_user_id');
  @override
  late final GeneratedColumn<int> creator_user_id = GeneratedColumn<int>(
      'creator_user_id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _memory_model_idMeta =
      const VerificationMeta('memory_model_id');
  @override
  late final GeneratedColumn<String> memory_model_id = GeneratedColumn<String>(
      'memory_model_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _new_display_orderMeta =
      const VerificationMeta('new_display_order');
  @override
  late final GeneratedColumnWithTypeConverter<NewDisplayOrder, int>
      new_display_order = GeneratedColumn<int>(
              'new_display_order', aliasedName, false,
              type: DriftSqlType.int, requiredDuringInsert: true)
          .withConverter<NewDisplayOrder>(
              $MemoryGroupsTable.$converternew_display_order);
  static const VerificationMeta _new_review_display_orderMeta =
      const VerificationMeta('new_review_display_order');
  @override
  late final GeneratedColumnWithTypeConverter<NewReviewDisplayOrder, int>
      new_review_display_order = GeneratedColumn<int>(
              'new_review_display_order', aliasedName, false,
              type: DriftSqlType.int, requiredDuringInsert: true)
          .withConverter<NewReviewDisplayOrder>(
              $MemoryGroupsTable.$converternew_review_display_order);
  static const VerificationMeta _review_intervalMeta =
      const VerificationMeta('review_interval');
  @override
  late final GeneratedColumn<DateTime> review_interval =
      GeneratedColumn<DateTime>('review_interval', aliasedName, false,
          type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _start_timeMeta =
      const VerificationMeta('start_time');
  @override
  late final GeneratedColumn<DateTime> start_time = GeneratedColumn<DateTime>(
      'start_time', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _titleMeta = const VerificationMeta('title');
  @override
  late final GeneratedColumn<String> title = GeneratedColumn<String>(
      'title', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _will_new_learn_countMeta =
      const VerificationMeta('will_new_learn_count');
  @override
  late final GeneratedColumn<int> will_new_learn_count = GeneratedColumn<int>(
      'will_new_learn_count', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _created_atMeta =
      const VerificationMeta('created_at');
  @override
  late final GeneratedColumn<DateTime> created_at = GeneratedColumn<DateTime>(
      'created_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _updated_atMeta =
      const VerificationMeta('updated_at');
  @override
  late final GeneratedColumn<DateTime> updated_at = GeneratedColumn<DateTime>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns => [
        creator_user_id,
        memory_model_id,
        new_display_order,
        new_review_display_order,
        review_interval,
        start_time,
        title,
        will_new_learn_count,
        created_at,
        id,
        updated_at
      ];
  @override
  String get aliasedName => _alias ?? 'memory_groups';
  @override
  String get actualTableName => 'memory_groups';
  @override
  VerificationContext validateIntegrity(Insertable<MemoryGroup> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('creator_user_id')) {
      context.handle(
          _creator_user_idMeta,
          creator_user_id.isAcceptableOrUnknown(
              data['creator_user_id']!, _creator_user_idMeta));
    } else if (isInserting) {
      context.missing(_creator_user_idMeta);
    }
    if (data.containsKey('memory_model_id')) {
      context.handle(
          _memory_model_idMeta,
          memory_model_id.isAcceptableOrUnknown(
              data['memory_model_id']!, _memory_model_idMeta));
    }
    context.handle(_new_display_orderMeta, const VerificationResult.success());
    context.handle(
        _new_review_display_orderMeta, const VerificationResult.success());
    if (data.containsKey('review_interval')) {
      context.handle(
          _review_intervalMeta,
          review_interval.isAcceptableOrUnknown(
              data['review_interval']!, _review_intervalMeta));
    } else if (isInserting) {
      context.missing(_review_intervalMeta);
    }
    if (data.containsKey('start_time')) {
      context.handle(
          _start_timeMeta,
          start_time.isAcceptableOrUnknown(
              data['start_time']!, _start_timeMeta));
    }
    if (data.containsKey('title')) {
      context.handle(
          _titleMeta, title.isAcceptableOrUnknown(data['title']!, _titleMeta));
    } else if (isInserting) {
      context.missing(_titleMeta);
    }
    if (data.containsKey('will_new_learn_count')) {
      context.handle(
          _will_new_learn_countMeta,
          will_new_learn_count.isAcceptableOrUnknown(
              data['will_new_learn_count']!, _will_new_learn_countMeta));
    } else if (isInserting) {
      context.missing(_will_new_learn_countMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(
          _created_atMeta,
          created_at.isAcceptableOrUnknown(
              data['created_at']!, _created_atMeta));
    } else if (isInserting) {
      context.missing(_created_atMeta);
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
          _updated_atMeta,
          updated_at.isAcceptableOrUnknown(
              data['updated_at']!, _updated_atMeta));
    } else if (isInserting) {
      context.missing(_updated_atMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  MemoryGroup map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return MemoryGroup(
      creator_user_id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}creator_user_id'])!,
      memory_model_id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}memory_model_id']),
      new_display_order: $MemoryGroupsTable.$converternew_display_order.fromSql(
          attachedDatabase.typeMapping.read(
              DriftSqlType.int, data['${effectivePrefix}new_display_order'])!),
      new_review_display_order: $MemoryGroupsTable
          .$converternew_review_display_order
          .fromSql(attachedDatabase.typeMapping.read(DriftSqlType.int,
              data['${effectivePrefix}new_review_display_order'])!),
      review_interval: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}review_interval'])!,
      start_time: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}start_time']),
      title: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}title'])!,
      will_new_learn_count: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}will_new_learn_count'])!,
      created_at: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_at'])!,
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id'])!,
      updated_at: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}updated_at'])!,
    );
  }

  @override
  $MemoryGroupsTable createAlias(String alias) {
    return $MemoryGroupsTable(attachedDatabase, alias);
  }

  static JsonTypeConverter2<NewDisplayOrder, int, int>
      $converternew_display_order =
      const EnumIndexConverter<NewDisplayOrder>(NewDisplayOrder.values);
  static JsonTypeConverter2<NewReviewDisplayOrder, int, int>
      $converternew_review_display_order =
      const EnumIndexConverter<NewReviewDisplayOrder>(
          NewReviewDisplayOrder.values);
}

class MemoryModel extends DataClass implements Insertable<MemoryModel> {
  String button_algorithm;
  int creator_user_id;
  String familiarity_algorithm;
  String? father_memory_model_id;
  String next_time_algorithm;
  String title;
  DateTime created_at;
  String id;
  DateTime updated_at;
  MemoryModel(
      {required this.button_algorithm,
      required this.creator_user_id,
      required this.familiarity_algorithm,
      this.father_memory_model_id,
      required this.next_time_algorithm,
      required this.title,
      required this.created_at,
      required this.id,
      required this.updated_at});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['button_algorithm'] = Variable<String>(button_algorithm);
    map['creator_user_id'] = Variable<int>(creator_user_id);
    map['familiarity_algorithm'] = Variable<String>(familiarity_algorithm);
    if (!nullToAbsent || father_memory_model_id != null) {
      map['father_memory_model_id'] = Variable<String>(father_memory_model_id);
    }
    map['next_time_algorithm'] = Variable<String>(next_time_algorithm);
    map['title'] = Variable<String>(title);
    map['created_at'] = Variable<DateTime>(created_at);
    map['id'] = Variable<String>(id);
    map['updated_at'] = Variable<DateTime>(updated_at);
    return map;
  }

  MemoryModelsCompanion toCompanion(bool nullToAbsent) {
    return MemoryModelsCompanion(
      button_algorithm: Value(button_algorithm),
      creator_user_id: Value(creator_user_id),
      familiarity_algorithm: Value(familiarity_algorithm),
      father_memory_model_id: father_memory_model_id == null && nullToAbsent
          ? const Value.absent()
          : Value(father_memory_model_id),
      next_time_algorithm: Value(next_time_algorithm),
      title: Value(title),
      created_at: Value(created_at),
      id: Value(id),
      updated_at: Value(updated_at),
    );
  }

  factory MemoryModel.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return MemoryModel(
      button_algorithm: serializer.fromJson<String>(json['button_algorithm']),
      creator_user_id: serializer.fromJson<int>(json['creator_user_id']),
      familiarity_algorithm:
          serializer.fromJson<String>(json['familiarity_algorithm']),
      father_memory_model_id:
          serializer.fromJson<String?>(json['father_memory_model_id']),
      next_time_algorithm:
          serializer.fromJson<String>(json['next_time_algorithm']),
      title: serializer.fromJson<String>(json['title']),
      created_at: serializer.fromJson<DateTime>(json['created_at']),
      id: serializer.fromJson<String>(json['id']),
      updated_at: serializer.fromJson<DateTime>(json['updated_at']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'button_algorithm': serializer.toJson<String>(button_algorithm),
      'creator_user_id': serializer.toJson<int>(creator_user_id),
      'familiarity_algorithm': serializer.toJson<String>(familiarity_algorithm),
      'father_memory_model_id':
          serializer.toJson<String?>(father_memory_model_id),
      'next_time_algorithm': serializer.toJson<String>(next_time_algorithm),
      'title': serializer.toJson<String>(title),
      'created_at': serializer.toJson<DateTime>(created_at),
      'id': serializer.toJson<String>(id),
      'updated_at': serializer.toJson<DateTime>(updated_at),
    };
  }

  MemoryModel copyWith(
          {String? button_algorithm,
          int? creator_user_id,
          String? familiarity_algorithm,
          Value<String?> father_memory_model_id = const Value.absent(),
          String? next_time_algorithm,
          String? title,
          DateTime? created_at,
          String? id,
          DateTime? updated_at}) =>
      MemoryModel(
        button_algorithm: button_algorithm ?? this.button_algorithm,
        creator_user_id: creator_user_id ?? this.creator_user_id,
        familiarity_algorithm:
            familiarity_algorithm ?? this.familiarity_algorithm,
        father_memory_model_id: father_memory_model_id.present
            ? father_memory_model_id.value
            : this.father_memory_model_id,
        next_time_algorithm: next_time_algorithm ?? this.next_time_algorithm,
        title: title ?? this.title,
        created_at: created_at ?? this.created_at,
        id: id ?? this.id,
        updated_at: updated_at ?? this.updated_at,
      );
  @override
  String toString() {
    return (StringBuffer('MemoryModel(')
          ..write('button_algorithm: $button_algorithm, ')
          ..write('creator_user_id: $creator_user_id, ')
          ..write('familiarity_algorithm: $familiarity_algorithm, ')
          ..write('father_memory_model_id: $father_memory_model_id, ')
          ..write('next_time_algorithm: $next_time_algorithm, ')
          ..write('title: $title, ')
          ..write('created_at: $created_at, ')
          ..write('id: $id, ')
          ..write('updated_at: $updated_at')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      button_algorithm,
      creator_user_id,
      familiarity_algorithm,
      father_memory_model_id,
      next_time_algorithm,
      title,
      created_at,
      id,
      updated_at);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is MemoryModel &&
          other.button_algorithm == this.button_algorithm &&
          other.creator_user_id == this.creator_user_id &&
          other.familiarity_algorithm == this.familiarity_algorithm &&
          other.father_memory_model_id == this.father_memory_model_id &&
          other.next_time_algorithm == this.next_time_algorithm &&
          other.title == this.title &&
          other.created_at == this.created_at &&
          other.id == this.id &&
          other.updated_at == this.updated_at);
}

class MemoryModelsCompanion extends UpdateCompanion<MemoryModel> {
  Value<String> button_algorithm;
  Value<int> creator_user_id;
  Value<String> familiarity_algorithm;
  Value<String?> father_memory_model_id;
  Value<String> next_time_algorithm;
  Value<String> title;
  Value<DateTime> created_at;
  Value<String> id;
  Value<DateTime> updated_at;
  MemoryModelsCompanion({
    this.button_algorithm = const Value.absent(),
    this.creator_user_id = const Value.absent(),
    this.familiarity_algorithm = const Value.absent(),
    this.father_memory_model_id = const Value.absent(),
    this.next_time_algorithm = const Value.absent(),
    this.title = const Value.absent(),
    this.created_at = const Value.absent(),
    this.id = const Value.absent(),
    this.updated_at = const Value.absent(),
  });
  MemoryModelsCompanion.insert({
    required String button_algorithm,
    required int creator_user_id,
    required String familiarity_algorithm,
    this.father_memory_model_id = const Value.absent(),
    required String next_time_algorithm,
    required String title,
    required DateTime created_at,
    required String id,
    required DateTime updated_at,
  })  : button_algorithm = Value(button_algorithm),
        creator_user_id = Value(creator_user_id),
        familiarity_algorithm = Value(familiarity_algorithm),
        next_time_algorithm = Value(next_time_algorithm),
        title = Value(title),
        created_at = Value(created_at),
        id = Value(id),
        updated_at = Value(updated_at);
  static Insertable<MemoryModel> custom({
    Expression<String>? button_algorithm,
    Expression<int>? creator_user_id,
    Expression<String>? familiarity_algorithm,
    Expression<String>? father_memory_model_id,
    Expression<String>? next_time_algorithm,
    Expression<String>? title,
    Expression<DateTime>? created_at,
    Expression<String>? id,
    Expression<DateTime>? updated_at,
  }) {
    return RawValuesInsertable({
      if (button_algorithm != null) 'button_algorithm': button_algorithm,
      if (creator_user_id != null) 'creator_user_id': creator_user_id,
      if (familiarity_algorithm != null)
        'familiarity_algorithm': familiarity_algorithm,
      if (father_memory_model_id != null)
        'father_memory_model_id': father_memory_model_id,
      if (next_time_algorithm != null)
        'next_time_algorithm': next_time_algorithm,
      if (title != null) 'title': title,
      if (created_at != null) 'created_at': created_at,
      if (id != null) 'id': id,
      if (updated_at != null) 'updated_at': updated_at,
    });
  }

  MemoryModelsCompanion copyWith(
      {Value<String>? button_algorithm,
      Value<int>? creator_user_id,
      Value<String>? familiarity_algorithm,
      Value<String?>? father_memory_model_id,
      Value<String>? next_time_algorithm,
      Value<String>? title,
      Value<DateTime>? created_at,
      Value<String>? id,
      Value<DateTime>? updated_at}) {
    return MemoryModelsCompanion(
      button_algorithm: button_algorithm ?? this.button_algorithm,
      creator_user_id: creator_user_id ?? this.creator_user_id,
      familiarity_algorithm:
          familiarity_algorithm ?? this.familiarity_algorithm,
      father_memory_model_id:
          father_memory_model_id ?? this.father_memory_model_id,
      next_time_algorithm: next_time_algorithm ?? this.next_time_algorithm,
      title: title ?? this.title,
      created_at: created_at ?? this.created_at,
      id: id ?? this.id,
      updated_at: updated_at ?? this.updated_at,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (button_algorithm.present) {
      map['button_algorithm'] = Variable<String>(button_algorithm.value);
    }
    if (creator_user_id.present) {
      map['creator_user_id'] = Variable<int>(creator_user_id.value);
    }
    if (familiarity_algorithm.present) {
      map['familiarity_algorithm'] =
          Variable<String>(familiarity_algorithm.value);
    }
    if (father_memory_model_id.present) {
      map['father_memory_model_id'] =
          Variable<String>(father_memory_model_id.value);
    }
    if (next_time_algorithm.present) {
      map['next_time_algorithm'] = Variable<String>(next_time_algorithm.value);
    }
    if (title.present) {
      map['title'] = Variable<String>(title.value);
    }
    if (created_at.present) {
      map['created_at'] = Variable<DateTime>(created_at.value);
    }
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (updated_at.present) {
      map['updated_at'] = Variable<DateTime>(updated_at.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('MemoryModelsCompanion(')
          ..write('button_algorithm: $button_algorithm, ')
          ..write('creator_user_id: $creator_user_id, ')
          ..write('familiarity_algorithm: $familiarity_algorithm, ')
          ..write('father_memory_model_id: $father_memory_model_id, ')
          ..write('next_time_algorithm: $next_time_algorithm, ')
          ..write('title: $title, ')
          ..write('created_at: $created_at, ')
          ..write('id: $id, ')
          ..write('updated_at: $updated_at')
          ..write(')'))
        .toString();
  }
}

class $MemoryModelsTable extends MemoryModels
    with TableInfo<$MemoryModelsTable, MemoryModel> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $MemoryModelsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _button_algorithmMeta =
      const VerificationMeta('button_algorithm');
  @override
  late final GeneratedColumn<String> button_algorithm = GeneratedColumn<String>(
      'button_algorithm', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _creator_user_idMeta =
      const VerificationMeta('creator_user_id');
  @override
  late final GeneratedColumn<int> creator_user_id = GeneratedColumn<int>(
      'creator_user_id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _familiarity_algorithmMeta =
      const VerificationMeta('familiarity_algorithm');
  @override
  late final GeneratedColumn<String> familiarity_algorithm =
      GeneratedColumn<String>('familiarity_algorithm', aliasedName, false,
          type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _father_memory_model_idMeta =
      const VerificationMeta('father_memory_model_id');
  @override
  late final GeneratedColumn<String> father_memory_model_id =
      GeneratedColumn<String>('father_memory_model_id', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _next_time_algorithmMeta =
      const VerificationMeta('next_time_algorithm');
  @override
  late final GeneratedColumn<String> next_time_algorithm =
      GeneratedColumn<String>('next_time_algorithm', aliasedName, false,
          type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _titleMeta = const VerificationMeta('title');
  @override
  late final GeneratedColumn<String> title = GeneratedColumn<String>(
      'title', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _created_atMeta =
      const VerificationMeta('created_at');
  @override
  late final GeneratedColumn<DateTime> created_at = GeneratedColumn<DateTime>(
      'created_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _updated_atMeta =
      const VerificationMeta('updated_at');
  @override
  late final GeneratedColumn<DateTime> updated_at = GeneratedColumn<DateTime>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns => [
        button_algorithm,
        creator_user_id,
        familiarity_algorithm,
        father_memory_model_id,
        next_time_algorithm,
        title,
        created_at,
        id,
        updated_at
      ];
  @override
  String get aliasedName => _alias ?? 'memory_models';
  @override
  String get actualTableName => 'memory_models';
  @override
  VerificationContext validateIntegrity(Insertable<MemoryModel> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('button_algorithm')) {
      context.handle(
          _button_algorithmMeta,
          button_algorithm.isAcceptableOrUnknown(
              data['button_algorithm']!, _button_algorithmMeta));
    } else if (isInserting) {
      context.missing(_button_algorithmMeta);
    }
    if (data.containsKey('creator_user_id')) {
      context.handle(
          _creator_user_idMeta,
          creator_user_id.isAcceptableOrUnknown(
              data['creator_user_id']!, _creator_user_idMeta));
    } else if (isInserting) {
      context.missing(_creator_user_idMeta);
    }
    if (data.containsKey('familiarity_algorithm')) {
      context.handle(
          _familiarity_algorithmMeta,
          familiarity_algorithm.isAcceptableOrUnknown(
              data['familiarity_algorithm']!, _familiarity_algorithmMeta));
    } else if (isInserting) {
      context.missing(_familiarity_algorithmMeta);
    }
    if (data.containsKey('father_memory_model_id')) {
      context.handle(
          _father_memory_model_idMeta,
          father_memory_model_id.isAcceptableOrUnknown(
              data['father_memory_model_id']!, _father_memory_model_idMeta));
    }
    if (data.containsKey('next_time_algorithm')) {
      context.handle(
          _next_time_algorithmMeta,
          next_time_algorithm.isAcceptableOrUnknown(
              data['next_time_algorithm']!, _next_time_algorithmMeta));
    } else if (isInserting) {
      context.missing(_next_time_algorithmMeta);
    }
    if (data.containsKey('title')) {
      context.handle(
          _titleMeta, title.isAcceptableOrUnknown(data['title']!, _titleMeta));
    } else if (isInserting) {
      context.missing(_titleMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(
          _created_atMeta,
          created_at.isAcceptableOrUnknown(
              data['created_at']!, _created_atMeta));
    } else if (isInserting) {
      context.missing(_created_atMeta);
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
          _updated_atMeta,
          updated_at.isAcceptableOrUnknown(
              data['updated_at']!, _updated_atMeta));
    } else if (isInserting) {
      context.missing(_updated_atMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  MemoryModel map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return MemoryModel(
      button_algorithm: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}button_algorithm'])!,
      creator_user_id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}creator_user_id'])!,
      familiarity_algorithm: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}familiarity_algorithm'])!,
      father_memory_model_id: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}father_memory_model_id']),
      next_time_algorithm: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}next_time_algorithm'])!,
      title: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}title'])!,
      created_at: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_at'])!,
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id'])!,
      updated_at: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}updated_at'])!,
    );
  }

  @override
  $MemoryModelsTable createAlias(String alias) {
    return $MemoryModelsTable(attachedDatabase, alias);
  }
}

class Note extends DataClass implements Insertable<Note> {
  String content;
  int creator_user_id;
  String? document_id;
  String? father_note_id;
  DateTime created_at;
  String id;
  DateTime updated_at;
  Note(
      {required this.content,
      required this.creator_user_id,
      this.document_id,
      this.father_note_id,
      required this.created_at,
      required this.id,
      required this.updated_at});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['content'] = Variable<String>(content);
    map['creator_user_id'] = Variable<int>(creator_user_id);
    if (!nullToAbsent || document_id != null) {
      map['document_id'] = Variable<String>(document_id);
    }
    if (!nullToAbsent || father_note_id != null) {
      map['father_note_id'] = Variable<String>(father_note_id);
    }
    map['created_at'] = Variable<DateTime>(created_at);
    map['id'] = Variable<String>(id);
    map['updated_at'] = Variable<DateTime>(updated_at);
    return map;
  }

  NotesCompanion toCompanion(bool nullToAbsent) {
    return NotesCompanion(
      content: Value(content),
      creator_user_id: Value(creator_user_id),
      document_id: document_id == null && nullToAbsent
          ? const Value.absent()
          : Value(document_id),
      father_note_id: father_note_id == null && nullToAbsent
          ? const Value.absent()
          : Value(father_note_id),
      created_at: Value(created_at),
      id: Value(id),
      updated_at: Value(updated_at),
    );
  }

  factory Note.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Note(
      content: serializer.fromJson<String>(json['content']),
      creator_user_id: serializer.fromJson<int>(json['creator_user_id']),
      document_id: serializer.fromJson<String?>(json['document_id']),
      father_note_id: serializer.fromJson<String?>(json['father_note_id']),
      created_at: serializer.fromJson<DateTime>(json['created_at']),
      id: serializer.fromJson<String>(json['id']),
      updated_at: serializer.fromJson<DateTime>(json['updated_at']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'content': serializer.toJson<String>(content),
      'creator_user_id': serializer.toJson<int>(creator_user_id),
      'document_id': serializer.toJson<String?>(document_id),
      'father_note_id': serializer.toJson<String?>(father_note_id),
      'created_at': serializer.toJson<DateTime>(created_at),
      'id': serializer.toJson<String>(id),
      'updated_at': serializer.toJson<DateTime>(updated_at),
    };
  }

  Note copyWith(
          {String? content,
          int? creator_user_id,
          Value<String?> document_id = const Value.absent(),
          Value<String?> father_note_id = const Value.absent(),
          DateTime? created_at,
          String? id,
          DateTime? updated_at}) =>
      Note(
        content: content ?? this.content,
        creator_user_id: creator_user_id ?? this.creator_user_id,
        document_id: document_id.present ? document_id.value : this.document_id,
        father_note_id:
            father_note_id.present ? father_note_id.value : this.father_note_id,
        created_at: created_at ?? this.created_at,
        id: id ?? this.id,
        updated_at: updated_at ?? this.updated_at,
      );
  @override
  String toString() {
    return (StringBuffer('Note(')
          ..write('content: $content, ')
          ..write('creator_user_id: $creator_user_id, ')
          ..write('document_id: $document_id, ')
          ..write('father_note_id: $father_note_id, ')
          ..write('created_at: $created_at, ')
          ..write('id: $id, ')
          ..write('updated_at: $updated_at')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(content, creator_user_id, document_id,
      father_note_id, created_at, id, updated_at);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Note &&
          other.content == this.content &&
          other.creator_user_id == this.creator_user_id &&
          other.document_id == this.document_id &&
          other.father_note_id == this.father_note_id &&
          other.created_at == this.created_at &&
          other.id == this.id &&
          other.updated_at == this.updated_at);
}

class NotesCompanion extends UpdateCompanion<Note> {
  Value<String> content;
  Value<int> creator_user_id;
  Value<String?> document_id;
  Value<String?> father_note_id;
  Value<DateTime> created_at;
  Value<String> id;
  Value<DateTime> updated_at;
  NotesCompanion({
    this.content = const Value.absent(),
    this.creator_user_id = const Value.absent(),
    this.document_id = const Value.absent(),
    this.father_note_id = const Value.absent(),
    this.created_at = const Value.absent(),
    this.id = const Value.absent(),
    this.updated_at = const Value.absent(),
  });
  NotesCompanion.insert({
    required String content,
    required int creator_user_id,
    this.document_id = const Value.absent(),
    this.father_note_id = const Value.absent(),
    required DateTime created_at,
    required String id,
    required DateTime updated_at,
  })  : content = Value(content),
        creator_user_id = Value(creator_user_id),
        created_at = Value(created_at),
        id = Value(id),
        updated_at = Value(updated_at);
  static Insertable<Note> custom({
    Expression<String>? content,
    Expression<int>? creator_user_id,
    Expression<String>? document_id,
    Expression<String>? father_note_id,
    Expression<DateTime>? created_at,
    Expression<String>? id,
    Expression<DateTime>? updated_at,
  }) {
    return RawValuesInsertable({
      if (content != null) 'content': content,
      if (creator_user_id != null) 'creator_user_id': creator_user_id,
      if (document_id != null) 'document_id': document_id,
      if (father_note_id != null) 'father_note_id': father_note_id,
      if (created_at != null) 'created_at': created_at,
      if (id != null) 'id': id,
      if (updated_at != null) 'updated_at': updated_at,
    });
  }

  NotesCompanion copyWith(
      {Value<String>? content,
      Value<int>? creator_user_id,
      Value<String?>? document_id,
      Value<String?>? father_note_id,
      Value<DateTime>? created_at,
      Value<String>? id,
      Value<DateTime>? updated_at}) {
    return NotesCompanion(
      content: content ?? this.content,
      creator_user_id: creator_user_id ?? this.creator_user_id,
      document_id: document_id ?? this.document_id,
      father_note_id: father_note_id ?? this.father_note_id,
      created_at: created_at ?? this.created_at,
      id: id ?? this.id,
      updated_at: updated_at ?? this.updated_at,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (content.present) {
      map['content'] = Variable<String>(content.value);
    }
    if (creator_user_id.present) {
      map['creator_user_id'] = Variable<int>(creator_user_id.value);
    }
    if (document_id.present) {
      map['document_id'] = Variable<String>(document_id.value);
    }
    if (father_note_id.present) {
      map['father_note_id'] = Variable<String>(father_note_id.value);
    }
    if (created_at.present) {
      map['created_at'] = Variable<DateTime>(created_at.value);
    }
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (updated_at.present) {
      map['updated_at'] = Variable<DateTime>(updated_at.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('NotesCompanion(')
          ..write('content: $content, ')
          ..write('creator_user_id: $creator_user_id, ')
          ..write('document_id: $document_id, ')
          ..write('father_note_id: $father_note_id, ')
          ..write('created_at: $created_at, ')
          ..write('id: $id, ')
          ..write('updated_at: $updated_at')
          ..write(')'))
        .toString();
  }
}

class $NotesTable extends Notes with TableInfo<$NotesTable, Note> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $NotesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _contentMeta =
      const VerificationMeta('content');
  @override
  late final GeneratedColumn<String> content = GeneratedColumn<String>(
      'content', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _creator_user_idMeta =
      const VerificationMeta('creator_user_id');
  @override
  late final GeneratedColumn<int> creator_user_id = GeneratedColumn<int>(
      'creator_user_id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _document_idMeta =
      const VerificationMeta('document_id');
  @override
  late final GeneratedColumn<String> document_id = GeneratedColumn<String>(
      'document_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _father_note_idMeta =
      const VerificationMeta('father_note_id');
  @override
  late final GeneratedColumn<String> father_note_id = GeneratedColumn<String>(
      'father_note_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _created_atMeta =
      const VerificationMeta('created_at');
  @override
  late final GeneratedColumn<DateTime> created_at = GeneratedColumn<DateTime>(
      'created_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _updated_atMeta =
      const VerificationMeta('updated_at');
  @override
  late final GeneratedColumn<DateTime> updated_at = GeneratedColumn<DateTime>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns => [
        content,
        creator_user_id,
        document_id,
        father_note_id,
        created_at,
        id,
        updated_at
      ];
  @override
  String get aliasedName => _alias ?? 'notes';
  @override
  String get actualTableName => 'notes';
  @override
  VerificationContext validateIntegrity(Insertable<Note> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('content')) {
      context.handle(_contentMeta,
          content.isAcceptableOrUnknown(data['content']!, _contentMeta));
    } else if (isInserting) {
      context.missing(_contentMeta);
    }
    if (data.containsKey('creator_user_id')) {
      context.handle(
          _creator_user_idMeta,
          creator_user_id.isAcceptableOrUnknown(
              data['creator_user_id']!, _creator_user_idMeta));
    } else if (isInserting) {
      context.missing(_creator_user_idMeta);
    }
    if (data.containsKey('document_id')) {
      context.handle(
          _document_idMeta,
          document_id.isAcceptableOrUnknown(
              data['document_id']!, _document_idMeta));
    }
    if (data.containsKey('father_note_id')) {
      context.handle(
          _father_note_idMeta,
          father_note_id.isAcceptableOrUnknown(
              data['father_note_id']!, _father_note_idMeta));
    }
    if (data.containsKey('created_at')) {
      context.handle(
          _created_atMeta,
          created_at.isAcceptableOrUnknown(
              data['created_at']!, _created_atMeta));
    } else if (isInserting) {
      context.missing(_created_atMeta);
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
          _updated_atMeta,
          updated_at.isAcceptableOrUnknown(
              data['updated_at']!, _updated_atMeta));
    } else if (isInserting) {
      context.missing(_updated_atMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Note map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Note(
      content: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}content'])!,
      creator_user_id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}creator_user_id'])!,
      document_id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}document_id']),
      father_note_id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}father_note_id']),
      created_at: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_at'])!,
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id'])!,
      updated_at: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}updated_at'])!,
    );
  }

  @override
  $NotesTable createAlias(String alias) {
    return $NotesTable(attachedDatabase, alias);
  }
}

class DocumentGroup extends DataClass implements Insertable<DocumentGroup> {
  int creator_user_id;
  String? father_document_groups_id;
  String title;
  DateTime created_at;
  String id;
  DateTime updated_at;
  DocumentGroup(
      {required this.creator_user_id,
      this.father_document_groups_id,
      required this.title,
      required this.created_at,
      required this.id,
      required this.updated_at});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['creator_user_id'] = Variable<int>(creator_user_id);
    if (!nullToAbsent || father_document_groups_id != null) {
      map['father_document_groups_id'] =
          Variable<String>(father_document_groups_id);
    }
    map['title'] = Variable<String>(title);
    map['created_at'] = Variable<DateTime>(created_at);
    map['id'] = Variable<String>(id);
    map['updated_at'] = Variable<DateTime>(updated_at);
    return map;
  }

  DocumentGroupsCompanion toCompanion(bool nullToAbsent) {
    return DocumentGroupsCompanion(
      creator_user_id: Value(creator_user_id),
      father_document_groups_id:
          father_document_groups_id == null && nullToAbsent
              ? const Value.absent()
              : Value(father_document_groups_id),
      title: Value(title),
      created_at: Value(created_at),
      id: Value(id),
      updated_at: Value(updated_at),
    );
  }

  factory DocumentGroup.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return DocumentGroup(
      creator_user_id: serializer.fromJson<int>(json['creator_user_id']),
      father_document_groups_id:
          serializer.fromJson<String?>(json['father_document_groups_id']),
      title: serializer.fromJson<String>(json['title']),
      created_at: serializer.fromJson<DateTime>(json['created_at']),
      id: serializer.fromJson<String>(json['id']),
      updated_at: serializer.fromJson<DateTime>(json['updated_at']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'creator_user_id': serializer.toJson<int>(creator_user_id),
      'father_document_groups_id':
          serializer.toJson<String?>(father_document_groups_id),
      'title': serializer.toJson<String>(title),
      'created_at': serializer.toJson<DateTime>(created_at),
      'id': serializer.toJson<String>(id),
      'updated_at': serializer.toJson<DateTime>(updated_at),
    };
  }

  DocumentGroup copyWith(
          {int? creator_user_id,
          Value<String?> father_document_groups_id = const Value.absent(),
          String? title,
          DateTime? created_at,
          String? id,
          DateTime? updated_at}) =>
      DocumentGroup(
        creator_user_id: creator_user_id ?? this.creator_user_id,
        father_document_groups_id: father_document_groups_id.present
            ? father_document_groups_id.value
            : this.father_document_groups_id,
        title: title ?? this.title,
        created_at: created_at ?? this.created_at,
        id: id ?? this.id,
        updated_at: updated_at ?? this.updated_at,
      );
  @override
  String toString() {
    return (StringBuffer('DocumentGroup(')
          ..write('creator_user_id: $creator_user_id, ')
          ..write('father_document_groups_id: $father_document_groups_id, ')
          ..write('title: $title, ')
          ..write('created_at: $created_at, ')
          ..write('id: $id, ')
          ..write('updated_at: $updated_at')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(creator_user_id, father_document_groups_id,
      title, created_at, id, updated_at);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is DocumentGroup &&
          other.creator_user_id == this.creator_user_id &&
          other.father_document_groups_id == this.father_document_groups_id &&
          other.title == this.title &&
          other.created_at == this.created_at &&
          other.id == this.id &&
          other.updated_at == this.updated_at);
}

class DocumentGroupsCompanion extends UpdateCompanion<DocumentGroup> {
  Value<int> creator_user_id;
  Value<String?> father_document_groups_id;
  Value<String> title;
  Value<DateTime> created_at;
  Value<String> id;
  Value<DateTime> updated_at;
  DocumentGroupsCompanion({
    this.creator_user_id = const Value.absent(),
    this.father_document_groups_id = const Value.absent(),
    this.title = const Value.absent(),
    this.created_at = const Value.absent(),
    this.id = const Value.absent(),
    this.updated_at = const Value.absent(),
  });
  DocumentGroupsCompanion.insert({
    required int creator_user_id,
    this.father_document_groups_id = const Value.absent(),
    required String title,
    required DateTime created_at,
    required String id,
    required DateTime updated_at,
  })  : creator_user_id = Value(creator_user_id),
        title = Value(title),
        created_at = Value(created_at),
        id = Value(id),
        updated_at = Value(updated_at);
  static Insertable<DocumentGroup> custom({
    Expression<int>? creator_user_id,
    Expression<String>? father_document_groups_id,
    Expression<String>? title,
    Expression<DateTime>? created_at,
    Expression<String>? id,
    Expression<DateTime>? updated_at,
  }) {
    return RawValuesInsertable({
      if (creator_user_id != null) 'creator_user_id': creator_user_id,
      if (father_document_groups_id != null)
        'father_document_groups_id': father_document_groups_id,
      if (title != null) 'title': title,
      if (created_at != null) 'created_at': created_at,
      if (id != null) 'id': id,
      if (updated_at != null) 'updated_at': updated_at,
    });
  }

  DocumentGroupsCompanion copyWith(
      {Value<int>? creator_user_id,
      Value<String?>? father_document_groups_id,
      Value<String>? title,
      Value<DateTime>? created_at,
      Value<String>? id,
      Value<DateTime>? updated_at}) {
    return DocumentGroupsCompanion(
      creator_user_id: creator_user_id ?? this.creator_user_id,
      father_document_groups_id:
          father_document_groups_id ?? this.father_document_groups_id,
      title: title ?? this.title,
      created_at: created_at ?? this.created_at,
      id: id ?? this.id,
      updated_at: updated_at ?? this.updated_at,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (creator_user_id.present) {
      map['creator_user_id'] = Variable<int>(creator_user_id.value);
    }
    if (father_document_groups_id.present) {
      map['father_document_groups_id'] =
          Variable<String>(father_document_groups_id.value);
    }
    if (title.present) {
      map['title'] = Variable<String>(title.value);
    }
    if (created_at.present) {
      map['created_at'] = Variable<DateTime>(created_at.value);
    }
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (updated_at.present) {
      map['updated_at'] = Variable<DateTime>(updated_at.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('DocumentGroupsCompanion(')
          ..write('creator_user_id: $creator_user_id, ')
          ..write('father_document_groups_id: $father_document_groups_id, ')
          ..write('title: $title, ')
          ..write('created_at: $created_at, ')
          ..write('id: $id, ')
          ..write('updated_at: $updated_at')
          ..write(')'))
        .toString();
  }
}

class $DocumentGroupsTable extends DocumentGroups
    with TableInfo<$DocumentGroupsTable, DocumentGroup> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $DocumentGroupsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _creator_user_idMeta =
      const VerificationMeta('creator_user_id');
  @override
  late final GeneratedColumn<int> creator_user_id = GeneratedColumn<int>(
      'creator_user_id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _father_document_groups_idMeta =
      const VerificationMeta('father_document_groups_id');
  @override
  late final GeneratedColumn<String> father_document_groups_id =
      GeneratedColumn<String>('father_document_groups_id', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _titleMeta = const VerificationMeta('title');
  @override
  late final GeneratedColumn<String> title = GeneratedColumn<String>(
      'title', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _created_atMeta =
      const VerificationMeta('created_at');
  @override
  late final GeneratedColumn<DateTime> created_at = GeneratedColumn<DateTime>(
      'created_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _updated_atMeta =
      const VerificationMeta('updated_at');
  @override
  late final GeneratedColumn<DateTime> updated_at = GeneratedColumn<DateTime>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns => [
        creator_user_id,
        father_document_groups_id,
        title,
        created_at,
        id,
        updated_at
      ];
  @override
  String get aliasedName => _alias ?? 'document_groups';
  @override
  String get actualTableName => 'document_groups';
  @override
  VerificationContext validateIntegrity(Insertable<DocumentGroup> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('creator_user_id')) {
      context.handle(
          _creator_user_idMeta,
          creator_user_id.isAcceptableOrUnknown(
              data['creator_user_id']!, _creator_user_idMeta));
    } else if (isInserting) {
      context.missing(_creator_user_idMeta);
    }
    if (data.containsKey('father_document_groups_id')) {
      context.handle(
          _father_document_groups_idMeta,
          father_document_groups_id.isAcceptableOrUnknown(
              data['father_document_groups_id']!,
              _father_document_groups_idMeta));
    }
    if (data.containsKey('title')) {
      context.handle(
          _titleMeta, title.isAcceptableOrUnknown(data['title']!, _titleMeta));
    } else if (isInserting) {
      context.missing(_titleMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(
          _created_atMeta,
          created_at.isAcceptableOrUnknown(
              data['created_at']!, _created_atMeta));
    } else if (isInserting) {
      context.missing(_created_atMeta);
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
          _updated_atMeta,
          updated_at.isAcceptableOrUnknown(
              data['updated_at']!, _updated_atMeta));
    } else if (isInserting) {
      context.missing(_updated_atMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  DocumentGroup map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return DocumentGroup(
      creator_user_id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}creator_user_id'])!,
      father_document_groups_id: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}father_document_groups_id']),
      title: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}title'])!,
      created_at: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_at'])!,
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id'])!,
      updated_at: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}updated_at'])!,
    );
  }

  @override
  $DocumentGroupsTable createAlias(String alias) {
    return $DocumentGroupsTable(attachedDatabase, alias);
  }
}

class FragmentGroup extends DataClass implements Insertable<FragmentGroup> {
  bool client_be_selected;
  int creator_user_id;
  String? father_fragment_groups_id;
  String title;
  DateTime created_at;
  String id;
  DateTime updated_at;
  FragmentGroup(
      {required this.client_be_selected,
      required this.creator_user_id,
      this.father_fragment_groups_id,
      required this.title,
      required this.created_at,
      required this.id,
      required this.updated_at});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['client_be_selected'] = Variable<bool>(client_be_selected);
    map['creator_user_id'] = Variable<int>(creator_user_id);
    if (!nullToAbsent || father_fragment_groups_id != null) {
      map['father_fragment_groups_id'] =
          Variable<String>(father_fragment_groups_id);
    }
    map['title'] = Variable<String>(title);
    map['created_at'] = Variable<DateTime>(created_at);
    map['id'] = Variable<String>(id);
    map['updated_at'] = Variable<DateTime>(updated_at);
    return map;
  }

  FragmentGroupsCompanion toCompanion(bool nullToAbsent) {
    return FragmentGroupsCompanion(
      client_be_selected: Value(client_be_selected),
      creator_user_id: Value(creator_user_id),
      father_fragment_groups_id:
          father_fragment_groups_id == null && nullToAbsent
              ? const Value.absent()
              : Value(father_fragment_groups_id),
      title: Value(title),
      created_at: Value(created_at),
      id: Value(id),
      updated_at: Value(updated_at),
    );
  }

  factory FragmentGroup.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return FragmentGroup(
      client_be_selected: serializer.fromJson<bool>(json['client_be_selected']),
      creator_user_id: serializer.fromJson<int>(json['creator_user_id']),
      father_fragment_groups_id:
          serializer.fromJson<String?>(json['father_fragment_groups_id']),
      title: serializer.fromJson<String>(json['title']),
      created_at: serializer.fromJson<DateTime>(json['created_at']),
      id: serializer.fromJson<String>(json['id']),
      updated_at: serializer.fromJson<DateTime>(json['updated_at']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'client_be_selected': serializer.toJson<bool>(client_be_selected),
      'creator_user_id': serializer.toJson<int>(creator_user_id),
      'father_fragment_groups_id':
          serializer.toJson<String?>(father_fragment_groups_id),
      'title': serializer.toJson<String>(title),
      'created_at': serializer.toJson<DateTime>(created_at),
      'id': serializer.toJson<String>(id),
      'updated_at': serializer.toJson<DateTime>(updated_at),
    };
  }

  FragmentGroup copyWith(
          {bool? client_be_selected,
          int? creator_user_id,
          Value<String?> father_fragment_groups_id = const Value.absent(),
          String? title,
          DateTime? created_at,
          String? id,
          DateTime? updated_at}) =>
      FragmentGroup(
        client_be_selected: client_be_selected ?? this.client_be_selected,
        creator_user_id: creator_user_id ?? this.creator_user_id,
        father_fragment_groups_id: father_fragment_groups_id.present
            ? father_fragment_groups_id.value
            : this.father_fragment_groups_id,
        title: title ?? this.title,
        created_at: created_at ?? this.created_at,
        id: id ?? this.id,
        updated_at: updated_at ?? this.updated_at,
      );
  @override
  String toString() {
    return (StringBuffer('FragmentGroup(')
          ..write('client_be_selected: $client_be_selected, ')
          ..write('creator_user_id: $creator_user_id, ')
          ..write('father_fragment_groups_id: $father_fragment_groups_id, ')
          ..write('title: $title, ')
          ..write('created_at: $created_at, ')
          ..write('id: $id, ')
          ..write('updated_at: $updated_at')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(client_be_selected, creator_user_id,
      father_fragment_groups_id, title, created_at, id, updated_at);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is FragmentGroup &&
          other.client_be_selected == this.client_be_selected &&
          other.creator_user_id == this.creator_user_id &&
          other.father_fragment_groups_id == this.father_fragment_groups_id &&
          other.title == this.title &&
          other.created_at == this.created_at &&
          other.id == this.id &&
          other.updated_at == this.updated_at);
}

class FragmentGroupsCompanion extends UpdateCompanion<FragmentGroup> {
  Value<bool> client_be_selected;
  Value<int> creator_user_id;
  Value<String?> father_fragment_groups_id;
  Value<String> title;
  Value<DateTime> created_at;
  Value<String> id;
  Value<DateTime> updated_at;
  FragmentGroupsCompanion({
    this.client_be_selected = const Value.absent(),
    this.creator_user_id = const Value.absent(),
    this.father_fragment_groups_id = const Value.absent(),
    this.title = const Value.absent(),
    this.created_at = const Value.absent(),
    this.id = const Value.absent(),
    this.updated_at = const Value.absent(),
  });
  FragmentGroupsCompanion.insert({
    required bool client_be_selected,
    required int creator_user_id,
    this.father_fragment_groups_id = const Value.absent(),
    required String title,
    required DateTime created_at,
    required String id,
    required DateTime updated_at,
  })  : client_be_selected = Value(client_be_selected),
        creator_user_id = Value(creator_user_id),
        title = Value(title),
        created_at = Value(created_at),
        id = Value(id),
        updated_at = Value(updated_at);
  static Insertable<FragmentGroup> custom({
    Expression<bool>? client_be_selected,
    Expression<int>? creator_user_id,
    Expression<String>? father_fragment_groups_id,
    Expression<String>? title,
    Expression<DateTime>? created_at,
    Expression<String>? id,
    Expression<DateTime>? updated_at,
  }) {
    return RawValuesInsertable({
      if (client_be_selected != null) 'client_be_selected': client_be_selected,
      if (creator_user_id != null) 'creator_user_id': creator_user_id,
      if (father_fragment_groups_id != null)
        'father_fragment_groups_id': father_fragment_groups_id,
      if (title != null) 'title': title,
      if (created_at != null) 'created_at': created_at,
      if (id != null) 'id': id,
      if (updated_at != null) 'updated_at': updated_at,
    });
  }

  FragmentGroupsCompanion copyWith(
      {Value<bool>? client_be_selected,
      Value<int>? creator_user_id,
      Value<String?>? father_fragment_groups_id,
      Value<String>? title,
      Value<DateTime>? created_at,
      Value<String>? id,
      Value<DateTime>? updated_at}) {
    return FragmentGroupsCompanion(
      client_be_selected: client_be_selected ?? this.client_be_selected,
      creator_user_id: creator_user_id ?? this.creator_user_id,
      father_fragment_groups_id:
          father_fragment_groups_id ?? this.father_fragment_groups_id,
      title: title ?? this.title,
      created_at: created_at ?? this.created_at,
      id: id ?? this.id,
      updated_at: updated_at ?? this.updated_at,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (client_be_selected.present) {
      map['client_be_selected'] = Variable<bool>(client_be_selected.value);
    }
    if (creator_user_id.present) {
      map['creator_user_id'] = Variable<int>(creator_user_id.value);
    }
    if (father_fragment_groups_id.present) {
      map['father_fragment_groups_id'] =
          Variable<String>(father_fragment_groups_id.value);
    }
    if (title.present) {
      map['title'] = Variable<String>(title.value);
    }
    if (created_at.present) {
      map['created_at'] = Variable<DateTime>(created_at.value);
    }
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (updated_at.present) {
      map['updated_at'] = Variable<DateTime>(updated_at.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('FragmentGroupsCompanion(')
          ..write('client_be_selected: $client_be_selected, ')
          ..write('creator_user_id: $creator_user_id, ')
          ..write('father_fragment_groups_id: $father_fragment_groups_id, ')
          ..write('title: $title, ')
          ..write('created_at: $created_at, ')
          ..write('id: $id, ')
          ..write('updated_at: $updated_at')
          ..write(')'))
        .toString();
  }
}

class $FragmentGroupsTable extends FragmentGroups
    with TableInfo<$FragmentGroupsTable, FragmentGroup> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $FragmentGroupsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _client_be_selectedMeta =
      const VerificationMeta('client_be_selected');
  @override
  late final GeneratedColumn<bool> client_be_selected =
      GeneratedColumn<bool>('client_be_selected', aliasedName, false,
          type: DriftSqlType.bool,
          requiredDuringInsert: true,
          defaultConstraints: GeneratedColumn.constraintsDependsOnDialect({
            SqlDialect.sqlite: 'CHECK ("client_be_selected" IN (0, 1))',
            SqlDialect.mysql: '',
            SqlDialect.postgres: '',
          }));
  static const VerificationMeta _creator_user_idMeta =
      const VerificationMeta('creator_user_id');
  @override
  late final GeneratedColumn<int> creator_user_id = GeneratedColumn<int>(
      'creator_user_id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _father_fragment_groups_idMeta =
      const VerificationMeta('father_fragment_groups_id');
  @override
  late final GeneratedColumn<String> father_fragment_groups_id =
      GeneratedColumn<String>('father_fragment_groups_id', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _titleMeta = const VerificationMeta('title');
  @override
  late final GeneratedColumn<String> title = GeneratedColumn<String>(
      'title', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _created_atMeta =
      const VerificationMeta('created_at');
  @override
  late final GeneratedColumn<DateTime> created_at = GeneratedColumn<DateTime>(
      'created_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _updated_atMeta =
      const VerificationMeta('updated_at');
  @override
  late final GeneratedColumn<DateTime> updated_at = GeneratedColumn<DateTime>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns => [
        client_be_selected,
        creator_user_id,
        father_fragment_groups_id,
        title,
        created_at,
        id,
        updated_at
      ];
  @override
  String get aliasedName => _alias ?? 'fragment_groups';
  @override
  String get actualTableName => 'fragment_groups';
  @override
  VerificationContext validateIntegrity(Insertable<FragmentGroup> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('client_be_selected')) {
      context.handle(
          _client_be_selectedMeta,
          client_be_selected.isAcceptableOrUnknown(
              data['client_be_selected']!, _client_be_selectedMeta));
    } else if (isInserting) {
      context.missing(_client_be_selectedMeta);
    }
    if (data.containsKey('creator_user_id')) {
      context.handle(
          _creator_user_idMeta,
          creator_user_id.isAcceptableOrUnknown(
              data['creator_user_id']!, _creator_user_idMeta));
    } else if (isInserting) {
      context.missing(_creator_user_idMeta);
    }
    if (data.containsKey('father_fragment_groups_id')) {
      context.handle(
          _father_fragment_groups_idMeta,
          father_fragment_groups_id.isAcceptableOrUnknown(
              data['father_fragment_groups_id']!,
              _father_fragment_groups_idMeta));
    }
    if (data.containsKey('title')) {
      context.handle(
          _titleMeta, title.isAcceptableOrUnknown(data['title']!, _titleMeta));
    } else if (isInserting) {
      context.missing(_titleMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(
          _created_atMeta,
          created_at.isAcceptableOrUnknown(
              data['created_at']!, _created_atMeta));
    } else if (isInserting) {
      context.missing(_created_atMeta);
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
          _updated_atMeta,
          updated_at.isAcceptableOrUnknown(
              data['updated_at']!, _updated_atMeta));
    } else if (isInserting) {
      context.missing(_updated_atMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  FragmentGroup map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return FragmentGroup(
      client_be_selected: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}client_be_selected'])!,
      creator_user_id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}creator_user_id'])!,
      father_fragment_groups_id: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}father_fragment_groups_id']),
      title: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}title'])!,
      created_at: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_at'])!,
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id'])!,
      updated_at: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}updated_at'])!,
    );
  }

  @override
  $FragmentGroupsTable createAlias(String alias) {
    return $FragmentGroupsTable(attachedDatabase, alias);
  }
}

class NoteGroup extends DataClass implements Insertable<NoteGroup> {
  int creator_user_id;
  String? father_note_groups_id;
  String title;
  DateTime created_at;
  String id;
  DateTime updated_at;
  NoteGroup(
      {required this.creator_user_id,
      this.father_note_groups_id,
      required this.title,
      required this.created_at,
      required this.id,
      required this.updated_at});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['creator_user_id'] = Variable<int>(creator_user_id);
    if (!nullToAbsent || father_note_groups_id != null) {
      map['father_note_groups_id'] = Variable<String>(father_note_groups_id);
    }
    map['title'] = Variable<String>(title);
    map['created_at'] = Variable<DateTime>(created_at);
    map['id'] = Variable<String>(id);
    map['updated_at'] = Variable<DateTime>(updated_at);
    return map;
  }

  NoteGroupsCompanion toCompanion(bool nullToAbsent) {
    return NoteGroupsCompanion(
      creator_user_id: Value(creator_user_id),
      father_note_groups_id: father_note_groups_id == null && nullToAbsent
          ? const Value.absent()
          : Value(father_note_groups_id),
      title: Value(title),
      created_at: Value(created_at),
      id: Value(id),
      updated_at: Value(updated_at),
    );
  }

  factory NoteGroup.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return NoteGroup(
      creator_user_id: serializer.fromJson<int>(json['creator_user_id']),
      father_note_groups_id:
          serializer.fromJson<String?>(json['father_note_groups_id']),
      title: serializer.fromJson<String>(json['title']),
      created_at: serializer.fromJson<DateTime>(json['created_at']),
      id: serializer.fromJson<String>(json['id']),
      updated_at: serializer.fromJson<DateTime>(json['updated_at']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'creator_user_id': serializer.toJson<int>(creator_user_id),
      'father_note_groups_id':
          serializer.toJson<String?>(father_note_groups_id),
      'title': serializer.toJson<String>(title),
      'created_at': serializer.toJson<DateTime>(created_at),
      'id': serializer.toJson<String>(id),
      'updated_at': serializer.toJson<DateTime>(updated_at),
    };
  }

  NoteGroup copyWith(
          {int? creator_user_id,
          Value<String?> father_note_groups_id = const Value.absent(),
          String? title,
          DateTime? created_at,
          String? id,
          DateTime? updated_at}) =>
      NoteGroup(
        creator_user_id: creator_user_id ?? this.creator_user_id,
        father_note_groups_id: father_note_groups_id.present
            ? father_note_groups_id.value
            : this.father_note_groups_id,
        title: title ?? this.title,
        created_at: created_at ?? this.created_at,
        id: id ?? this.id,
        updated_at: updated_at ?? this.updated_at,
      );
  @override
  String toString() {
    return (StringBuffer('NoteGroup(')
          ..write('creator_user_id: $creator_user_id, ')
          ..write('father_note_groups_id: $father_note_groups_id, ')
          ..write('title: $title, ')
          ..write('created_at: $created_at, ')
          ..write('id: $id, ')
          ..write('updated_at: $updated_at')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(creator_user_id, father_note_groups_id, title,
      created_at, id, updated_at);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is NoteGroup &&
          other.creator_user_id == this.creator_user_id &&
          other.father_note_groups_id == this.father_note_groups_id &&
          other.title == this.title &&
          other.created_at == this.created_at &&
          other.id == this.id &&
          other.updated_at == this.updated_at);
}

class NoteGroupsCompanion extends UpdateCompanion<NoteGroup> {
  Value<int> creator_user_id;
  Value<String?> father_note_groups_id;
  Value<String> title;
  Value<DateTime> created_at;
  Value<String> id;
  Value<DateTime> updated_at;
  NoteGroupsCompanion({
    this.creator_user_id = const Value.absent(),
    this.father_note_groups_id = const Value.absent(),
    this.title = const Value.absent(),
    this.created_at = const Value.absent(),
    this.id = const Value.absent(),
    this.updated_at = const Value.absent(),
  });
  NoteGroupsCompanion.insert({
    required int creator_user_id,
    this.father_note_groups_id = const Value.absent(),
    required String title,
    required DateTime created_at,
    required String id,
    required DateTime updated_at,
  })  : creator_user_id = Value(creator_user_id),
        title = Value(title),
        created_at = Value(created_at),
        id = Value(id),
        updated_at = Value(updated_at);
  static Insertable<NoteGroup> custom({
    Expression<int>? creator_user_id,
    Expression<String>? father_note_groups_id,
    Expression<String>? title,
    Expression<DateTime>? created_at,
    Expression<String>? id,
    Expression<DateTime>? updated_at,
  }) {
    return RawValuesInsertable({
      if (creator_user_id != null) 'creator_user_id': creator_user_id,
      if (father_note_groups_id != null)
        'father_note_groups_id': father_note_groups_id,
      if (title != null) 'title': title,
      if (created_at != null) 'created_at': created_at,
      if (id != null) 'id': id,
      if (updated_at != null) 'updated_at': updated_at,
    });
  }

  NoteGroupsCompanion copyWith(
      {Value<int>? creator_user_id,
      Value<String?>? father_note_groups_id,
      Value<String>? title,
      Value<DateTime>? created_at,
      Value<String>? id,
      Value<DateTime>? updated_at}) {
    return NoteGroupsCompanion(
      creator_user_id: creator_user_id ?? this.creator_user_id,
      father_note_groups_id:
          father_note_groups_id ?? this.father_note_groups_id,
      title: title ?? this.title,
      created_at: created_at ?? this.created_at,
      id: id ?? this.id,
      updated_at: updated_at ?? this.updated_at,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (creator_user_id.present) {
      map['creator_user_id'] = Variable<int>(creator_user_id.value);
    }
    if (father_note_groups_id.present) {
      map['father_note_groups_id'] =
          Variable<String>(father_note_groups_id.value);
    }
    if (title.present) {
      map['title'] = Variable<String>(title.value);
    }
    if (created_at.present) {
      map['created_at'] = Variable<DateTime>(created_at.value);
    }
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (updated_at.present) {
      map['updated_at'] = Variable<DateTime>(updated_at.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('NoteGroupsCompanion(')
          ..write('creator_user_id: $creator_user_id, ')
          ..write('father_note_groups_id: $father_note_groups_id, ')
          ..write('title: $title, ')
          ..write('created_at: $created_at, ')
          ..write('id: $id, ')
          ..write('updated_at: $updated_at')
          ..write(')'))
        .toString();
  }
}

class $NoteGroupsTable extends NoteGroups
    with TableInfo<$NoteGroupsTable, NoteGroup> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $NoteGroupsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _creator_user_idMeta =
      const VerificationMeta('creator_user_id');
  @override
  late final GeneratedColumn<int> creator_user_id = GeneratedColumn<int>(
      'creator_user_id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _father_note_groups_idMeta =
      const VerificationMeta('father_note_groups_id');
  @override
  late final GeneratedColumn<String> father_note_groups_id =
      GeneratedColumn<String>('father_note_groups_id', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _titleMeta = const VerificationMeta('title');
  @override
  late final GeneratedColumn<String> title = GeneratedColumn<String>(
      'title', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _created_atMeta =
      const VerificationMeta('created_at');
  @override
  late final GeneratedColumn<DateTime> created_at = GeneratedColumn<DateTime>(
      'created_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _updated_atMeta =
      const VerificationMeta('updated_at');
  @override
  late final GeneratedColumn<DateTime> updated_at = GeneratedColumn<DateTime>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns => [
        creator_user_id,
        father_note_groups_id,
        title,
        created_at,
        id,
        updated_at
      ];
  @override
  String get aliasedName => _alias ?? 'note_groups';
  @override
  String get actualTableName => 'note_groups';
  @override
  VerificationContext validateIntegrity(Insertable<NoteGroup> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('creator_user_id')) {
      context.handle(
          _creator_user_idMeta,
          creator_user_id.isAcceptableOrUnknown(
              data['creator_user_id']!, _creator_user_idMeta));
    } else if (isInserting) {
      context.missing(_creator_user_idMeta);
    }
    if (data.containsKey('father_note_groups_id')) {
      context.handle(
          _father_note_groups_idMeta,
          father_note_groups_id.isAcceptableOrUnknown(
              data['father_note_groups_id']!, _father_note_groups_idMeta));
    }
    if (data.containsKey('title')) {
      context.handle(
          _titleMeta, title.isAcceptableOrUnknown(data['title']!, _titleMeta));
    } else if (isInserting) {
      context.missing(_titleMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(
          _created_atMeta,
          created_at.isAcceptableOrUnknown(
              data['created_at']!, _created_atMeta));
    } else if (isInserting) {
      context.missing(_created_atMeta);
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
          _updated_atMeta,
          updated_at.isAcceptableOrUnknown(
              data['updated_at']!, _updated_atMeta));
    } else if (isInserting) {
      context.missing(_updated_atMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  NoteGroup map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return NoteGroup(
      creator_user_id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}creator_user_id'])!,
      father_note_groups_id: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}father_note_groups_id']),
      title: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}title'])!,
      created_at: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_at'])!,
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id'])!,
      updated_at: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}updated_at'])!,
    );
  }

  @override
  $NoteGroupsTable createAlias(String alias) {
    return $NoteGroupsTable(attachedDatabase, alias);
  }
}

abstract class _$DriftDb extends GeneratedDatabase {
  _$DriftDb(QueryExecutor e) : super(e);
  late final $UsersTable users = $UsersTable(this);
  late final $ClientSyncInfosTable clientSyncInfos =
      $ClientSyncInfosTable(this);
  late final $SyncsTable syncs = $SyncsTable(this);
  late final $FragmentMemoryInfosTable fragmentMemoryInfos =
      $FragmentMemoryInfosTable(this);
  late final $RDocument2DocumentGroupsTable rDocument2DocumentGroups =
      $RDocument2DocumentGroupsTable(this);
  late final $RFragment2FragmentGroupsTable rFragment2FragmentGroups =
      $RFragment2FragmentGroupsTable(this);
  late final $RNote2NoteGroupsTable rNote2NoteGroups =
      $RNote2NoteGroupsTable(this);
  late final $Test2sTable test2s = $Test2sTable(this);
  late final $TestsTable tests = $TestsTable(this);
  late final $DocumentsTable documents = $DocumentsTable(this);
  late final $FragmentTemplatesTable fragmentTemplates =
      $FragmentTemplatesTable(this);
  late final $FragmentsTable fragments = $FragmentsTable(this);
  late final $MemoryGroupsTable memoryGroups = $MemoryGroupsTable(this);
  late final $MemoryModelsTable memoryModels = $MemoryModelsTable(this);
  late final $NotesTable notes = $NotesTable(this);
  late final $DocumentGroupsTable documentGroups = $DocumentGroupsTable(this);
  late final $FragmentGroupsTable fragmentGroups = $FragmentGroupsTable(this);
  late final $NoteGroupsTable noteGroups = $NoteGroupsTable(this);
  late final InsertDAO insertDAO = InsertDAO(this as DriftDb);
  late final RawDAO rawDAO = RawDAO(this as DriftDb);
  late final RegisterOrLoginDAO registerOrLoginDAO =
      RegisterOrLoginDAO(this as DriftDb);
  late final UpdateDAO updateDAO = UpdateDAO(this as DriftDb);
  late final DeleteDAO deleteDAO = DeleteDAO(this as DriftDb);
  late final GeneralQueryDAO generalQueryDAO = GeneralQueryDAO(this as DriftDb);
  @override
  Iterable<TableInfo<Table, Object?>> get allTables =>
      allSchemaEntities.whereType<TableInfo<Table, Object?>>();
  @override
  List<DatabaseSchemaEntity> get allSchemaEntities => [
        users,
        clientSyncInfos,
        syncs,
        fragmentMemoryInfos,
        rDocument2DocumentGroups,
        rFragment2FragmentGroups,
        rNote2NoteGroups,
        test2s,
        tests,
        documents,
        fragmentTemplates,
        fragments,
        memoryGroups,
        memoryModels,
        notes,
        documentGroups,
        fragmentGroups,
        noteGroups
      ];
}

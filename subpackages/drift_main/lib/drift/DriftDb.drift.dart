// ignore_for_file: type=lint
part of 'DriftDb.dart';

mixin _$GeneralQueryDAOMixin on DatabaseAccessor<DriftDb> {
  $ClientSyncInfosTable get clientSyncInfos => attachedDatabase.clientSyncInfos;
  $SyncsTable get syncs => attachedDatabase.syncs;
  $FragmentMemoryInfosTable get fragmentMemoryInfos =>
      attachedDatabase.fragmentMemoryInfos;
  $FragmentGroupTagsTable get fragmentGroupTags =>
      attachedDatabase.fragmentGroupTags;
  $RFragment2FragmentGroupsTable get rFragment2FragmentGroups =>
      attachedDatabase.rFragment2FragmentGroups;
  $Test2sTable get test2s => attachedDatabase.test2s;
  $TestsTable get tests => attachedDatabase.tests;
  $FragmentsTable get fragments => attachedDatabase.fragments;
  $MemoryGroupsTable get memoryGroups => attachedDatabase.memoryGroups;
  $MemoryModelsTable get memoryModels => attachedDatabase.memoryModels;
  $ShorthandsTable get shorthands => attachedDatabase.shorthands;
  $FragmentGroupsTable get fragmentGroups => attachedDatabase.fragmentGroups;
  $UserCommentsTable get userComments => attachedDatabase.userComments;
  $UserLikesTable get userLikes => attachedDatabase.userLikes;
  $UsersTable get users => attachedDatabase.users;
}
mixin _$InsertDAOMixin on DatabaseAccessor<DriftDb> {
  $ClientSyncInfosTable get clientSyncInfos => attachedDatabase.clientSyncInfos;
  $SyncsTable get syncs => attachedDatabase.syncs;
  $FragmentMemoryInfosTable get fragmentMemoryInfos =>
      attachedDatabase.fragmentMemoryInfos;
  $FragmentGroupTagsTable get fragmentGroupTags =>
      attachedDatabase.fragmentGroupTags;
  $RFragment2FragmentGroupsTable get rFragment2FragmentGroups =>
      attachedDatabase.rFragment2FragmentGroups;
  $Test2sTable get test2s => attachedDatabase.test2s;
  $TestsTable get tests => attachedDatabase.tests;
  $FragmentsTable get fragments => attachedDatabase.fragments;
  $MemoryGroupsTable get memoryGroups => attachedDatabase.memoryGroups;
  $MemoryModelsTable get memoryModels => attachedDatabase.memoryModels;
  $ShorthandsTable get shorthands => attachedDatabase.shorthands;
  $FragmentGroupsTable get fragmentGroups => attachedDatabase.fragmentGroups;
  $UserCommentsTable get userComments => attachedDatabase.userComments;
  $UserLikesTable get userLikes => attachedDatabase.userLikes;
  $UsersTable get users => attachedDatabase.users;
}
mixin _$RawDAOMixin on DatabaseAccessor<DriftDb> {
  $ClientSyncInfosTable get clientSyncInfos => attachedDatabase.clientSyncInfos;
  $SyncsTable get syncs => attachedDatabase.syncs;
  $FragmentMemoryInfosTable get fragmentMemoryInfos =>
      attachedDatabase.fragmentMemoryInfos;
  $FragmentGroupTagsTable get fragmentGroupTags =>
      attachedDatabase.fragmentGroupTags;
  $RFragment2FragmentGroupsTable get rFragment2FragmentGroups =>
      attachedDatabase.rFragment2FragmentGroups;
  $Test2sTable get test2s => attachedDatabase.test2s;
  $TestsTable get tests => attachedDatabase.tests;
  $FragmentsTable get fragments => attachedDatabase.fragments;
  $MemoryGroupsTable get memoryGroups => attachedDatabase.memoryGroups;
  $MemoryModelsTable get memoryModels => attachedDatabase.memoryModels;
  $ShorthandsTable get shorthands => attachedDatabase.shorthands;
  $FragmentGroupsTable get fragmentGroups => attachedDatabase.fragmentGroups;
  $UserCommentsTable get userComments => attachedDatabase.userComments;
  $UserLikesTable get userLikes => attachedDatabase.userLikes;
  $UsersTable get users => attachedDatabase.users;
}
mixin _$RegisterOrLoginDAOMixin on DatabaseAccessor<DriftDb> {
  $ClientSyncInfosTable get clientSyncInfos => attachedDatabase.clientSyncInfos;
  $SyncsTable get syncs => attachedDatabase.syncs;
  $FragmentMemoryInfosTable get fragmentMemoryInfos =>
      attachedDatabase.fragmentMemoryInfos;
  $FragmentGroupTagsTable get fragmentGroupTags =>
      attachedDatabase.fragmentGroupTags;
  $RFragment2FragmentGroupsTable get rFragment2FragmentGroups =>
      attachedDatabase.rFragment2FragmentGroups;
  $Test2sTable get test2s => attachedDatabase.test2s;
  $TestsTable get tests => attachedDatabase.tests;
  $FragmentsTable get fragments => attachedDatabase.fragments;
  $MemoryGroupsTable get memoryGroups => attachedDatabase.memoryGroups;
  $MemoryModelsTable get memoryModels => attachedDatabase.memoryModels;
  $ShorthandsTable get shorthands => attachedDatabase.shorthands;
  $FragmentGroupsTable get fragmentGroups => attachedDatabase.fragmentGroups;
  $UserCommentsTable get userComments => attachedDatabase.userComments;
  $UserLikesTable get userLikes => attachedDatabase.userLikes;
  $UsersTable get users => attachedDatabase.users;
}
mixin _$UpdateDAOMixin on DatabaseAccessor<DriftDb> {
  $ClientSyncInfosTable get clientSyncInfos => attachedDatabase.clientSyncInfos;
  $SyncsTable get syncs => attachedDatabase.syncs;
  $FragmentMemoryInfosTable get fragmentMemoryInfos =>
      attachedDatabase.fragmentMemoryInfos;
  $FragmentGroupTagsTable get fragmentGroupTags =>
      attachedDatabase.fragmentGroupTags;
  $RFragment2FragmentGroupsTable get rFragment2FragmentGroups =>
      attachedDatabase.rFragment2FragmentGroups;
  $Test2sTable get test2s => attachedDatabase.test2s;
  $TestsTable get tests => attachedDatabase.tests;
  $FragmentsTable get fragments => attachedDatabase.fragments;
  $MemoryGroupsTable get memoryGroups => attachedDatabase.memoryGroups;
  $MemoryModelsTable get memoryModels => attachedDatabase.memoryModels;
  $ShorthandsTable get shorthands => attachedDatabase.shorthands;
  $FragmentGroupsTable get fragmentGroups => attachedDatabase.fragmentGroups;
  $UserCommentsTable get userComments => attachedDatabase.userComments;
  $UserLikesTable get userLikes => attachedDatabase.userLikes;
  $UsersTable get users => attachedDatabase.users;
}
mixin _$DeleteDAOMixin on DatabaseAccessor<DriftDb> {
  $ClientSyncInfosTable get clientSyncInfos => attachedDatabase.clientSyncInfos;
  $SyncsTable get syncs => attachedDatabase.syncs;
  $FragmentMemoryInfosTable get fragmentMemoryInfos =>
      attachedDatabase.fragmentMemoryInfos;
  $FragmentGroupTagsTable get fragmentGroupTags =>
      attachedDatabase.fragmentGroupTags;
  $RFragment2FragmentGroupsTable get rFragment2FragmentGroups =>
      attachedDatabase.rFragment2FragmentGroups;
  $Test2sTable get test2s => attachedDatabase.test2s;
  $TestsTable get tests => attachedDatabase.tests;
  $FragmentsTable get fragments => attachedDatabase.fragments;
  $MemoryGroupsTable get memoryGroups => attachedDatabase.memoryGroups;
  $MemoryModelsTable get memoryModels => attachedDatabase.memoryModels;
  $ShorthandsTable get shorthands => attachedDatabase.shorthands;
  $FragmentGroupsTable get fragmentGroups => attachedDatabase.fragmentGroups;
  $UserCommentsTable get userComments => attachedDatabase.userComments;
  $UserLikesTable get userLikes => attachedDatabase.userLikes;
  $UsersTable get users => attachedDatabase.users;
}

class $ClientSyncInfosTable extends ClientSyncInfos
    with TableInfo<$ClientSyncInfosTable, ClientSyncInfo> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ClientSyncInfosTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _device_infoMeta =
      const VerificationMeta('device_info');
  @override
  late final GeneratedColumn<String> device_info = GeneratedColumn<String>(
      'device_info', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _recent_sync_timeMeta =
      const VerificationMeta('recent_sync_time');
  @override
  late final GeneratedColumn<DateTime> recent_sync_time =
      GeneratedColumn<DateTime>('recent_sync_time', aliasedName, true,
          type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _tokenMeta = const VerificationMeta('token');
  @override
  late final GeneratedColumn<String> token = GeneratedColumn<String>(
      'token', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _created_atMeta =
      const VerificationMeta('created_at');
  @override
  late final GeneratedColumn<DateTime> created_at = GeneratedColumn<DateTime>(
      'created_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _updated_atMeta =
      const VerificationMeta('updated_at');
  @override
  late final GeneratedColumn<DateTime> updated_at = GeneratedColumn<DateTime>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns =>
      [device_info, recent_sync_time, token, created_at, id, updated_at];
  @override
  String get aliasedName => _alias ?? 'client_sync_infos';
  @override
  String get actualTableName => 'client_sync_infos';
  @override
  VerificationContext validateIntegrity(Insertable<ClientSyncInfo> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('device_info')) {
      context.handle(
          _device_infoMeta,
          device_info.isAcceptableOrUnknown(
              data['device_info']!, _device_infoMeta));
    } else if (isInserting) {
      context.missing(_device_infoMeta);
    }
    if (data.containsKey('recent_sync_time')) {
      context.handle(
          _recent_sync_timeMeta,
          recent_sync_time.isAcceptableOrUnknown(
              data['recent_sync_time']!, _recent_sync_timeMeta));
    }
    if (data.containsKey('token')) {
      context.handle(
          _tokenMeta, token.isAcceptableOrUnknown(data['token']!, _tokenMeta));
    }
    if (data.containsKey('created_at')) {
      context.handle(
          _created_atMeta,
          created_at.isAcceptableOrUnknown(
              data['created_at']!, _created_atMeta));
    } else if (isInserting) {
      context.missing(_created_atMeta);
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('updated_at')) {
      context.handle(
          _updated_atMeta,
          updated_at.isAcceptableOrUnknown(
              data['updated_at']!, _updated_atMeta));
    } else if (isInserting) {
      context.missing(_updated_atMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  ClientSyncInfo map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ClientSyncInfo(
      device_info: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}device_info'])!,
      recent_sync_time: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}recent_sync_time']),
      token: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}token']),
      created_at: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_at'])!,
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      updated_at: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}updated_at'])!,
    );
  }

  @override
  $ClientSyncInfosTable createAlias(String alias) {
    return $ClientSyncInfosTable(attachedDatabase, alias);
  }
}

class ClientSyncInfo extends DataClass implements Insertable<ClientSyncInfo> {
  String device_info;
  DateTime? recent_sync_time;
  String? token;
  DateTime created_at;
  int id;
  DateTime updated_at;
  ClientSyncInfo(
      {required this.device_info,
      this.recent_sync_time,
      this.token,
      required this.created_at,
      required this.id,
      required this.updated_at});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['device_info'] = Variable<String>(device_info);
    if (!nullToAbsent || recent_sync_time != null) {
      map['recent_sync_time'] = Variable<DateTime>(recent_sync_time);
    }
    if (!nullToAbsent || token != null) {
      map['token'] = Variable<String>(token);
    }
    map['created_at'] = Variable<DateTime>(created_at);
    map['id'] = Variable<int>(id);
    map['updated_at'] = Variable<DateTime>(updated_at);
    return map;
  }

  ClientSyncInfosCompanion toCompanion(bool nullToAbsent) {
    return ClientSyncInfosCompanion(
      device_info: Value(device_info),
      recent_sync_time: recent_sync_time == null && nullToAbsent
          ? const Value.absent()
          : Value(recent_sync_time),
      token:
          token == null && nullToAbsent ? const Value.absent() : Value(token),
      created_at: Value(created_at),
      id: Value(id),
      updated_at: Value(updated_at),
    );
  }

  factory ClientSyncInfo.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ClientSyncInfo(
      device_info: serializer.fromJson<String>(json['device_info']),
      recent_sync_time:
          serializer.fromJson<DateTime?>(json['recent_sync_time']),
      token: serializer.fromJson<String?>(json['token']),
      created_at: serializer.fromJson<DateTime>(json['created_at']),
      id: serializer.fromJson<int>(json['id']),
      updated_at: serializer.fromJson<DateTime>(json['updated_at']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'device_info': serializer.toJson<String>(device_info),
      'recent_sync_time': serializer.toJson<DateTime?>(recent_sync_time),
      'token': serializer.toJson<String?>(token),
      'created_at': serializer.toJson<DateTime>(created_at),
      'id': serializer.toJson<int>(id),
      'updated_at': serializer.toJson<DateTime>(updated_at),
    };
  }

  ClientSyncInfo copyWith(
          {String? device_info,
          Value<DateTime?> recent_sync_time = const Value.absent(),
          Value<String?> token = const Value.absent(),
          DateTime? created_at,
          int? id,
          DateTime? updated_at}) =>
      ClientSyncInfo(
        device_info: device_info ?? this.device_info,
        recent_sync_time: recent_sync_time.present
            ? recent_sync_time.value
            : this.recent_sync_time,
        token: token.present ? token.value : this.token,
        created_at: created_at ?? this.created_at,
        id: id ?? this.id,
        updated_at: updated_at ?? this.updated_at,
      );
  @override
  String toString() {
    return (StringBuffer('ClientSyncInfo(')
          ..write('device_info: $device_info, ')
          ..write('recent_sync_time: $recent_sync_time, ')
          ..write('token: $token, ')
          ..write('created_at: $created_at, ')
          ..write('id: $id, ')
          ..write('updated_at: $updated_at')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      device_info, recent_sync_time, token, created_at, id, updated_at);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ClientSyncInfo &&
          other.device_info == this.device_info &&
          other.recent_sync_time == this.recent_sync_time &&
          other.token == this.token &&
          other.created_at == this.created_at &&
          other.id == this.id &&
          other.updated_at == this.updated_at);
}

class ClientSyncInfosCompanion extends UpdateCompanion<ClientSyncInfo> {
  Value<String> device_info;
  Value<DateTime?> recent_sync_time;
  Value<String?> token;
  Value<DateTime> created_at;
  Value<int> id;
  Value<DateTime> updated_at;
  ClientSyncInfosCompanion({
    this.device_info = const Value.absent(),
    this.recent_sync_time = const Value.absent(),
    this.token = const Value.absent(),
    this.created_at = const Value.absent(),
    this.id = const Value.absent(),
    this.updated_at = const Value.absent(),
  });
  ClientSyncInfosCompanion.insert({
    required String device_info,
    this.recent_sync_time = const Value.absent(),
    this.token = const Value.absent(),
    required DateTime created_at,
    this.id = const Value.absent(),
    required DateTime updated_at,
  })  : device_info = Value(device_info),
        created_at = Value(created_at),
        updated_at = Value(updated_at);
  static Insertable<ClientSyncInfo> custom({
    Expression<String>? device_info,
    Expression<DateTime>? recent_sync_time,
    Expression<String>? token,
    Expression<DateTime>? created_at,
    Expression<int>? id,
    Expression<DateTime>? updated_at,
  }) {
    return RawValuesInsertable({
      if (device_info != null) 'device_info': device_info,
      if (recent_sync_time != null) 'recent_sync_time': recent_sync_time,
      if (token != null) 'token': token,
      if (created_at != null) 'created_at': created_at,
      if (id != null) 'id': id,
      if (updated_at != null) 'updated_at': updated_at,
    });
  }

  ClientSyncInfosCompanion copyWith(
      {Value<String>? device_info,
      Value<DateTime?>? recent_sync_time,
      Value<String?>? token,
      Value<DateTime>? created_at,
      Value<int>? id,
      Value<DateTime>? updated_at}) {
    return ClientSyncInfosCompanion(
      device_info: device_info ?? this.device_info,
      recent_sync_time: recent_sync_time ?? this.recent_sync_time,
      token: token ?? this.token,
      created_at: created_at ?? this.created_at,
      id: id ?? this.id,
      updated_at: updated_at ?? this.updated_at,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (device_info.present) {
      map['device_info'] = Variable<String>(device_info.value);
    }
    if (recent_sync_time.present) {
      map['recent_sync_time'] = Variable<DateTime>(recent_sync_time.value);
    }
    if (token.present) {
      map['token'] = Variable<String>(token.value);
    }
    if (created_at.present) {
      map['created_at'] = Variable<DateTime>(created_at.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (updated_at.present) {
      map['updated_at'] = Variable<DateTime>(updated_at.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ClientSyncInfosCompanion(')
          ..write('device_info: $device_info, ')
          ..write('recent_sync_time: $recent_sync_time, ')
          ..write('token: $token, ')
          ..write('created_at: $created_at, ')
          ..write('id: $id, ')
          ..write('updated_at: $updated_at')
          ..write(')'))
        .toString();
  }
}

class $SyncsTable extends Syncs with TableInfo<$SyncsTable, Sync> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SyncsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _row_idMeta = const VerificationMeta('row_id');
  @override
  late final GeneratedColumn<String> row_id = GeneratedColumn<String>(
      'row_id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _sync_curd_typeMeta =
      const VerificationMeta('sync_curd_type');
  @override
  late final GeneratedColumnWithTypeConverter<SyncCurdType, int>
      sync_curd_type = GeneratedColumn<int>(
              'sync_curd_type', aliasedName, false,
              type: DriftSqlType.int, requiredDuringInsert: true)
          .withConverter<SyncCurdType>($SyncsTable.$convertersync_curd_type);
  static const VerificationMeta _sync_table_nameMeta =
      const VerificationMeta('sync_table_name');
  @override
  late final GeneratedColumn<String> sync_table_name = GeneratedColumn<String>(
      'sync_table_name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _tagMeta = const VerificationMeta('tag');
  @override
  late final GeneratedColumn<int> tag = GeneratedColumn<int>(
      'tag', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _created_atMeta =
      const VerificationMeta('created_at');
  @override
  late final GeneratedColumn<DateTime> created_at = GeneratedColumn<DateTime>(
      'created_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _updated_atMeta =
      const VerificationMeta('updated_at');
  @override
  late final GeneratedColumn<DateTime> updated_at = GeneratedColumn<DateTime>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns => [
        row_id,
        sync_curd_type,
        sync_table_name,
        tag,
        created_at,
        id,
        updated_at
      ];
  @override
  String get aliasedName => _alias ?? 'syncs';
  @override
  String get actualTableName => 'syncs';
  @override
  VerificationContext validateIntegrity(Insertable<Sync> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('row_id')) {
      context.handle(_row_idMeta,
          row_id.isAcceptableOrUnknown(data['row_id']!, _row_idMeta));
    } else if (isInserting) {
      context.missing(_row_idMeta);
    }
    context.handle(_sync_curd_typeMeta, const VerificationResult.success());
    if (data.containsKey('sync_table_name')) {
      context.handle(
          _sync_table_nameMeta,
          sync_table_name.isAcceptableOrUnknown(
              data['sync_table_name']!, _sync_table_nameMeta));
    } else if (isInserting) {
      context.missing(_sync_table_nameMeta);
    }
    if (data.containsKey('tag')) {
      context.handle(
          _tagMeta, tag.isAcceptableOrUnknown(data['tag']!, _tagMeta));
    } else if (isInserting) {
      context.missing(_tagMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(
          _created_atMeta,
          created_at.isAcceptableOrUnknown(
              data['created_at']!, _created_atMeta));
    } else if (isInserting) {
      context.missing(_created_atMeta);
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('updated_at')) {
      context.handle(
          _updated_atMeta,
          updated_at.isAcceptableOrUnknown(
              data['updated_at']!, _updated_atMeta));
    } else if (isInserting) {
      context.missing(_updated_atMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Sync map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Sync(
      row_id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}row_id'])!,
      sync_curd_type: $SyncsTable.$convertersync_curd_type.fromSql(
          attachedDatabase.typeMapping.read(
              DriftSqlType.int, data['${effectivePrefix}sync_curd_type'])!),
      sync_table_name: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}sync_table_name'])!,
      tag: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}tag'])!,
      created_at: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_at'])!,
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      updated_at: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}updated_at'])!,
    );
  }

  @override
  $SyncsTable createAlias(String alias) {
    return $SyncsTable(attachedDatabase, alias);
  }

  static JsonTypeConverter2<SyncCurdType, int, int> $convertersync_curd_type =
      const EnumIndexConverter<SyncCurdType>(SyncCurdType.values);
}

class Sync extends DataClass implements Insertable<Sync> {
  String row_id;
  SyncCurdType sync_curd_type;
  String sync_table_name;
  int tag;
  DateTime created_at;
  int id;
  DateTime updated_at;
  Sync(
      {required this.row_id,
      required this.sync_curd_type,
      required this.sync_table_name,
      required this.tag,
      required this.created_at,
      required this.id,
      required this.updated_at});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['row_id'] = Variable<String>(row_id);
    {
      final converter = $SyncsTable.$convertersync_curd_type;
      map['sync_curd_type'] = Variable<int>(converter.toSql(sync_curd_type));
    }
    map['sync_table_name'] = Variable<String>(sync_table_name);
    map['tag'] = Variable<int>(tag);
    map['created_at'] = Variable<DateTime>(created_at);
    map['id'] = Variable<int>(id);
    map['updated_at'] = Variable<DateTime>(updated_at);
    return map;
  }

  SyncsCompanion toCompanion(bool nullToAbsent) {
    return SyncsCompanion(
      row_id: Value(row_id),
      sync_curd_type: Value(sync_curd_type),
      sync_table_name: Value(sync_table_name),
      tag: Value(tag),
      created_at: Value(created_at),
      id: Value(id),
      updated_at: Value(updated_at),
    );
  }

  factory Sync.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Sync(
      row_id: serializer.fromJson<String>(json['row_id']),
      sync_curd_type: $SyncsTable.$convertersync_curd_type
          .fromJson(serializer.fromJson<int>(json['sync_curd_type'])),
      sync_table_name: serializer.fromJson<String>(json['sync_table_name']),
      tag: serializer.fromJson<int>(json['tag']),
      created_at: serializer.fromJson<DateTime>(json['created_at']),
      id: serializer.fromJson<int>(json['id']),
      updated_at: serializer.fromJson<DateTime>(json['updated_at']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'row_id': serializer.toJson<String>(row_id),
      'sync_curd_type': serializer.toJson<int>(
          $SyncsTable.$convertersync_curd_type.toJson(sync_curd_type)),
      'sync_table_name': serializer.toJson<String>(sync_table_name),
      'tag': serializer.toJson<int>(tag),
      'created_at': serializer.toJson<DateTime>(created_at),
      'id': serializer.toJson<int>(id),
      'updated_at': serializer.toJson<DateTime>(updated_at),
    };
  }

  Sync copyWith(
          {String? row_id,
          SyncCurdType? sync_curd_type,
          String? sync_table_name,
          int? tag,
          DateTime? created_at,
          int? id,
          DateTime? updated_at}) =>
      Sync(
        row_id: row_id ?? this.row_id,
        sync_curd_type: sync_curd_type ?? this.sync_curd_type,
        sync_table_name: sync_table_name ?? this.sync_table_name,
        tag: tag ?? this.tag,
        created_at: created_at ?? this.created_at,
        id: id ?? this.id,
        updated_at: updated_at ?? this.updated_at,
      );
  @override
  String toString() {
    return (StringBuffer('Sync(')
          ..write('row_id: $row_id, ')
          ..write('sync_curd_type: $sync_curd_type, ')
          ..write('sync_table_name: $sync_table_name, ')
          ..write('tag: $tag, ')
          ..write('created_at: $created_at, ')
          ..write('id: $id, ')
          ..write('updated_at: $updated_at')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      row_id, sync_curd_type, sync_table_name, tag, created_at, id, updated_at);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Sync &&
          other.row_id == this.row_id &&
          other.sync_curd_type == this.sync_curd_type &&
          other.sync_table_name == this.sync_table_name &&
          other.tag == this.tag &&
          other.created_at == this.created_at &&
          other.id == this.id &&
          other.updated_at == this.updated_at);
}

class SyncsCompanion extends UpdateCompanion<Sync> {
  Value<String> row_id;
  Value<SyncCurdType> sync_curd_type;
  Value<String> sync_table_name;
  Value<int> tag;
  Value<DateTime> created_at;
  Value<int> id;
  Value<DateTime> updated_at;
  SyncsCompanion({
    this.row_id = const Value.absent(),
    this.sync_curd_type = const Value.absent(),
    this.sync_table_name = const Value.absent(),
    this.tag = const Value.absent(),
    this.created_at = const Value.absent(),
    this.id = const Value.absent(),
    this.updated_at = const Value.absent(),
  });
  SyncsCompanion.insert({
    required String row_id,
    required SyncCurdType sync_curd_type,
    required String sync_table_name,
    required int tag,
    required DateTime created_at,
    this.id = const Value.absent(),
    required DateTime updated_at,
  })  : row_id = Value(row_id),
        sync_curd_type = Value(sync_curd_type),
        sync_table_name = Value(sync_table_name),
        tag = Value(tag),
        created_at = Value(created_at),
        updated_at = Value(updated_at);
  static Insertable<Sync> custom({
    Expression<String>? row_id,
    Expression<int>? sync_curd_type,
    Expression<String>? sync_table_name,
    Expression<int>? tag,
    Expression<DateTime>? created_at,
    Expression<int>? id,
    Expression<DateTime>? updated_at,
  }) {
    return RawValuesInsertable({
      if (row_id != null) 'row_id': row_id,
      if (sync_curd_type != null) 'sync_curd_type': sync_curd_type,
      if (sync_table_name != null) 'sync_table_name': sync_table_name,
      if (tag != null) 'tag': tag,
      if (created_at != null) 'created_at': created_at,
      if (id != null) 'id': id,
      if (updated_at != null) 'updated_at': updated_at,
    });
  }

  SyncsCompanion copyWith(
      {Value<String>? row_id,
      Value<SyncCurdType>? sync_curd_type,
      Value<String>? sync_table_name,
      Value<int>? tag,
      Value<DateTime>? created_at,
      Value<int>? id,
      Value<DateTime>? updated_at}) {
    return SyncsCompanion(
      row_id: row_id ?? this.row_id,
      sync_curd_type: sync_curd_type ?? this.sync_curd_type,
      sync_table_name: sync_table_name ?? this.sync_table_name,
      tag: tag ?? this.tag,
      created_at: created_at ?? this.created_at,
      id: id ?? this.id,
      updated_at: updated_at ?? this.updated_at,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (row_id.present) {
      map['row_id'] = Variable<String>(row_id.value);
    }
    if (sync_curd_type.present) {
      final converter = $SyncsTable.$convertersync_curd_type;
      map['sync_curd_type'] =
          Variable<int>(converter.toSql(sync_curd_type.value));
    }
    if (sync_table_name.present) {
      map['sync_table_name'] = Variable<String>(sync_table_name.value);
    }
    if (tag.present) {
      map['tag'] = Variable<int>(tag.value);
    }
    if (created_at.present) {
      map['created_at'] = Variable<DateTime>(created_at.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (updated_at.present) {
      map['updated_at'] = Variable<DateTime>(updated_at.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SyncsCompanion(')
          ..write('row_id: $row_id, ')
          ..write('sync_curd_type: $sync_curd_type, ')
          ..write('sync_table_name: $sync_table_name, ')
          ..write('tag: $tag, ')
          ..write('created_at: $created_at, ')
          ..write('id: $id, ')
          ..write('updated_at: $updated_at')
          ..write(')'))
        .toString();
  }
}

class $FragmentMemoryInfosTable extends FragmentMemoryInfos
    with TableInfo<$FragmentMemoryInfosTable, FragmentMemoryInfo> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $FragmentMemoryInfosTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _actual_show_timeMeta =
      const VerificationMeta('actual_show_time');
  @override
  late final GeneratedColumn<String> actual_show_time = GeneratedColumn<String>(
      'actual_show_time', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _button_valuesMeta =
      const VerificationMeta('button_values');
  @override
  late final GeneratedColumn<String> button_values = GeneratedColumn<String>(
      'button_values', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _click_familiarityMeta =
      const VerificationMeta('click_familiarity');
  @override
  late final GeneratedColumn<String> click_familiarity =
      GeneratedColumn<String>('click_familiarity', aliasedName, false,
          type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _click_timeMeta =
      const VerificationMeta('click_time');
  @override
  late final GeneratedColumn<String> click_time = GeneratedColumn<String>(
      'click_time', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _click_valueMeta =
      const VerificationMeta('click_value');
  @override
  late final GeneratedColumn<String> click_value = GeneratedColumn<String>(
      'click_value', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _content_valueMeta =
      const VerificationMeta('content_value');
  @override
  late final GeneratedColumn<String> content_value = GeneratedColumn<String>(
      'content_value', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _creator_user_idMeta =
      const VerificationMeta('creator_user_id');
  @override
  late final GeneratedColumn<int> creator_user_id = GeneratedColumn<int>(
      'creator_user_id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _fragment_idMeta =
      const VerificationMeta('fragment_id');
  @override
  late final GeneratedColumn<String> fragment_id = GeneratedColumn<String>(
      'fragment_id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _memory_group_idMeta =
      const VerificationMeta('memory_group_id');
  @override
  late final GeneratedColumn<String> memory_group_id = GeneratedColumn<String>(
      'memory_group_id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _next_plan_show_timeMeta =
      const VerificationMeta('next_plan_show_time');
  @override
  late final GeneratedColumn<String> next_plan_show_time =
      GeneratedColumn<String>('next_plan_show_time', aliasedName, false,
          type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _show_familiarityMeta =
      const VerificationMeta('show_familiarity');
  @override
  late final GeneratedColumn<String> show_familiarity = GeneratedColumn<String>(
      'show_familiarity', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _study_statusMeta =
      const VerificationMeta('study_status');
  @override
  late final GeneratedColumnWithTypeConverter<StudyStatus, int> study_status =
      GeneratedColumn<int>('study_status', aliasedName, false,
              type: DriftSqlType.int, requiredDuringInsert: true)
          .withConverter<StudyStatus>(
              $FragmentMemoryInfosTable.$converterstudy_status);
  static const VerificationMeta _created_atMeta =
      const VerificationMeta('created_at');
  @override
  late final GeneratedColumn<DateTime> created_at = GeneratedColumn<DateTime>(
      'created_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _updated_atMeta =
      const VerificationMeta('updated_at');
  @override
  late final GeneratedColumn<DateTime> updated_at = GeneratedColumn<DateTime>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns => [
        actual_show_time,
        button_values,
        click_familiarity,
        click_time,
        click_value,
        content_value,
        creator_user_id,
        fragment_id,
        memory_group_id,
        next_plan_show_time,
        show_familiarity,
        study_status,
        created_at,
        id,
        updated_at
      ];
  @override
  String get aliasedName => _alias ?? 'fragment_memory_infos';
  @override
  String get actualTableName => 'fragment_memory_infos';
  @override
  VerificationContext validateIntegrity(Insertable<FragmentMemoryInfo> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('actual_show_time')) {
      context.handle(
          _actual_show_timeMeta,
          actual_show_time.isAcceptableOrUnknown(
              data['actual_show_time']!, _actual_show_timeMeta));
    } else if (isInserting) {
      context.missing(_actual_show_timeMeta);
    }
    if (data.containsKey('button_values')) {
      context.handle(
          _button_valuesMeta,
          button_values.isAcceptableOrUnknown(
              data['button_values']!, _button_valuesMeta));
    } else if (isInserting) {
      context.missing(_button_valuesMeta);
    }
    if (data.containsKey('click_familiarity')) {
      context.handle(
          _click_familiarityMeta,
          click_familiarity.isAcceptableOrUnknown(
              data['click_familiarity']!, _click_familiarityMeta));
    } else if (isInserting) {
      context.missing(_click_familiarityMeta);
    }
    if (data.containsKey('click_time')) {
      context.handle(
          _click_timeMeta,
          click_time.isAcceptableOrUnknown(
              data['click_time']!, _click_timeMeta));
    } else if (isInserting) {
      context.missing(_click_timeMeta);
    }
    if (data.containsKey('click_value')) {
      context.handle(
          _click_valueMeta,
          click_value.isAcceptableOrUnknown(
              data['click_value']!, _click_valueMeta));
    } else if (isInserting) {
      context.missing(_click_valueMeta);
    }
    if (data.containsKey('content_value')) {
      context.handle(
          _content_valueMeta,
          content_value.isAcceptableOrUnknown(
              data['content_value']!, _content_valueMeta));
    } else if (isInserting) {
      context.missing(_content_valueMeta);
    }
    if (data.containsKey('creator_user_id')) {
      context.handle(
          _creator_user_idMeta,
          creator_user_id.isAcceptableOrUnknown(
              data['creator_user_id']!, _creator_user_idMeta));
    } else if (isInserting) {
      context.missing(_creator_user_idMeta);
    }
    if (data.containsKey('fragment_id')) {
      context.handle(
          _fragment_idMeta,
          fragment_id.isAcceptableOrUnknown(
              data['fragment_id']!, _fragment_idMeta));
    } else if (isInserting) {
      context.missing(_fragment_idMeta);
    }
    if (data.containsKey('memory_group_id')) {
      context.handle(
          _memory_group_idMeta,
          memory_group_id.isAcceptableOrUnknown(
              data['memory_group_id']!, _memory_group_idMeta));
    } else if (isInserting) {
      context.missing(_memory_group_idMeta);
    }
    if (data.containsKey('next_plan_show_time')) {
      context.handle(
          _next_plan_show_timeMeta,
          next_plan_show_time.isAcceptableOrUnknown(
              data['next_plan_show_time']!, _next_plan_show_timeMeta));
    } else if (isInserting) {
      context.missing(_next_plan_show_timeMeta);
    }
    if (data.containsKey('show_familiarity')) {
      context.handle(
          _show_familiarityMeta,
          show_familiarity.isAcceptableOrUnknown(
              data['show_familiarity']!, _show_familiarityMeta));
    } else if (isInserting) {
      context.missing(_show_familiarityMeta);
    }
    context.handle(_study_statusMeta, const VerificationResult.success());
    if (data.containsKey('created_at')) {
      context.handle(
          _created_atMeta,
          created_at.isAcceptableOrUnknown(
              data['created_at']!, _created_atMeta));
    } else if (isInserting) {
      context.missing(_created_atMeta);
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
          _updated_atMeta,
          updated_at.isAcceptableOrUnknown(
              data['updated_at']!, _updated_atMeta));
    } else if (isInserting) {
      context.missing(_updated_atMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  FragmentMemoryInfo map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return FragmentMemoryInfo(
      actual_show_time: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}actual_show_time'])!,
      button_values: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}button_values'])!,
      click_familiarity: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}click_familiarity'])!,
      click_time: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}click_time'])!,
      click_value: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}click_value'])!,
      content_value: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}content_value'])!,
      creator_user_id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}creator_user_id'])!,
      fragment_id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}fragment_id'])!,
      memory_group_id: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}memory_group_id'])!,
      next_plan_show_time: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}next_plan_show_time'])!,
      show_familiarity: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}show_familiarity'])!,
      study_status: $FragmentMemoryInfosTable.$converterstudy_status.fromSql(
          attachedDatabase.typeMapping
              .read(DriftSqlType.int, data['${effectivePrefix}study_status'])!),
      created_at: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_at'])!,
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id'])!,
      updated_at: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}updated_at'])!,
    );
  }

  @override
  $FragmentMemoryInfosTable createAlias(String alias) {
    return $FragmentMemoryInfosTable(attachedDatabase, alias);
  }

  static JsonTypeConverter2<StudyStatus, int, int> $converterstudy_status =
      const EnumIndexConverter<StudyStatus>(StudyStatus.values);
  @override
  bool get withoutRowId => true;
}

class FragmentMemoryInfo extends DataClass
    implements Insertable<FragmentMemoryInfo> {
  String actual_show_time;
  String button_values;
  String click_familiarity;
  String click_time;
  String click_value;
  String content_value;
  int creator_user_id;
  String fragment_id;
  String memory_group_id;
  String next_plan_show_time;
  String show_familiarity;
  StudyStatus study_status;
  DateTime created_at;
  String id;
  DateTime updated_at;
  FragmentMemoryInfo(
      {required this.actual_show_time,
      required this.button_values,
      required this.click_familiarity,
      required this.click_time,
      required this.click_value,
      required this.content_value,
      required this.creator_user_id,
      required this.fragment_id,
      required this.memory_group_id,
      required this.next_plan_show_time,
      required this.show_familiarity,
      required this.study_status,
      required this.created_at,
      required this.id,
      required this.updated_at});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['actual_show_time'] = Variable<String>(actual_show_time);
    map['button_values'] = Variable<String>(button_values);
    map['click_familiarity'] = Variable<String>(click_familiarity);
    map['click_time'] = Variable<String>(click_time);
    map['click_value'] = Variable<String>(click_value);
    map['content_value'] = Variable<String>(content_value);
    map['creator_user_id'] = Variable<int>(creator_user_id);
    map['fragment_id'] = Variable<String>(fragment_id);
    map['memory_group_id'] = Variable<String>(memory_group_id);
    map['next_plan_show_time'] = Variable<String>(next_plan_show_time);
    map['show_familiarity'] = Variable<String>(show_familiarity);
    {
      final converter = $FragmentMemoryInfosTable.$converterstudy_status;
      map['study_status'] = Variable<int>(converter.toSql(study_status));
    }
    map['created_at'] = Variable<DateTime>(created_at);
    map['id'] = Variable<String>(id);
    map['updated_at'] = Variable<DateTime>(updated_at);
    return map;
  }

  FragmentMemoryInfosCompanion toCompanion(bool nullToAbsent) {
    return FragmentMemoryInfosCompanion(
      actual_show_time: Value(actual_show_time),
      button_values: Value(button_values),
      click_familiarity: Value(click_familiarity),
      click_time: Value(click_time),
      click_value: Value(click_value),
      content_value: Value(content_value),
      creator_user_id: Value(creator_user_id),
      fragment_id: Value(fragment_id),
      memory_group_id: Value(memory_group_id),
      next_plan_show_time: Value(next_plan_show_time),
      show_familiarity: Value(show_familiarity),
      study_status: Value(study_status),
      created_at: Value(created_at),
      id: Value(id),
      updated_at: Value(updated_at),
    );
  }

  factory FragmentMemoryInfo.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return FragmentMemoryInfo(
      actual_show_time: serializer.fromJson<String>(json['actual_show_time']),
      button_values: serializer.fromJson<String>(json['button_values']),
      click_familiarity: serializer.fromJson<String>(json['click_familiarity']),
      click_time: serializer.fromJson<String>(json['click_time']),
      click_value: serializer.fromJson<String>(json['click_value']),
      content_value: serializer.fromJson<String>(json['content_value']),
      creator_user_id: serializer.fromJson<int>(json['creator_user_id']),
      fragment_id: serializer.fromJson<String>(json['fragment_id']),
      memory_group_id: serializer.fromJson<String>(json['memory_group_id']),
      next_plan_show_time:
          serializer.fromJson<String>(json['next_plan_show_time']),
      show_familiarity: serializer.fromJson<String>(json['show_familiarity']),
      study_status: $FragmentMemoryInfosTable.$converterstudy_status
          .fromJson(serializer.fromJson<int>(json['study_status'])),
      created_at: serializer.fromJson<DateTime>(json['created_at']),
      id: serializer.fromJson<String>(json['id']),
      updated_at: serializer.fromJson<DateTime>(json['updated_at']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'actual_show_time': serializer.toJson<String>(actual_show_time),
      'button_values': serializer.toJson<String>(button_values),
      'click_familiarity': serializer.toJson<String>(click_familiarity),
      'click_time': serializer.toJson<String>(click_time),
      'click_value': serializer.toJson<String>(click_value),
      'content_value': serializer.toJson<String>(content_value),
      'creator_user_id': serializer.toJson<int>(creator_user_id),
      'fragment_id': serializer.toJson<String>(fragment_id),
      'memory_group_id': serializer.toJson<String>(memory_group_id),
      'next_plan_show_time': serializer.toJson<String>(next_plan_show_time),
      'show_familiarity': serializer.toJson<String>(show_familiarity),
      'study_status': serializer.toJson<int>($FragmentMemoryInfosTable
          .$converterstudy_status
          .toJson(study_status)),
      'created_at': serializer.toJson<DateTime>(created_at),
      'id': serializer.toJson<String>(id),
      'updated_at': serializer.toJson<DateTime>(updated_at),
    };
  }

  FragmentMemoryInfo copyWith(
          {String? actual_show_time,
          String? button_values,
          String? click_familiarity,
          String? click_time,
          String? click_value,
          String? content_value,
          int? creator_user_id,
          String? fragment_id,
          String? memory_group_id,
          String? next_plan_show_time,
          String? show_familiarity,
          StudyStatus? study_status,
          DateTime? created_at,
          String? id,
          DateTime? updated_at}) =>
      FragmentMemoryInfo(
        actual_show_time: actual_show_time ?? this.actual_show_time,
        button_values: button_values ?? this.button_values,
        click_familiarity: click_familiarity ?? this.click_familiarity,
        click_time: click_time ?? this.click_time,
        click_value: click_value ?? this.click_value,
        content_value: content_value ?? this.content_value,
        creator_user_id: creator_user_id ?? this.creator_user_id,
        fragment_id: fragment_id ?? this.fragment_id,
        memory_group_id: memory_group_id ?? this.memory_group_id,
        next_plan_show_time: next_plan_show_time ?? this.next_plan_show_time,
        show_familiarity: show_familiarity ?? this.show_familiarity,
        study_status: study_status ?? this.study_status,
        created_at: created_at ?? this.created_at,
        id: id ?? this.id,
        updated_at: updated_at ?? this.updated_at,
      );
  @override
  String toString() {
    return (StringBuffer('FragmentMemoryInfo(')
          ..write('actual_show_time: $actual_show_time, ')
          ..write('button_values: $button_values, ')
          ..write('click_familiarity: $click_familiarity, ')
          ..write('click_time: $click_time, ')
          ..write('click_value: $click_value, ')
          ..write('content_value: $content_value, ')
          ..write('creator_user_id: $creator_user_id, ')
          ..write('fragment_id: $fragment_id, ')
          ..write('memory_group_id: $memory_group_id, ')
          ..write('next_plan_show_time: $next_plan_show_time, ')
          ..write('show_familiarity: $show_familiarity, ')
          ..write('study_status: $study_status, ')
          ..write('created_at: $created_at, ')
          ..write('id: $id, ')
          ..write('updated_at: $updated_at')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      actual_show_time,
      button_values,
      click_familiarity,
      click_time,
      click_value,
      content_value,
      creator_user_id,
      fragment_id,
      memory_group_id,
      next_plan_show_time,
      show_familiarity,
      study_status,
      created_at,
      id,
      updated_at);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is FragmentMemoryInfo &&
          other.actual_show_time == this.actual_show_time &&
          other.button_values == this.button_values &&
          other.click_familiarity == this.click_familiarity &&
          other.click_time == this.click_time &&
          other.click_value == this.click_value &&
          other.content_value == this.content_value &&
          other.creator_user_id == this.creator_user_id &&
          other.fragment_id == this.fragment_id &&
          other.memory_group_id == this.memory_group_id &&
          other.next_plan_show_time == this.next_plan_show_time &&
          other.show_familiarity == this.show_familiarity &&
          other.study_status == this.study_status &&
          other.created_at == this.created_at &&
          other.id == this.id &&
          other.updated_at == this.updated_at);
}

class FragmentMemoryInfosCompanion extends UpdateCompanion<FragmentMemoryInfo> {
  Value<String> actual_show_time;
  Value<String> button_values;
  Value<String> click_familiarity;
  Value<String> click_time;
  Value<String> click_value;
  Value<String> content_value;
  Value<int> creator_user_id;
  Value<String> fragment_id;
  Value<String> memory_group_id;
  Value<String> next_plan_show_time;
  Value<String> show_familiarity;
  Value<StudyStatus> study_status;
  Value<DateTime> created_at;
  Value<String> id;
  Value<DateTime> updated_at;
  FragmentMemoryInfosCompanion({
    this.actual_show_time = const Value.absent(),
    this.button_values = const Value.absent(),
    this.click_familiarity = const Value.absent(),
    this.click_time = const Value.absent(),
    this.click_value = const Value.absent(),
    this.content_value = const Value.absent(),
    this.creator_user_id = const Value.absent(),
    this.fragment_id = const Value.absent(),
    this.memory_group_id = const Value.absent(),
    this.next_plan_show_time = const Value.absent(),
    this.show_familiarity = const Value.absent(),
    this.study_status = const Value.absent(),
    this.created_at = const Value.absent(),
    this.id = const Value.absent(),
    this.updated_at = const Value.absent(),
  });
  FragmentMemoryInfosCompanion.insert({
    required String actual_show_time,
    required String button_values,
    required String click_familiarity,
    required String click_time,
    required String click_value,
    required String content_value,
    required int creator_user_id,
    required String fragment_id,
    required String memory_group_id,
    required String next_plan_show_time,
    required String show_familiarity,
    required StudyStatus study_status,
    required DateTime created_at,
    required String id,
    required DateTime updated_at,
  })  : actual_show_time = Value(actual_show_time),
        button_values = Value(button_values),
        click_familiarity = Value(click_familiarity),
        click_time = Value(click_time),
        click_value = Value(click_value),
        content_value = Value(content_value),
        creator_user_id = Value(creator_user_id),
        fragment_id = Value(fragment_id),
        memory_group_id = Value(memory_group_id),
        next_plan_show_time = Value(next_plan_show_time),
        show_familiarity = Value(show_familiarity),
        study_status = Value(study_status),
        created_at = Value(created_at),
        id = Value(id),
        updated_at = Value(updated_at);
  static Insertable<FragmentMemoryInfo> custom({
    Expression<String>? actual_show_time,
    Expression<String>? button_values,
    Expression<String>? click_familiarity,
    Expression<String>? click_time,
    Expression<String>? click_value,
    Expression<String>? content_value,
    Expression<int>? creator_user_id,
    Expression<String>? fragment_id,
    Expression<String>? memory_group_id,
    Expression<String>? next_plan_show_time,
    Expression<String>? show_familiarity,
    Expression<int>? study_status,
    Expression<DateTime>? created_at,
    Expression<String>? id,
    Expression<DateTime>? updated_at,
  }) {
    return RawValuesInsertable({
      if (actual_show_time != null) 'actual_show_time': actual_show_time,
      if (button_values != null) 'button_values': button_values,
      if (click_familiarity != null) 'click_familiarity': click_familiarity,
      if (click_time != null) 'click_time': click_time,
      if (click_value != null) 'click_value': click_value,
      if (content_value != null) 'content_value': content_value,
      if (creator_user_id != null) 'creator_user_id': creator_user_id,
      if (fragment_id != null) 'fragment_id': fragment_id,
      if (memory_group_id != null) 'memory_group_id': memory_group_id,
      if (next_plan_show_time != null)
        'next_plan_show_time': next_plan_show_time,
      if (show_familiarity != null) 'show_familiarity': show_familiarity,
      if (study_status != null) 'study_status': study_status,
      if (created_at != null) 'created_at': created_at,
      if (id != null) 'id': id,
      if (updated_at != null) 'updated_at': updated_at,
    });
  }

  FragmentMemoryInfosCompanion copyWith(
      {Value<String>? actual_show_time,
      Value<String>? button_values,
      Value<String>? click_familiarity,
      Value<String>? click_time,
      Value<String>? click_value,
      Value<String>? content_value,
      Value<int>? creator_user_id,
      Value<String>? fragment_id,
      Value<String>? memory_group_id,
      Value<String>? next_plan_show_time,
      Value<String>? show_familiarity,
      Value<StudyStatus>? study_status,
      Value<DateTime>? created_at,
      Value<String>? id,
      Value<DateTime>? updated_at}) {
    return FragmentMemoryInfosCompanion(
      actual_show_time: actual_show_time ?? this.actual_show_time,
      button_values: button_values ?? this.button_values,
      click_familiarity: click_familiarity ?? this.click_familiarity,
      click_time: click_time ?? this.click_time,
      click_value: click_value ?? this.click_value,
      content_value: content_value ?? this.content_value,
      creator_user_id: creator_user_id ?? this.creator_user_id,
      fragment_id: fragment_id ?? this.fragment_id,
      memory_group_id: memory_group_id ?? this.memory_group_id,
      next_plan_show_time: next_plan_show_time ?? this.next_plan_show_time,
      show_familiarity: show_familiarity ?? this.show_familiarity,
      study_status: study_status ?? this.study_status,
      created_at: created_at ?? this.created_at,
      id: id ?? this.id,
      updated_at: updated_at ?? this.updated_at,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (actual_show_time.present) {
      map['actual_show_time'] = Variable<String>(actual_show_time.value);
    }
    if (button_values.present) {
      map['button_values'] = Variable<String>(button_values.value);
    }
    if (click_familiarity.present) {
      map['click_familiarity'] = Variable<String>(click_familiarity.value);
    }
    if (click_time.present) {
      map['click_time'] = Variable<String>(click_time.value);
    }
    if (click_value.present) {
      map['click_value'] = Variable<String>(click_value.value);
    }
    if (content_value.present) {
      map['content_value'] = Variable<String>(content_value.value);
    }
    if (creator_user_id.present) {
      map['creator_user_id'] = Variable<int>(creator_user_id.value);
    }
    if (fragment_id.present) {
      map['fragment_id'] = Variable<String>(fragment_id.value);
    }
    if (memory_group_id.present) {
      map['memory_group_id'] = Variable<String>(memory_group_id.value);
    }
    if (next_plan_show_time.present) {
      map['next_plan_show_time'] = Variable<String>(next_plan_show_time.value);
    }
    if (show_familiarity.present) {
      map['show_familiarity'] = Variable<String>(show_familiarity.value);
    }
    if (study_status.present) {
      final converter = $FragmentMemoryInfosTable.$converterstudy_status;
      map['study_status'] = Variable<int>(converter.toSql(study_status.value));
    }
    if (created_at.present) {
      map['created_at'] = Variable<DateTime>(created_at.value);
    }
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (updated_at.present) {
      map['updated_at'] = Variable<DateTime>(updated_at.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('FragmentMemoryInfosCompanion(')
          ..write('actual_show_time: $actual_show_time, ')
          ..write('button_values: $button_values, ')
          ..write('click_familiarity: $click_familiarity, ')
          ..write('click_time: $click_time, ')
          ..write('click_value: $click_value, ')
          ..write('content_value: $content_value, ')
          ..write('creator_user_id: $creator_user_id, ')
          ..write('fragment_id: $fragment_id, ')
          ..write('memory_group_id: $memory_group_id, ')
          ..write('next_plan_show_time: $next_plan_show_time, ')
          ..write('show_familiarity: $show_familiarity, ')
          ..write('study_status: $study_status, ')
          ..write('created_at: $created_at, ')
          ..write('id: $id, ')
          ..write('updated_at: $updated_at')
          ..write(')'))
        .toString();
  }
}

class $FragmentGroupTagsTable extends FragmentGroupTags
    with TableInfo<$FragmentGroupTagsTable, FragmentGroupTag> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $FragmentGroupTagsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _fragment_group_idMeta =
      const VerificationMeta('fragment_group_id');
  @override
  late final GeneratedColumn<String> fragment_group_id =
      GeneratedColumn<String>('fragment_group_id', aliasedName, false,
          type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _tagMeta = const VerificationMeta('tag');
  @override
  late final GeneratedColumn<String> tag = GeneratedColumn<String>(
      'tag', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _created_atMeta =
      const VerificationMeta('created_at');
  @override
  late final GeneratedColumn<DateTime> created_at = GeneratedColumn<DateTime>(
      'created_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _updated_atMeta =
      const VerificationMeta('updated_at');
  @override
  late final GeneratedColumn<DateTime> updated_at = GeneratedColumn<DateTime>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns =>
      [fragment_group_id, tag, created_at, id, updated_at];
  @override
  String get aliasedName => _alias ?? 'fragment_group_tags';
  @override
  String get actualTableName => 'fragment_group_tags';
  @override
  VerificationContext validateIntegrity(Insertable<FragmentGroupTag> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('fragment_group_id')) {
      context.handle(
          _fragment_group_idMeta,
          fragment_group_id.isAcceptableOrUnknown(
              data['fragment_group_id']!, _fragment_group_idMeta));
    } else if (isInserting) {
      context.missing(_fragment_group_idMeta);
    }
    if (data.containsKey('tag')) {
      context.handle(
          _tagMeta, tag.isAcceptableOrUnknown(data['tag']!, _tagMeta));
    } else if (isInserting) {
      context.missing(_tagMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(
          _created_atMeta,
          created_at.isAcceptableOrUnknown(
              data['created_at']!, _created_atMeta));
    } else if (isInserting) {
      context.missing(_created_atMeta);
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
          _updated_atMeta,
          updated_at.isAcceptableOrUnknown(
              data['updated_at']!, _updated_atMeta));
    } else if (isInserting) {
      context.missing(_updated_atMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  FragmentGroupTag map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return FragmentGroupTag(
      fragment_group_id: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}fragment_group_id'])!,
      tag: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tag'])!,
      created_at: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_at'])!,
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id'])!,
      updated_at: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}updated_at'])!,
    );
  }

  @override
  $FragmentGroupTagsTable createAlias(String alias) {
    return $FragmentGroupTagsTable(attachedDatabase, alias);
  }

  @override
  bool get withoutRowId => true;
}

class FragmentGroupTag extends DataClass
    implements Insertable<FragmentGroupTag> {
  String fragment_group_id;
  String tag;
  DateTime created_at;
  String id;
  DateTime updated_at;
  FragmentGroupTag(
      {required this.fragment_group_id,
      required this.tag,
      required this.created_at,
      required this.id,
      required this.updated_at});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['fragment_group_id'] = Variable<String>(fragment_group_id);
    map['tag'] = Variable<String>(tag);
    map['created_at'] = Variable<DateTime>(created_at);
    map['id'] = Variable<String>(id);
    map['updated_at'] = Variable<DateTime>(updated_at);
    return map;
  }

  FragmentGroupTagsCompanion toCompanion(bool nullToAbsent) {
    return FragmentGroupTagsCompanion(
      fragment_group_id: Value(fragment_group_id),
      tag: Value(tag),
      created_at: Value(created_at),
      id: Value(id),
      updated_at: Value(updated_at),
    );
  }

  factory FragmentGroupTag.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return FragmentGroupTag(
      fragment_group_id: serializer.fromJson<String>(json['fragment_group_id']),
      tag: serializer.fromJson<String>(json['tag']),
      created_at: serializer.fromJson<DateTime>(json['created_at']),
      id: serializer.fromJson<String>(json['id']),
      updated_at: serializer.fromJson<DateTime>(json['updated_at']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'fragment_group_id': serializer.toJson<String>(fragment_group_id),
      'tag': serializer.toJson<String>(tag),
      'created_at': serializer.toJson<DateTime>(created_at),
      'id': serializer.toJson<String>(id),
      'updated_at': serializer.toJson<DateTime>(updated_at),
    };
  }

  FragmentGroupTag copyWith(
          {String? fragment_group_id,
          String? tag,
          DateTime? created_at,
          String? id,
          DateTime? updated_at}) =>
      FragmentGroupTag(
        fragment_group_id: fragment_group_id ?? this.fragment_group_id,
        tag: tag ?? this.tag,
        created_at: created_at ?? this.created_at,
        id: id ?? this.id,
        updated_at: updated_at ?? this.updated_at,
      );
  @override
  String toString() {
    return (StringBuffer('FragmentGroupTag(')
          ..write('fragment_group_id: $fragment_group_id, ')
          ..write('tag: $tag, ')
          ..write('created_at: $created_at, ')
          ..write('id: $id, ')
          ..write('updated_at: $updated_at')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(fragment_group_id, tag, created_at, id, updated_at);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is FragmentGroupTag &&
          other.fragment_group_id == this.fragment_group_id &&
          other.tag == this.tag &&
          other.created_at == this.created_at &&
          other.id == this.id &&
          other.updated_at == this.updated_at);
}

class FragmentGroupTagsCompanion extends UpdateCompanion<FragmentGroupTag> {
  Value<String> fragment_group_id;
  Value<String> tag;
  Value<DateTime> created_at;
  Value<String> id;
  Value<DateTime> updated_at;
  FragmentGroupTagsCompanion({
    this.fragment_group_id = const Value.absent(),
    this.tag = const Value.absent(),
    this.created_at = const Value.absent(),
    this.id = const Value.absent(),
    this.updated_at = const Value.absent(),
  });
  FragmentGroupTagsCompanion.insert({
    required String fragment_group_id,
    required String tag,
    required DateTime created_at,
    required String id,
    required DateTime updated_at,
  })  : fragment_group_id = Value(fragment_group_id),
        tag = Value(tag),
        created_at = Value(created_at),
        id = Value(id),
        updated_at = Value(updated_at);
  static Insertable<FragmentGroupTag> custom({
    Expression<String>? fragment_group_id,
    Expression<String>? tag,
    Expression<DateTime>? created_at,
    Expression<String>? id,
    Expression<DateTime>? updated_at,
  }) {
    return RawValuesInsertable({
      if (fragment_group_id != null) 'fragment_group_id': fragment_group_id,
      if (tag != null) 'tag': tag,
      if (created_at != null) 'created_at': created_at,
      if (id != null) 'id': id,
      if (updated_at != null) 'updated_at': updated_at,
    });
  }

  FragmentGroupTagsCompanion copyWith(
      {Value<String>? fragment_group_id,
      Value<String>? tag,
      Value<DateTime>? created_at,
      Value<String>? id,
      Value<DateTime>? updated_at}) {
    return FragmentGroupTagsCompanion(
      fragment_group_id: fragment_group_id ?? this.fragment_group_id,
      tag: tag ?? this.tag,
      created_at: created_at ?? this.created_at,
      id: id ?? this.id,
      updated_at: updated_at ?? this.updated_at,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (fragment_group_id.present) {
      map['fragment_group_id'] = Variable<String>(fragment_group_id.value);
    }
    if (tag.present) {
      map['tag'] = Variable<String>(tag.value);
    }
    if (created_at.present) {
      map['created_at'] = Variable<DateTime>(created_at.value);
    }
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (updated_at.present) {
      map['updated_at'] = Variable<DateTime>(updated_at.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('FragmentGroupTagsCompanion(')
          ..write('fragment_group_id: $fragment_group_id, ')
          ..write('tag: $tag, ')
          ..write('created_at: $created_at, ')
          ..write('id: $id, ')
          ..write('updated_at: $updated_at')
          ..write(')'))
        .toString();
  }
}

class $RFragment2FragmentGroupsTable extends RFragment2FragmentGroups
    with TableInfo<$RFragment2FragmentGroupsTable, RFragment2FragmentGroup> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $RFragment2FragmentGroupsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _creator_user_idMeta =
      const VerificationMeta('creator_user_id');
  @override
  late final GeneratedColumn<int> creator_user_id = GeneratedColumn<int>(
      'creator_user_id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _fragment_group_idMeta =
      const VerificationMeta('fragment_group_id');
  @override
  late final GeneratedColumn<String> fragment_group_id =
      GeneratedColumn<String>('fragment_group_id', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _fragment_idMeta =
      const VerificationMeta('fragment_id');
  @override
  late final GeneratedColumn<String> fragment_id = GeneratedColumn<String>(
      'fragment_id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _created_atMeta =
      const VerificationMeta('created_at');
  @override
  late final GeneratedColumn<DateTime> created_at = GeneratedColumn<DateTime>(
      'created_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _updated_atMeta =
      const VerificationMeta('updated_at');
  @override
  late final GeneratedColumn<DateTime> updated_at = GeneratedColumn<DateTime>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns => [
        creator_user_id,
        fragment_group_id,
        fragment_id,
        created_at,
        id,
        updated_at
      ];
  @override
  String get aliasedName => _alias ?? 'r_fragment2_fragment_groups';
  @override
  String get actualTableName => 'r_fragment2_fragment_groups';
  @override
  VerificationContext validateIntegrity(
      Insertable<RFragment2FragmentGroup> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('creator_user_id')) {
      context.handle(
          _creator_user_idMeta,
          creator_user_id.isAcceptableOrUnknown(
              data['creator_user_id']!, _creator_user_idMeta));
    } else if (isInserting) {
      context.missing(_creator_user_idMeta);
    }
    if (data.containsKey('fragment_group_id')) {
      context.handle(
          _fragment_group_idMeta,
          fragment_group_id.isAcceptableOrUnknown(
              data['fragment_group_id']!, _fragment_group_idMeta));
    }
    if (data.containsKey('fragment_id')) {
      context.handle(
          _fragment_idMeta,
          fragment_id.isAcceptableOrUnknown(
              data['fragment_id']!, _fragment_idMeta));
    } else if (isInserting) {
      context.missing(_fragment_idMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(
          _created_atMeta,
          created_at.isAcceptableOrUnknown(
              data['created_at']!, _created_atMeta));
    } else if (isInserting) {
      context.missing(_created_atMeta);
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
          _updated_atMeta,
          updated_at.isAcceptableOrUnknown(
              data['updated_at']!, _updated_atMeta));
    } else if (isInserting) {
      context.missing(_updated_atMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  RFragment2FragmentGroup map(Map<String, dynamic> data,
      {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return RFragment2FragmentGroup(
      creator_user_id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}creator_user_id'])!,
      fragment_group_id: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}fragment_group_id']),
      fragment_id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}fragment_id'])!,
      created_at: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_at'])!,
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id'])!,
      updated_at: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}updated_at'])!,
    );
  }

  @override
  $RFragment2FragmentGroupsTable createAlias(String alias) {
    return $RFragment2FragmentGroupsTable(attachedDatabase, alias);
  }

  @override
  bool get withoutRowId => true;
}

class RFragment2FragmentGroup extends DataClass
    implements Insertable<RFragment2FragmentGroup> {
  int creator_user_id;
  String? fragment_group_id;
  String fragment_id;
  DateTime created_at;
  String id;
  DateTime updated_at;
  RFragment2FragmentGroup(
      {required this.creator_user_id,
      this.fragment_group_id,
      required this.fragment_id,
      required this.created_at,
      required this.id,
      required this.updated_at});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['creator_user_id'] = Variable<int>(creator_user_id);
    if (!nullToAbsent || fragment_group_id != null) {
      map['fragment_group_id'] = Variable<String>(fragment_group_id);
    }
    map['fragment_id'] = Variable<String>(fragment_id);
    map['created_at'] = Variable<DateTime>(created_at);
    map['id'] = Variable<String>(id);
    map['updated_at'] = Variable<DateTime>(updated_at);
    return map;
  }

  RFragment2FragmentGroupsCompanion toCompanion(bool nullToAbsent) {
    return RFragment2FragmentGroupsCompanion(
      creator_user_id: Value(creator_user_id),
      fragment_group_id: fragment_group_id == null && nullToAbsent
          ? const Value.absent()
          : Value(fragment_group_id),
      fragment_id: Value(fragment_id),
      created_at: Value(created_at),
      id: Value(id),
      updated_at: Value(updated_at),
    );
  }

  factory RFragment2FragmentGroup.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return RFragment2FragmentGroup(
      creator_user_id: serializer.fromJson<int>(json['creator_user_id']),
      fragment_group_id:
          serializer.fromJson<String?>(json['fragment_group_id']),
      fragment_id: serializer.fromJson<String>(json['fragment_id']),
      created_at: serializer.fromJson<DateTime>(json['created_at']),
      id: serializer.fromJson<String>(json['id']),
      updated_at: serializer.fromJson<DateTime>(json['updated_at']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'creator_user_id': serializer.toJson<int>(creator_user_id),
      'fragment_group_id': serializer.toJson<String?>(fragment_group_id),
      'fragment_id': serializer.toJson<String>(fragment_id),
      'created_at': serializer.toJson<DateTime>(created_at),
      'id': serializer.toJson<String>(id),
      'updated_at': serializer.toJson<DateTime>(updated_at),
    };
  }

  RFragment2FragmentGroup copyWith(
          {int? creator_user_id,
          Value<String?> fragment_group_id = const Value.absent(),
          String? fragment_id,
          DateTime? created_at,
          String? id,
          DateTime? updated_at}) =>
      RFragment2FragmentGroup(
        creator_user_id: creator_user_id ?? this.creator_user_id,
        fragment_group_id: fragment_group_id.present
            ? fragment_group_id.value
            : this.fragment_group_id,
        fragment_id: fragment_id ?? this.fragment_id,
        created_at: created_at ?? this.created_at,
        id: id ?? this.id,
        updated_at: updated_at ?? this.updated_at,
      );
  @override
  String toString() {
    return (StringBuffer('RFragment2FragmentGroup(')
          ..write('creator_user_id: $creator_user_id, ')
          ..write('fragment_group_id: $fragment_group_id, ')
          ..write('fragment_id: $fragment_id, ')
          ..write('created_at: $created_at, ')
          ..write('id: $id, ')
          ..write('updated_at: $updated_at')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(creator_user_id, fragment_group_id,
      fragment_id, created_at, id, updated_at);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is RFragment2FragmentGroup &&
          other.creator_user_id == this.creator_user_id &&
          other.fragment_group_id == this.fragment_group_id &&
          other.fragment_id == this.fragment_id &&
          other.created_at == this.created_at &&
          other.id == this.id &&
          other.updated_at == this.updated_at);
}

class RFragment2FragmentGroupsCompanion
    extends UpdateCompanion<RFragment2FragmentGroup> {
  Value<int> creator_user_id;
  Value<String?> fragment_group_id;
  Value<String> fragment_id;
  Value<DateTime> created_at;
  Value<String> id;
  Value<DateTime> updated_at;
  RFragment2FragmentGroupsCompanion({
    this.creator_user_id = const Value.absent(),
    this.fragment_group_id = const Value.absent(),
    this.fragment_id = const Value.absent(),
    this.created_at = const Value.absent(),
    this.id = const Value.absent(),
    this.updated_at = const Value.absent(),
  });
  RFragment2FragmentGroupsCompanion.insert({
    required int creator_user_id,
    this.fragment_group_id = const Value.absent(),
    required String fragment_id,
    required DateTime created_at,
    required String id,
    required DateTime updated_at,
  })  : creator_user_id = Value(creator_user_id),
        fragment_id = Value(fragment_id),
        created_at = Value(created_at),
        id = Value(id),
        updated_at = Value(updated_at);
  static Insertable<RFragment2FragmentGroup> custom({
    Expression<int>? creator_user_id,
    Expression<String>? fragment_group_id,
    Expression<String>? fragment_id,
    Expression<DateTime>? created_at,
    Expression<String>? id,
    Expression<DateTime>? updated_at,
  }) {
    return RawValuesInsertable({
      if (creator_user_id != null) 'creator_user_id': creator_user_id,
      if (fragment_group_id != null) 'fragment_group_id': fragment_group_id,
      if (fragment_id != null) 'fragment_id': fragment_id,
      if (created_at != null) 'created_at': created_at,
      if (id != null) 'id': id,
      if (updated_at != null) 'updated_at': updated_at,
    });
  }

  RFragment2FragmentGroupsCompanion copyWith(
      {Value<int>? creator_user_id,
      Value<String?>? fragment_group_id,
      Value<String>? fragment_id,
      Value<DateTime>? created_at,
      Value<String>? id,
      Value<DateTime>? updated_at}) {
    return RFragment2FragmentGroupsCompanion(
      creator_user_id: creator_user_id ?? this.creator_user_id,
      fragment_group_id: fragment_group_id ?? this.fragment_group_id,
      fragment_id: fragment_id ?? this.fragment_id,
      created_at: created_at ?? this.created_at,
      id: id ?? this.id,
      updated_at: updated_at ?? this.updated_at,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (creator_user_id.present) {
      map['creator_user_id'] = Variable<int>(creator_user_id.value);
    }
    if (fragment_group_id.present) {
      map['fragment_group_id'] = Variable<String>(fragment_group_id.value);
    }
    if (fragment_id.present) {
      map['fragment_id'] = Variable<String>(fragment_id.value);
    }
    if (created_at.present) {
      map['created_at'] = Variable<DateTime>(created_at.value);
    }
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (updated_at.present) {
      map['updated_at'] = Variable<DateTime>(updated_at.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('RFragment2FragmentGroupsCompanion(')
          ..write('creator_user_id: $creator_user_id, ')
          ..write('fragment_group_id: $fragment_group_id, ')
          ..write('fragment_id: $fragment_id, ')
          ..write('created_at: $created_at, ')
          ..write('id: $id, ')
          ..write('updated_at: $updated_at')
          ..write(')'))
        .toString();
  }
}

class $Test2sTable extends Test2s with TableInfo<$Test2sTable, Test2> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $Test2sTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _client_contentMeta =
      const VerificationMeta('client_content');
  @override
  late final GeneratedColumn<String> client_content = GeneratedColumn<String>(
      'client_content', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _created_atMeta =
      const VerificationMeta('created_at');
  @override
  late final GeneratedColumn<DateTime> created_at = GeneratedColumn<DateTime>(
      'created_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _updated_atMeta =
      const VerificationMeta('updated_at');
  @override
  late final GeneratedColumn<DateTime> updated_at = GeneratedColumn<DateTime>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns =>
      [client_content, created_at, id, updated_at];
  @override
  String get aliasedName => _alias ?? 'test2s';
  @override
  String get actualTableName => 'test2s';
  @override
  VerificationContext validateIntegrity(Insertable<Test2> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('client_content')) {
      context.handle(
          _client_contentMeta,
          client_content.isAcceptableOrUnknown(
              data['client_content']!, _client_contentMeta));
    } else if (isInserting) {
      context.missing(_client_contentMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(
          _created_atMeta,
          created_at.isAcceptableOrUnknown(
              data['created_at']!, _created_atMeta));
    } else if (isInserting) {
      context.missing(_created_atMeta);
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('updated_at')) {
      context.handle(
          _updated_atMeta,
          updated_at.isAcceptableOrUnknown(
              data['updated_at']!, _updated_atMeta));
    } else if (isInserting) {
      context.missing(_updated_atMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Test2 map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Test2(
      client_content: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}client_content'])!,
      created_at: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_at'])!,
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      updated_at: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}updated_at'])!,
    );
  }

  @override
  $Test2sTable createAlias(String alias) {
    return $Test2sTable(attachedDatabase, alias);
  }
}

class Test2 extends DataClass implements Insertable<Test2> {
  String client_content;
  DateTime created_at;
  int id;
  DateTime updated_at;
  Test2(
      {required this.client_content,
      required this.created_at,
      required this.id,
      required this.updated_at});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['client_content'] = Variable<String>(client_content);
    map['created_at'] = Variable<DateTime>(created_at);
    map['id'] = Variable<int>(id);
    map['updated_at'] = Variable<DateTime>(updated_at);
    return map;
  }

  Test2sCompanion toCompanion(bool nullToAbsent) {
    return Test2sCompanion(
      client_content: Value(client_content),
      created_at: Value(created_at),
      id: Value(id),
      updated_at: Value(updated_at),
    );
  }

  factory Test2.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Test2(
      client_content: serializer.fromJson<String>(json['client_content']),
      created_at: serializer.fromJson<DateTime>(json['created_at']),
      id: serializer.fromJson<int>(json['id']),
      updated_at: serializer.fromJson<DateTime>(json['updated_at']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'client_content': serializer.toJson<String>(client_content),
      'created_at': serializer.toJson<DateTime>(created_at),
      'id': serializer.toJson<int>(id),
      'updated_at': serializer.toJson<DateTime>(updated_at),
    };
  }

  Test2 copyWith(
          {String? client_content,
          DateTime? created_at,
          int? id,
          DateTime? updated_at}) =>
      Test2(
        client_content: client_content ?? this.client_content,
        created_at: created_at ?? this.created_at,
        id: id ?? this.id,
        updated_at: updated_at ?? this.updated_at,
      );
  @override
  String toString() {
    return (StringBuffer('Test2(')
          ..write('client_content: $client_content, ')
          ..write('created_at: $created_at, ')
          ..write('id: $id, ')
          ..write('updated_at: $updated_at')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(client_content, created_at, id, updated_at);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Test2 &&
          other.client_content == this.client_content &&
          other.created_at == this.created_at &&
          other.id == this.id &&
          other.updated_at == this.updated_at);
}

class Test2sCompanion extends UpdateCompanion<Test2> {
  Value<String> client_content;
  Value<DateTime> created_at;
  Value<int> id;
  Value<DateTime> updated_at;
  Test2sCompanion({
    this.client_content = const Value.absent(),
    this.created_at = const Value.absent(),
    this.id = const Value.absent(),
    this.updated_at = const Value.absent(),
  });
  Test2sCompanion.insert({
    required String client_content,
    required DateTime created_at,
    this.id = const Value.absent(),
    required DateTime updated_at,
  })  : client_content = Value(client_content),
        created_at = Value(created_at),
        updated_at = Value(updated_at);
  static Insertable<Test2> custom({
    Expression<String>? client_content,
    Expression<DateTime>? created_at,
    Expression<int>? id,
    Expression<DateTime>? updated_at,
  }) {
    return RawValuesInsertable({
      if (client_content != null) 'client_content': client_content,
      if (created_at != null) 'created_at': created_at,
      if (id != null) 'id': id,
      if (updated_at != null) 'updated_at': updated_at,
    });
  }

  Test2sCompanion copyWith(
      {Value<String>? client_content,
      Value<DateTime>? created_at,
      Value<int>? id,
      Value<DateTime>? updated_at}) {
    return Test2sCompanion(
      client_content: client_content ?? this.client_content,
      created_at: created_at ?? this.created_at,
      id: id ?? this.id,
      updated_at: updated_at ?? this.updated_at,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (client_content.present) {
      map['client_content'] = Variable<String>(client_content.value);
    }
    if (created_at.present) {
      map['created_at'] = Variable<DateTime>(created_at.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (updated_at.present) {
      map['updated_at'] = Variable<DateTime>(updated_at.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('Test2sCompanion(')
          ..write('client_content: $client_content, ')
          ..write('created_at: $created_at, ')
          ..write('id: $id, ')
          ..write('updated_at: $updated_at')
          ..write(')'))
        .toString();
  }
}

class $TestsTable extends Tests with TableInfo<$TestsTable, Test> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $TestsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _client_aMeta =
      const VerificationMeta('client_a');
  @override
  late final GeneratedColumn<String> client_a = GeneratedColumn<String>(
      'client_a', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _client_contentMeta =
      const VerificationMeta('client_content');
  @override
  late final GeneratedColumn<String> client_content = GeneratedColumn<String>(
      'client_content', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _created_atMeta =
      const VerificationMeta('created_at');
  @override
  late final GeneratedColumn<DateTime> created_at = GeneratedColumn<DateTime>(
      'created_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _updated_atMeta =
      const VerificationMeta('updated_at');
  @override
  late final GeneratedColumn<DateTime> updated_at = GeneratedColumn<DateTime>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns =>
      [client_a, client_content, created_at, id, updated_at];
  @override
  String get aliasedName => _alias ?? 'tests';
  @override
  String get actualTableName => 'tests';
  @override
  VerificationContext validateIntegrity(Insertable<Test> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('client_a')) {
      context.handle(_client_aMeta,
          client_a.isAcceptableOrUnknown(data['client_a']!, _client_aMeta));
    } else if (isInserting) {
      context.missing(_client_aMeta);
    }
    if (data.containsKey('client_content')) {
      context.handle(
          _client_contentMeta,
          client_content.isAcceptableOrUnknown(
              data['client_content']!, _client_contentMeta));
    } else if (isInserting) {
      context.missing(_client_contentMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(
          _created_atMeta,
          created_at.isAcceptableOrUnknown(
              data['created_at']!, _created_atMeta));
    } else if (isInserting) {
      context.missing(_created_atMeta);
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('updated_at')) {
      context.handle(
          _updated_atMeta,
          updated_at.isAcceptableOrUnknown(
              data['updated_at']!, _updated_atMeta));
    } else if (isInserting) {
      context.missing(_updated_atMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Test map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Test(
      client_a: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}client_a'])!,
      client_content: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}client_content'])!,
      created_at: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_at'])!,
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      updated_at: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}updated_at'])!,
    );
  }

  @override
  $TestsTable createAlias(String alias) {
    return $TestsTable(attachedDatabase, alias);
  }
}

class Test extends DataClass implements Insertable<Test> {
  String client_a;
  String client_content;
  DateTime created_at;
  int id;
  DateTime updated_at;
  Test(
      {required this.client_a,
      required this.client_content,
      required this.created_at,
      required this.id,
      required this.updated_at});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['client_a'] = Variable<String>(client_a);
    map['client_content'] = Variable<String>(client_content);
    map['created_at'] = Variable<DateTime>(created_at);
    map['id'] = Variable<int>(id);
    map['updated_at'] = Variable<DateTime>(updated_at);
    return map;
  }

  TestsCompanion toCompanion(bool nullToAbsent) {
    return TestsCompanion(
      client_a: Value(client_a),
      client_content: Value(client_content),
      created_at: Value(created_at),
      id: Value(id),
      updated_at: Value(updated_at),
    );
  }

  factory Test.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Test(
      client_a: serializer.fromJson<String>(json['client_a']),
      client_content: serializer.fromJson<String>(json['client_content']),
      created_at: serializer.fromJson<DateTime>(json['created_at']),
      id: serializer.fromJson<int>(json['id']),
      updated_at: serializer.fromJson<DateTime>(json['updated_at']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'client_a': serializer.toJson<String>(client_a),
      'client_content': serializer.toJson<String>(client_content),
      'created_at': serializer.toJson<DateTime>(created_at),
      'id': serializer.toJson<int>(id),
      'updated_at': serializer.toJson<DateTime>(updated_at),
    };
  }

  Test copyWith(
          {String? client_a,
          String? client_content,
          DateTime? created_at,
          int? id,
          DateTime? updated_at}) =>
      Test(
        client_a: client_a ?? this.client_a,
        client_content: client_content ?? this.client_content,
        created_at: created_at ?? this.created_at,
        id: id ?? this.id,
        updated_at: updated_at ?? this.updated_at,
      );
  @override
  String toString() {
    return (StringBuffer('Test(')
          ..write('client_a: $client_a, ')
          ..write('client_content: $client_content, ')
          ..write('created_at: $created_at, ')
          ..write('id: $id, ')
          ..write('updated_at: $updated_at')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(client_a, client_content, created_at, id, updated_at);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Test &&
          other.client_a == this.client_a &&
          other.client_content == this.client_content &&
          other.created_at == this.created_at &&
          other.id == this.id &&
          other.updated_at == this.updated_at);
}

class TestsCompanion extends UpdateCompanion<Test> {
  Value<String> client_a;
  Value<String> client_content;
  Value<DateTime> created_at;
  Value<int> id;
  Value<DateTime> updated_at;
  TestsCompanion({
    this.client_a = const Value.absent(),
    this.client_content = const Value.absent(),
    this.created_at = const Value.absent(),
    this.id = const Value.absent(),
    this.updated_at = const Value.absent(),
  });
  TestsCompanion.insert({
    required String client_a,
    required String client_content,
    required DateTime created_at,
    this.id = const Value.absent(),
    required DateTime updated_at,
  })  : client_a = Value(client_a),
        client_content = Value(client_content),
        created_at = Value(created_at),
        updated_at = Value(updated_at);
  static Insertable<Test> custom({
    Expression<String>? client_a,
    Expression<String>? client_content,
    Expression<DateTime>? created_at,
    Expression<int>? id,
    Expression<DateTime>? updated_at,
  }) {
    return RawValuesInsertable({
      if (client_a != null) 'client_a': client_a,
      if (client_content != null) 'client_content': client_content,
      if (created_at != null) 'created_at': created_at,
      if (id != null) 'id': id,
      if (updated_at != null) 'updated_at': updated_at,
    });
  }

  TestsCompanion copyWith(
      {Value<String>? client_a,
      Value<String>? client_content,
      Value<DateTime>? created_at,
      Value<int>? id,
      Value<DateTime>? updated_at}) {
    return TestsCompanion(
      client_a: client_a ?? this.client_a,
      client_content: client_content ?? this.client_content,
      created_at: created_at ?? this.created_at,
      id: id ?? this.id,
      updated_at: updated_at ?? this.updated_at,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (client_a.present) {
      map['client_a'] = Variable<String>(client_a.value);
    }
    if (client_content.present) {
      map['client_content'] = Variable<String>(client_content.value);
    }
    if (created_at.present) {
      map['created_at'] = Variable<DateTime>(created_at.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (updated_at.present) {
      map['updated_at'] = Variable<DateTime>(updated_at.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('TestsCompanion(')
          ..write('client_a: $client_a, ')
          ..write('client_content: $client_content, ')
          ..write('created_at: $created_at, ')
          ..write('id: $id, ')
          ..write('updated_at: $updated_at')
          ..write(')'))
        .toString();
  }
}

class $FragmentsTable extends Fragments
    with TableInfo<$FragmentsTable, Fragment> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $FragmentsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _be_sep_publishMeta =
      const VerificationMeta('be_sep_publish');
  @override
  late final GeneratedColumn<bool> be_sep_publish =
      GeneratedColumn<bool>('be_sep_publish', aliasedName, false,
          type: DriftSqlType.bool,
          requiredDuringInsert: true,
          defaultConstraints: GeneratedColumn.constraintsDependsOnDialect({
            SqlDialect.sqlite: 'CHECK ("be_sep_publish" IN (0, 1))',
            SqlDialect.mysql: '',
            SqlDialect.postgres: '',
          }));
  static const VerificationMeta _client_be_selectedMeta =
      const VerificationMeta('client_be_selected');
  @override
  late final GeneratedColumn<bool> client_be_selected =
      GeneratedColumn<bool>('client_be_selected', aliasedName, false,
          type: DriftSqlType.bool,
          requiredDuringInsert: true,
          defaultConstraints: GeneratedColumn.constraintsDependsOnDialect({
            SqlDialect.sqlite: 'CHECK ("client_be_selected" IN (0, 1))',
            SqlDialect.mysql: '',
            SqlDialect.postgres: '',
          }));
  static const VerificationMeta _contentMeta =
      const VerificationMeta('content');
  @override
  late final GeneratedColumn<String> content = GeneratedColumn<String>(
      'content', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _creator_user_idMeta =
      const VerificationMeta('creator_user_id');
  @override
  late final GeneratedColumn<int> creator_user_id = GeneratedColumn<int>(
      'creator_user_id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _father_fragment_idMeta =
      const VerificationMeta('father_fragment_id');
  @override
  late final GeneratedColumn<String> father_fragment_id =
      GeneratedColumn<String>('father_fragment_id', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _titleMeta = const VerificationMeta('title');
  @override
  late final GeneratedColumn<String> title = GeneratedColumn<String>(
      'title', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _created_atMeta =
      const VerificationMeta('created_at');
  @override
  late final GeneratedColumn<DateTime> created_at = GeneratedColumn<DateTime>(
      'created_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _updated_atMeta =
      const VerificationMeta('updated_at');
  @override
  late final GeneratedColumn<DateTime> updated_at = GeneratedColumn<DateTime>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns => [
        be_sep_publish,
        client_be_selected,
        content,
        creator_user_id,
        father_fragment_id,
        title,
        created_at,
        id,
        updated_at
      ];
  @override
  String get aliasedName => _alias ?? 'fragments';
  @override
  String get actualTableName => 'fragments';
  @override
  VerificationContext validateIntegrity(Insertable<Fragment> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('be_sep_publish')) {
      context.handle(
          _be_sep_publishMeta,
          be_sep_publish.isAcceptableOrUnknown(
              data['be_sep_publish']!, _be_sep_publishMeta));
    } else if (isInserting) {
      context.missing(_be_sep_publishMeta);
    }
    if (data.containsKey('client_be_selected')) {
      context.handle(
          _client_be_selectedMeta,
          client_be_selected.isAcceptableOrUnknown(
              data['client_be_selected']!, _client_be_selectedMeta));
    } else if (isInserting) {
      context.missing(_client_be_selectedMeta);
    }
    if (data.containsKey('content')) {
      context.handle(_contentMeta,
          content.isAcceptableOrUnknown(data['content']!, _contentMeta));
    } else if (isInserting) {
      context.missing(_contentMeta);
    }
    if (data.containsKey('creator_user_id')) {
      context.handle(
          _creator_user_idMeta,
          creator_user_id.isAcceptableOrUnknown(
              data['creator_user_id']!, _creator_user_idMeta));
    } else if (isInserting) {
      context.missing(_creator_user_idMeta);
    }
    if (data.containsKey('father_fragment_id')) {
      context.handle(
          _father_fragment_idMeta,
          father_fragment_id.isAcceptableOrUnknown(
              data['father_fragment_id']!, _father_fragment_idMeta));
    }
    if (data.containsKey('title')) {
      context.handle(
          _titleMeta, title.isAcceptableOrUnknown(data['title']!, _titleMeta));
    } else if (isInserting) {
      context.missing(_titleMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(
          _created_atMeta,
          created_at.isAcceptableOrUnknown(
              data['created_at']!, _created_atMeta));
    } else if (isInserting) {
      context.missing(_created_atMeta);
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
          _updated_atMeta,
          updated_at.isAcceptableOrUnknown(
              data['updated_at']!, _updated_atMeta));
    } else if (isInserting) {
      context.missing(_updated_atMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Fragment map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Fragment(
      be_sep_publish: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}be_sep_publish'])!,
      client_be_selected: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}client_be_selected'])!,
      content: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}content'])!,
      creator_user_id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}creator_user_id'])!,
      father_fragment_id: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}father_fragment_id']),
      title: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}title'])!,
      created_at: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_at'])!,
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id'])!,
      updated_at: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}updated_at'])!,
    );
  }

  @override
  $FragmentsTable createAlias(String alias) {
    return $FragmentsTable(attachedDatabase, alias);
  }

  @override
  bool get withoutRowId => true;
}

class Fragment extends DataClass implements Insertable<Fragment> {
  bool be_sep_publish;
  bool client_be_selected;
  String content;
  int creator_user_id;
  String? father_fragment_id;
  String title;
  DateTime created_at;
  String id;
  DateTime updated_at;
  Fragment(
      {required this.be_sep_publish,
      required this.client_be_selected,
      required this.content,
      required this.creator_user_id,
      this.father_fragment_id,
      required this.title,
      required this.created_at,
      required this.id,
      required this.updated_at});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['be_sep_publish'] = Variable<bool>(be_sep_publish);
    map['client_be_selected'] = Variable<bool>(client_be_selected);
    map['content'] = Variable<String>(content);
    map['creator_user_id'] = Variable<int>(creator_user_id);
    if (!nullToAbsent || father_fragment_id != null) {
      map['father_fragment_id'] = Variable<String>(father_fragment_id);
    }
    map['title'] = Variable<String>(title);
    map['created_at'] = Variable<DateTime>(created_at);
    map['id'] = Variable<String>(id);
    map['updated_at'] = Variable<DateTime>(updated_at);
    return map;
  }

  FragmentsCompanion toCompanion(bool nullToAbsent) {
    return FragmentsCompanion(
      be_sep_publish: Value(be_sep_publish),
      client_be_selected: Value(client_be_selected),
      content: Value(content),
      creator_user_id: Value(creator_user_id),
      father_fragment_id: father_fragment_id == null && nullToAbsent
          ? const Value.absent()
          : Value(father_fragment_id),
      title: Value(title),
      created_at: Value(created_at),
      id: Value(id),
      updated_at: Value(updated_at),
    );
  }

  factory Fragment.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Fragment(
      be_sep_publish: serializer.fromJson<bool>(json['be_sep_publish']),
      client_be_selected: serializer.fromJson<bool>(json['client_be_selected']),
      content: serializer.fromJson<String>(json['content']),
      creator_user_id: serializer.fromJson<int>(json['creator_user_id']),
      father_fragment_id:
          serializer.fromJson<String?>(json['father_fragment_id']),
      title: serializer.fromJson<String>(json['title']),
      created_at: serializer.fromJson<DateTime>(json['created_at']),
      id: serializer.fromJson<String>(json['id']),
      updated_at: serializer.fromJson<DateTime>(json['updated_at']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'be_sep_publish': serializer.toJson<bool>(be_sep_publish),
      'client_be_selected': serializer.toJson<bool>(client_be_selected),
      'content': serializer.toJson<String>(content),
      'creator_user_id': serializer.toJson<int>(creator_user_id),
      'father_fragment_id': serializer.toJson<String?>(father_fragment_id),
      'title': serializer.toJson<String>(title),
      'created_at': serializer.toJson<DateTime>(created_at),
      'id': serializer.toJson<String>(id),
      'updated_at': serializer.toJson<DateTime>(updated_at),
    };
  }

  Fragment copyWith(
          {bool? be_sep_publish,
          bool? client_be_selected,
          String? content,
          int? creator_user_id,
          Value<String?> father_fragment_id = const Value.absent(),
          String? title,
          DateTime? created_at,
          String? id,
          DateTime? updated_at}) =>
      Fragment(
        be_sep_publish: be_sep_publish ?? this.be_sep_publish,
        client_be_selected: client_be_selected ?? this.client_be_selected,
        content: content ?? this.content,
        creator_user_id: creator_user_id ?? this.creator_user_id,
        father_fragment_id: father_fragment_id.present
            ? father_fragment_id.value
            : this.father_fragment_id,
        title: title ?? this.title,
        created_at: created_at ?? this.created_at,
        id: id ?? this.id,
        updated_at: updated_at ?? this.updated_at,
      );
  @override
  String toString() {
    return (StringBuffer('Fragment(')
          ..write('be_sep_publish: $be_sep_publish, ')
          ..write('client_be_selected: $client_be_selected, ')
          ..write('content: $content, ')
          ..write('creator_user_id: $creator_user_id, ')
          ..write('father_fragment_id: $father_fragment_id, ')
          ..write('title: $title, ')
          ..write('created_at: $created_at, ')
          ..write('id: $id, ')
          ..write('updated_at: $updated_at')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(be_sep_publish, client_be_selected, content,
      creator_user_id, father_fragment_id, title, created_at, id, updated_at);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Fragment &&
          other.be_sep_publish == this.be_sep_publish &&
          other.client_be_selected == this.client_be_selected &&
          other.content == this.content &&
          other.creator_user_id == this.creator_user_id &&
          other.father_fragment_id == this.father_fragment_id &&
          other.title == this.title &&
          other.created_at == this.created_at &&
          other.id == this.id &&
          other.updated_at == this.updated_at);
}

class FragmentsCompanion extends UpdateCompanion<Fragment> {
  Value<bool> be_sep_publish;
  Value<bool> client_be_selected;
  Value<String> content;
  Value<int> creator_user_id;
  Value<String?> father_fragment_id;
  Value<String> title;
  Value<DateTime> created_at;
  Value<String> id;
  Value<DateTime> updated_at;
  FragmentsCompanion({
    this.be_sep_publish = const Value.absent(),
    this.client_be_selected = const Value.absent(),
    this.content = const Value.absent(),
    this.creator_user_id = const Value.absent(),
    this.father_fragment_id = const Value.absent(),
    this.title = const Value.absent(),
    this.created_at = const Value.absent(),
    this.id = const Value.absent(),
    this.updated_at = const Value.absent(),
  });
  FragmentsCompanion.insert({
    required bool be_sep_publish,
    required bool client_be_selected,
    required String content,
    required int creator_user_id,
    this.father_fragment_id = const Value.absent(),
    required String title,
    required DateTime created_at,
    required String id,
    required DateTime updated_at,
  })  : be_sep_publish = Value(be_sep_publish),
        client_be_selected = Value(client_be_selected),
        content = Value(content),
        creator_user_id = Value(creator_user_id),
        title = Value(title),
        created_at = Value(created_at),
        id = Value(id),
        updated_at = Value(updated_at);
  static Insertable<Fragment> custom({
    Expression<bool>? be_sep_publish,
    Expression<bool>? client_be_selected,
    Expression<String>? content,
    Expression<int>? creator_user_id,
    Expression<String>? father_fragment_id,
    Expression<String>? title,
    Expression<DateTime>? created_at,
    Expression<String>? id,
    Expression<DateTime>? updated_at,
  }) {
    return RawValuesInsertable({
      if (be_sep_publish != null) 'be_sep_publish': be_sep_publish,
      if (client_be_selected != null) 'client_be_selected': client_be_selected,
      if (content != null) 'content': content,
      if (creator_user_id != null) 'creator_user_id': creator_user_id,
      if (father_fragment_id != null) 'father_fragment_id': father_fragment_id,
      if (title != null) 'title': title,
      if (created_at != null) 'created_at': created_at,
      if (id != null) 'id': id,
      if (updated_at != null) 'updated_at': updated_at,
    });
  }

  FragmentsCompanion copyWith(
      {Value<bool>? be_sep_publish,
      Value<bool>? client_be_selected,
      Value<String>? content,
      Value<int>? creator_user_id,
      Value<String?>? father_fragment_id,
      Value<String>? title,
      Value<DateTime>? created_at,
      Value<String>? id,
      Value<DateTime>? updated_at}) {
    return FragmentsCompanion(
      be_sep_publish: be_sep_publish ?? this.be_sep_publish,
      client_be_selected: client_be_selected ?? this.client_be_selected,
      content: content ?? this.content,
      creator_user_id: creator_user_id ?? this.creator_user_id,
      father_fragment_id: father_fragment_id ?? this.father_fragment_id,
      title: title ?? this.title,
      created_at: created_at ?? this.created_at,
      id: id ?? this.id,
      updated_at: updated_at ?? this.updated_at,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (be_sep_publish.present) {
      map['be_sep_publish'] = Variable<bool>(be_sep_publish.value);
    }
    if (client_be_selected.present) {
      map['client_be_selected'] = Variable<bool>(client_be_selected.value);
    }
    if (content.present) {
      map['content'] = Variable<String>(content.value);
    }
    if (creator_user_id.present) {
      map['creator_user_id'] = Variable<int>(creator_user_id.value);
    }
    if (father_fragment_id.present) {
      map['father_fragment_id'] = Variable<String>(father_fragment_id.value);
    }
    if (title.present) {
      map['title'] = Variable<String>(title.value);
    }
    if (created_at.present) {
      map['created_at'] = Variable<DateTime>(created_at.value);
    }
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (updated_at.present) {
      map['updated_at'] = Variable<DateTime>(updated_at.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('FragmentsCompanion(')
          ..write('be_sep_publish: $be_sep_publish, ')
          ..write('client_be_selected: $client_be_selected, ')
          ..write('content: $content, ')
          ..write('creator_user_id: $creator_user_id, ')
          ..write('father_fragment_id: $father_fragment_id, ')
          ..write('title: $title, ')
          ..write('created_at: $created_at, ')
          ..write('id: $id, ')
          ..write('updated_at: $updated_at')
          ..write(')'))
        .toString();
  }
}

class $MemoryGroupsTable extends MemoryGroups
    with TableInfo<$MemoryGroupsTable, MemoryGroup> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $MemoryGroupsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _creator_user_idMeta =
      const VerificationMeta('creator_user_id');
  @override
  late final GeneratedColumn<int> creator_user_id = GeneratedColumn<int>(
      'creator_user_id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _memory_model_idMeta =
      const VerificationMeta('memory_model_id');
  @override
  late final GeneratedColumn<String> memory_model_id = GeneratedColumn<String>(
      'memory_model_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _new_display_orderMeta =
      const VerificationMeta('new_display_order');
  @override
  late final GeneratedColumnWithTypeConverter<NewDisplayOrder, int>
      new_display_order = GeneratedColumn<int>(
              'new_display_order', aliasedName, false,
              type: DriftSqlType.int, requiredDuringInsert: true)
          .withConverter<NewDisplayOrder>(
              $MemoryGroupsTable.$converternew_display_order);
  static const VerificationMeta _new_review_display_orderMeta =
      const VerificationMeta('new_review_display_order');
  @override
  late final GeneratedColumnWithTypeConverter<NewReviewDisplayOrder, int>
      new_review_display_order = GeneratedColumn<int>(
              'new_review_display_order', aliasedName, false,
              type: DriftSqlType.int, requiredDuringInsert: true)
          .withConverter<NewReviewDisplayOrder>(
              $MemoryGroupsTable.$converternew_review_display_order);
  static const VerificationMeta _review_display_orderMeta =
      const VerificationMeta('review_display_order');
  @override
  late final GeneratedColumnWithTypeConverter<ReviewDisplayOrder, int>
      review_display_order = GeneratedColumn<int>(
              'review_display_order', aliasedName, false,
              type: DriftSqlType.int, requiredDuringInsert: true)
          .withConverter<ReviewDisplayOrder>(
              $MemoryGroupsTable.$converterreview_display_order);
  static const VerificationMeta _review_intervalMeta =
      const VerificationMeta('review_interval');
  @override
  late final GeneratedColumn<DateTime> review_interval =
      GeneratedColumn<DateTime>('review_interval', aliasedName, false,
          type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _start_timeMeta =
      const VerificationMeta('start_time');
  @override
  late final GeneratedColumn<DateTime> start_time = GeneratedColumn<DateTime>(
      'start_time', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _titleMeta = const VerificationMeta('title');
  @override
  late final GeneratedColumn<String> title = GeneratedColumn<String>(
      'title', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _will_new_learn_countMeta =
      const VerificationMeta('will_new_learn_count');
  @override
  late final GeneratedColumn<int> will_new_learn_count = GeneratedColumn<int>(
      'will_new_learn_count', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _created_atMeta =
      const VerificationMeta('created_at');
  @override
  late final GeneratedColumn<DateTime> created_at = GeneratedColumn<DateTime>(
      'created_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _updated_atMeta =
      const VerificationMeta('updated_at');
  @override
  late final GeneratedColumn<DateTime> updated_at = GeneratedColumn<DateTime>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns => [
        creator_user_id,
        memory_model_id,
        new_display_order,
        new_review_display_order,
        review_display_order,
        review_interval,
        start_time,
        title,
        will_new_learn_count,
        created_at,
        id,
        updated_at
      ];
  @override
  String get aliasedName => _alias ?? 'memory_groups';
  @override
  String get actualTableName => 'memory_groups';
  @override
  VerificationContext validateIntegrity(Insertable<MemoryGroup> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('creator_user_id')) {
      context.handle(
          _creator_user_idMeta,
          creator_user_id.isAcceptableOrUnknown(
              data['creator_user_id']!, _creator_user_idMeta));
    } else if (isInserting) {
      context.missing(_creator_user_idMeta);
    }
    if (data.containsKey('memory_model_id')) {
      context.handle(
          _memory_model_idMeta,
          memory_model_id.isAcceptableOrUnknown(
              data['memory_model_id']!, _memory_model_idMeta));
    }
    context.handle(_new_display_orderMeta, const VerificationResult.success());
    context.handle(
        _new_review_display_orderMeta, const VerificationResult.success());
    context.handle(
        _review_display_orderMeta, const VerificationResult.success());
    if (data.containsKey('review_interval')) {
      context.handle(
          _review_intervalMeta,
          review_interval.isAcceptableOrUnknown(
              data['review_interval']!, _review_intervalMeta));
    } else if (isInserting) {
      context.missing(_review_intervalMeta);
    }
    if (data.containsKey('start_time')) {
      context.handle(
          _start_timeMeta,
          start_time.isAcceptableOrUnknown(
              data['start_time']!, _start_timeMeta));
    }
    if (data.containsKey('title')) {
      context.handle(
          _titleMeta, title.isAcceptableOrUnknown(data['title']!, _titleMeta));
    } else if (isInserting) {
      context.missing(_titleMeta);
    }
    if (data.containsKey('will_new_learn_count')) {
      context.handle(
          _will_new_learn_countMeta,
          will_new_learn_count.isAcceptableOrUnknown(
              data['will_new_learn_count']!, _will_new_learn_countMeta));
    } else if (isInserting) {
      context.missing(_will_new_learn_countMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(
          _created_atMeta,
          created_at.isAcceptableOrUnknown(
              data['created_at']!, _created_atMeta));
    } else if (isInserting) {
      context.missing(_created_atMeta);
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
          _updated_atMeta,
          updated_at.isAcceptableOrUnknown(
              data['updated_at']!, _updated_atMeta));
    } else if (isInserting) {
      context.missing(_updated_atMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  MemoryGroup map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return MemoryGroup(
      creator_user_id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}creator_user_id'])!,
      memory_model_id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}memory_model_id']),
      new_display_order: $MemoryGroupsTable.$converternew_display_order.fromSql(
          attachedDatabase.typeMapping.read(
              DriftSqlType.int, data['${effectivePrefix}new_display_order'])!),
      new_review_display_order: $MemoryGroupsTable
          .$converternew_review_display_order
          .fromSql(attachedDatabase.typeMapping.read(DriftSqlType.int,
              data['${effectivePrefix}new_review_display_order'])!),
      review_display_order: $MemoryGroupsTable.$converterreview_display_order
          .fromSql(attachedDatabase.typeMapping.read(DriftSqlType.int,
              data['${effectivePrefix}review_display_order'])!),
      review_interval: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}review_interval'])!,
      start_time: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}start_time']),
      title: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}title'])!,
      will_new_learn_count: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}will_new_learn_count'])!,
      created_at: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_at'])!,
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id'])!,
      updated_at: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}updated_at'])!,
    );
  }

  @override
  $MemoryGroupsTable createAlias(String alias) {
    return $MemoryGroupsTable(attachedDatabase, alias);
  }

  static JsonTypeConverter2<NewDisplayOrder, int, int>
      $converternew_display_order =
      const EnumIndexConverter<NewDisplayOrder>(NewDisplayOrder.values);
  static JsonTypeConverter2<NewReviewDisplayOrder, int, int>
      $converternew_review_display_order =
      const EnumIndexConverter<NewReviewDisplayOrder>(
          NewReviewDisplayOrder.values);
  static JsonTypeConverter2<ReviewDisplayOrder, int, int>
      $converterreview_display_order =
      const EnumIndexConverter<ReviewDisplayOrder>(ReviewDisplayOrder.values);
  @override
  bool get withoutRowId => true;
}

class MemoryGroup extends DataClass implements Insertable<MemoryGroup> {
  int creator_user_id;
  String? memory_model_id;
  NewDisplayOrder new_display_order;
  NewReviewDisplayOrder new_review_display_order;
  ReviewDisplayOrder review_display_order;
  DateTime review_interval;
  DateTime? start_time;
  String title;
  int will_new_learn_count;
  DateTime created_at;
  String id;
  DateTime updated_at;
  MemoryGroup(
      {required this.creator_user_id,
      this.memory_model_id,
      required this.new_display_order,
      required this.new_review_display_order,
      required this.review_display_order,
      required this.review_interval,
      this.start_time,
      required this.title,
      required this.will_new_learn_count,
      required this.created_at,
      required this.id,
      required this.updated_at});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['creator_user_id'] = Variable<int>(creator_user_id);
    if (!nullToAbsent || memory_model_id != null) {
      map['memory_model_id'] = Variable<String>(memory_model_id);
    }
    {
      final converter = $MemoryGroupsTable.$converternew_display_order;
      map['new_display_order'] =
          Variable<int>(converter.toSql(new_display_order));
    }
    {
      final converter = $MemoryGroupsTable.$converternew_review_display_order;
      map['new_review_display_order'] =
          Variable<int>(converter.toSql(new_review_display_order));
    }
    {
      final converter = $MemoryGroupsTable.$converterreview_display_order;
      map['review_display_order'] =
          Variable<int>(converter.toSql(review_display_order));
    }
    map['review_interval'] = Variable<DateTime>(review_interval);
    if (!nullToAbsent || start_time != null) {
      map['start_time'] = Variable<DateTime>(start_time);
    }
    map['title'] = Variable<String>(title);
    map['will_new_learn_count'] = Variable<int>(will_new_learn_count);
    map['created_at'] = Variable<DateTime>(created_at);
    map['id'] = Variable<String>(id);
    map['updated_at'] = Variable<DateTime>(updated_at);
    return map;
  }

  MemoryGroupsCompanion toCompanion(bool nullToAbsent) {
    return MemoryGroupsCompanion(
      creator_user_id: Value(creator_user_id),
      memory_model_id: memory_model_id == null && nullToAbsent
          ? const Value.absent()
          : Value(memory_model_id),
      new_display_order: Value(new_display_order),
      new_review_display_order: Value(new_review_display_order),
      review_display_order: Value(review_display_order),
      review_interval: Value(review_interval),
      start_time: start_time == null && nullToAbsent
          ? const Value.absent()
          : Value(start_time),
      title: Value(title),
      will_new_learn_count: Value(will_new_learn_count),
      created_at: Value(created_at),
      id: Value(id),
      updated_at: Value(updated_at),
    );
  }

  factory MemoryGroup.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return MemoryGroup(
      creator_user_id: serializer.fromJson<int>(json['creator_user_id']),
      memory_model_id: serializer.fromJson<String?>(json['memory_model_id']),
      new_display_order: $MemoryGroupsTable.$converternew_display_order
          .fromJson(serializer.fromJson<int>(json['new_display_order'])),
      new_review_display_order: $MemoryGroupsTable
          .$converternew_review_display_order
          .fromJson(serializer.fromJson<int>(json['new_review_display_order'])),
      review_display_order: $MemoryGroupsTable.$converterreview_display_order
          .fromJson(serializer.fromJson<int>(json['review_display_order'])),
      review_interval: serializer.fromJson<DateTime>(json['review_interval']),
      start_time: serializer.fromJson<DateTime?>(json['start_time']),
      title: serializer.fromJson<String>(json['title']),
      will_new_learn_count:
          serializer.fromJson<int>(json['will_new_learn_count']),
      created_at: serializer.fromJson<DateTime>(json['created_at']),
      id: serializer.fromJson<String>(json['id']),
      updated_at: serializer.fromJson<DateTime>(json['updated_at']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'creator_user_id': serializer.toJson<int>(creator_user_id),
      'memory_model_id': serializer.toJson<String?>(memory_model_id),
      'new_display_order': serializer.toJson<int>($MemoryGroupsTable
          .$converternew_display_order
          .toJson(new_display_order)),
      'new_review_display_order': serializer.toJson<int>($MemoryGroupsTable
          .$converternew_review_display_order
          .toJson(new_review_display_order)),
      'review_display_order': serializer.toJson<int>($MemoryGroupsTable
          .$converterreview_display_order
          .toJson(review_display_order)),
      'review_interval': serializer.toJson<DateTime>(review_interval),
      'start_time': serializer.toJson<DateTime?>(start_time),
      'title': serializer.toJson<String>(title),
      'will_new_learn_count': serializer.toJson<int>(will_new_learn_count),
      'created_at': serializer.toJson<DateTime>(created_at),
      'id': serializer.toJson<String>(id),
      'updated_at': serializer.toJson<DateTime>(updated_at),
    };
  }

  MemoryGroup copyWith(
          {int? creator_user_id,
          Value<String?> memory_model_id = const Value.absent(),
          NewDisplayOrder? new_display_order,
          NewReviewDisplayOrder? new_review_display_order,
          ReviewDisplayOrder? review_display_order,
          DateTime? review_interval,
          Value<DateTime?> start_time = const Value.absent(),
          String? title,
          int? will_new_learn_count,
          DateTime? created_at,
          String? id,
          DateTime? updated_at}) =>
      MemoryGroup(
        creator_user_id: creator_user_id ?? this.creator_user_id,
        memory_model_id: memory_model_id.present
            ? memory_model_id.value
            : this.memory_model_id,
        new_display_order: new_display_order ?? this.new_display_order,
        new_review_display_order:
            new_review_display_order ?? this.new_review_display_order,
        review_display_order: review_display_order ?? this.review_display_order,
        review_interval: review_interval ?? this.review_interval,
        start_time: start_time.present ? start_time.value : this.start_time,
        title: title ?? this.title,
        will_new_learn_count: will_new_learn_count ?? this.will_new_learn_count,
        created_at: created_at ?? this.created_at,
        id: id ?? this.id,
        updated_at: updated_at ?? this.updated_at,
      );
  @override
  String toString() {
    return (StringBuffer('MemoryGroup(')
          ..write('creator_user_id: $creator_user_id, ')
          ..write('memory_model_id: $memory_model_id, ')
          ..write('new_display_order: $new_display_order, ')
          ..write('new_review_display_order: $new_review_display_order, ')
          ..write('review_display_order: $review_display_order, ')
          ..write('review_interval: $review_interval, ')
          ..write('start_time: $start_time, ')
          ..write('title: $title, ')
          ..write('will_new_learn_count: $will_new_learn_count, ')
          ..write('created_at: $created_at, ')
          ..write('id: $id, ')
          ..write('updated_at: $updated_at')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      creator_user_id,
      memory_model_id,
      new_display_order,
      new_review_display_order,
      review_display_order,
      review_interval,
      start_time,
      title,
      will_new_learn_count,
      created_at,
      id,
      updated_at);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is MemoryGroup &&
          other.creator_user_id == this.creator_user_id &&
          other.memory_model_id == this.memory_model_id &&
          other.new_display_order == this.new_display_order &&
          other.new_review_display_order == this.new_review_display_order &&
          other.review_display_order == this.review_display_order &&
          other.review_interval == this.review_interval &&
          other.start_time == this.start_time &&
          other.title == this.title &&
          other.will_new_learn_count == this.will_new_learn_count &&
          other.created_at == this.created_at &&
          other.id == this.id &&
          other.updated_at == this.updated_at);
}

class MemoryGroupsCompanion extends UpdateCompanion<MemoryGroup> {
  Value<int> creator_user_id;
  Value<String?> memory_model_id;
  Value<NewDisplayOrder> new_display_order;
  Value<NewReviewDisplayOrder> new_review_display_order;
  Value<ReviewDisplayOrder> review_display_order;
  Value<DateTime> review_interval;
  Value<DateTime?> start_time;
  Value<String> title;
  Value<int> will_new_learn_count;
  Value<DateTime> created_at;
  Value<String> id;
  Value<DateTime> updated_at;
  MemoryGroupsCompanion({
    this.creator_user_id = const Value.absent(),
    this.memory_model_id = const Value.absent(),
    this.new_display_order = const Value.absent(),
    this.new_review_display_order = const Value.absent(),
    this.review_display_order = const Value.absent(),
    this.review_interval = const Value.absent(),
    this.start_time = const Value.absent(),
    this.title = const Value.absent(),
    this.will_new_learn_count = const Value.absent(),
    this.created_at = const Value.absent(),
    this.id = const Value.absent(),
    this.updated_at = const Value.absent(),
  });
  MemoryGroupsCompanion.insert({
    required int creator_user_id,
    this.memory_model_id = const Value.absent(),
    required NewDisplayOrder new_display_order,
    required NewReviewDisplayOrder new_review_display_order,
    required ReviewDisplayOrder review_display_order,
    required DateTime review_interval,
    this.start_time = const Value.absent(),
    required String title,
    required int will_new_learn_count,
    required DateTime created_at,
    required String id,
    required DateTime updated_at,
  })  : creator_user_id = Value(creator_user_id),
        new_display_order = Value(new_display_order),
        new_review_display_order = Value(new_review_display_order),
        review_display_order = Value(review_display_order),
        review_interval = Value(review_interval),
        title = Value(title),
        will_new_learn_count = Value(will_new_learn_count),
        created_at = Value(created_at),
        id = Value(id),
        updated_at = Value(updated_at);
  static Insertable<MemoryGroup> custom({
    Expression<int>? creator_user_id,
    Expression<String>? memory_model_id,
    Expression<int>? new_display_order,
    Expression<int>? new_review_display_order,
    Expression<int>? review_display_order,
    Expression<DateTime>? review_interval,
    Expression<DateTime>? start_time,
    Expression<String>? title,
    Expression<int>? will_new_learn_count,
    Expression<DateTime>? created_at,
    Expression<String>? id,
    Expression<DateTime>? updated_at,
  }) {
    return RawValuesInsertable({
      if (creator_user_id != null) 'creator_user_id': creator_user_id,
      if (memory_model_id != null) 'memory_model_id': memory_model_id,
      if (new_display_order != null) 'new_display_order': new_display_order,
      if (new_review_display_order != null)
        'new_review_display_order': new_review_display_order,
      if (review_display_order != null)
        'review_display_order': review_display_order,
      if (review_interval != null) 'review_interval': review_interval,
      if (start_time != null) 'start_time': start_time,
      if (title != null) 'title': title,
      if (will_new_learn_count != null)
        'will_new_learn_count': will_new_learn_count,
      if (created_at != null) 'created_at': created_at,
      if (id != null) 'id': id,
      if (updated_at != null) 'updated_at': updated_at,
    });
  }

  MemoryGroupsCompanion copyWith(
      {Value<int>? creator_user_id,
      Value<String?>? memory_model_id,
      Value<NewDisplayOrder>? new_display_order,
      Value<NewReviewDisplayOrder>? new_review_display_order,
      Value<ReviewDisplayOrder>? review_display_order,
      Value<DateTime>? review_interval,
      Value<DateTime?>? start_time,
      Value<String>? title,
      Value<int>? will_new_learn_count,
      Value<DateTime>? created_at,
      Value<String>? id,
      Value<DateTime>? updated_at}) {
    return MemoryGroupsCompanion(
      creator_user_id: creator_user_id ?? this.creator_user_id,
      memory_model_id: memory_model_id ?? this.memory_model_id,
      new_display_order: new_display_order ?? this.new_display_order,
      new_review_display_order:
          new_review_display_order ?? this.new_review_display_order,
      review_display_order: review_display_order ?? this.review_display_order,
      review_interval: review_interval ?? this.review_interval,
      start_time: start_time ?? this.start_time,
      title: title ?? this.title,
      will_new_learn_count: will_new_learn_count ?? this.will_new_learn_count,
      created_at: created_at ?? this.created_at,
      id: id ?? this.id,
      updated_at: updated_at ?? this.updated_at,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (creator_user_id.present) {
      map['creator_user_id'] = Variable<int>(creator_user_id.value);
    }
    if (memory_model_id.present) {
      map['memory_model_id'] = Variable<String>(memory_model_id.value);
    }
    if (new_display_order.present) {
      final converter = $MemoryGroupsTable.$converternew_display_order;
      map['new_display_order'] =
          Variable<int>(converter.toSql(new_display_order.value));
    }
    if (new_review_display_order.present) {
      final converter = $MemoryGroupsTable.$converternew_review_display_order;
      map['new_review_display_order'] =
          Variable<int>(converter.toSql(new_review_display_order.value));
    }
    if (review_display_order.present) {
      final converter = $MemoryGroupsTable.$converterreview_display_order;
      map['review_display_order'] =
          Variable<int>(converter.toSql(review_display_order.value));
    }
    if (review_interval.present) {
      map['review_interval'] = Variable<DateTime>(review_interval.value);
    }
    if (start_time.present) {
      map['start_time'] = Variable<DateTime>(start_time.value);
    }
    if (title.present) {
      map['title'] = Variable<String>(title.value);
    }
    if (will_new_learn_count.present) {
      map['will_new_learn_count'] = Variable<int>(will_new_learn_count.value);
    }
    if (created_at.present) {
      map['created_at'] = Variable<DateTime>(created_at.value);
    }
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (updated_at.present) {
      map['updated_at'] = Variable<DateTime>(updated_at.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('MemoryGroupsCompanion(')
          ..write('creator_user_id: $creator_user_id, ')
          ..write('memory_model_id: $memory_model_id, ')
          ..write('new_display_order: $new_display_order, ')
          ..write('new_review_display_order: $new_review_display_order, ')
          ..write('review_display_order: $review_display_order, ')
          ..write('review_interval: $review_interval, ')
          ..write('start_time: $start_time, ')
          ..write('title: $title, ')
          ..write('will_new_learn_count: $will_new_learn_count, ')
          ..write('created_at: $created_at, ')
          ..write('id: $id, ')
          ..write('updated_at: $updated_at')
          ..write(')'))
        .toString();
  }
}

class $MemoryModelsTable extends MemoryModels
    with TableInfo<$MemoryModelsTable, MemoryModel> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $MemoryModelsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _button_algorithm_aMeta =
      const VerificationMeta('button_algorithm_a');
  @override
  late final GeneratedColumn<String> button_algorithm_a =
      GeneratedColumn<String>('button_algorithm_a', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _button_algorithm_bMeta =
      const VerificationMeta('button_algorithm_b');
  @override
  late final GeneratedColumn<String> button_algorithm_b =
      GeneratedColumn<String>('button_algorithm_b', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _button_algorithm_cMeta =
      const VerificationMeta('button_algorithm_c');
  @override
  late final GeneratedColumn<String> button_algorithm_c =
      GeneratedColumn<String>('button_algorithm_c', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _button_algorithm_remarkMeta =
      const VerificationMeta('button_algorithm_remark');
  @override
  late final GeneratedColumn<String> button_algorithm_remark =
      GeneratedColumn<String>('button_algorithm_remark', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _button_algorithm_usage_statusMeta =
      const VerificationMeta('button_algorithm_usage_status');
  @override
  late final GeneratedColumnWithTypeConverter<AlgorithmUsageStatus, int>
      button_algorithm_usage_status = GeneratedColumn<int>(
              'button_algorithm_usage_status', aliasedName, false,
              type: DriftSqlType.int, requiredDuringInsert: true)
          .withConverter<AlgorithmUsageStatus>(
              $MemoryModelsTable.$converterbutton_algorithm_usage_status);
  static const VerificationMeta _creator_user_idMeta =
      const VerificationMeta('creator_user_id');
  @override
  late final GeneratedColumn<int> creator_user_id = GeneratedColumn<int>(
      'creator_user_id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _familiarity_algorithm_aMeta =
      const VerificationMeta('familiarity_algorithm_a');
  @override
  late final GeneratedColumn<String> familiarity_algorithm_a =
      GeneratedColumn<String>('familiarity_algorithm_a', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _familiarity_algorithm_bMeta =
      const VerificationMeta('familiarity_algorithm_b');
  @override
  late final GeneratedColumn<String> familiarity_algorithm_b =
      GeneratedColumn<String>('familiarity_algorithm_b', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _familiarity_algorithm_cMeta =
      const VerificationMeta('familiarity_algorithm_c');
  @override
  late final GeneratedColumn<String> familiarity_algorithm_c =
      GeneratedColumn<String>('familiarity_algorithm_c', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _familiarity_algorithm_remarkMeta =
      const VerificationMeta('familiarity_algorithm_remark');
  @override
  late final GeneratedColumn<String> familiarity_algorithm_remark =
      GeneratedColumn<String>('familiarity_algorithm_remark', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _familiarity_algorithm_usage_statusMeta =
      const VerificationMeta('familiarity_algorithm_usage_status');
  @override
  late final GeneratedColumnWithTypeConverter<AlgorithmUsageStatus, int>
      familiarity_algorithm_usage_status = GeneratedColumn<int>(
              'familiarity_algorithm_usage_status', aliasedName, false,
              type: DriftSqlType.int, requiredDuringInsert: true)
          .withConverter<AlgorithmUsageStatus>(
              $MemoryModelsTable.$converterfamiliarity_algorithm_usage_status);
  static const VerificationMeta _father_memory_model_idMeta =
      const VerificationMeta('father_memory_model_id');
  @override
  late final GeneratedColumn<String> father_memory_model_id =
      GeneratedColumn<String>('father_memory_model_id', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _next_time_algorithm_aMeta =
      const VerificationMeta('next_time_algorithm_a');
  @override
  late final GeneratedColumn<String> next_time_algorithm_a =
      GeneratedColumn<String>('next_time_algorithm_a', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _next_time_algorithm_bMeta =
      const VerificationMeta('next_time_algorithm_b');
  @override
  late final GeneratedColumn<String> next_time_algorithm_b =
      GeneratedColumn<String>('next_time_algorithm_b', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _next_time_algorithm_cMeta =
      const VerificationMeta('next_time_algorithm_c');
  @override
  late final GeneratedColumn<String> next_time_algorithm_c =
      GeneratedColumn<String>('next_time_algorithm_c', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _next_time_algorithm_remarkMeta =
      const VerificationMeta('next_time_algorithm_remark');
  @override
  late final GeneratedColumn<String> next_time_algorithm_remark =
      GeneratedColumn<String>('next_time_algorithm_remark', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _next_time_algorithm_usage_statusMeta =
      const VerificationMeta('next_time_algorithm_usage_status');
  @override
  late final GeneratedColumnWithTypeConverter<AlgorithmUsageStatus, int>
      next_time_algorithm_usage_status = GeneratedColumn<int>(
              'next_time_algorithm_usage_status', aliasedName, false,
              type: DriftSqlType.int, requiredDuringInsert: true)
          .withConverter<AlgorithmUsageStatus>(
              $MemoryModelsTable.$converternext_time_algorithm_usage_status);
  static const VerificationMeta _titleMeta = const VerificationMeta('title');
  @override
  late final GeneratedColumn<String> title = GeneratedColumn<String>(
      'title', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _created_atMeta =
      const VerificationMeta('created_at');
  @override
  late final GeneratedColumn<DateTime> created_at = GeneratedColumn<DateTime>(
      'created_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _updated_atMeta =
      const VerificationMeta('updated_at');
  @override
  late final GeneratedColumn<DateTime> updated_at = GeneratedColumn<DateTime>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns => [
        button_algorithm_a,
        button_algorithm_b,
        button_algorithm_c,
        button_algorithm_remark,
        button_algorithm_usage_status,
        creator_user_id,
        familiarity_algorithm_a,
        familiarity_algorithm_b,
        familiarity_algorithm_c,
        familiarity_algorithm_remark,
        familiarity_algorithm_usage_status,
        father_memory_model_id,
        next_time_algorithm_a,
        next_time_algorithm_b,
        next_time_algorithm_c,
        next_time_algorithm_remark,
        next_time_algorithm_usage_status,
        title,
        created_at,
        id,
        updated_at
      ];
  @override
  String get aliasedName => _alias ?? 'memory_models';
  @override
  String get actualTableName => 'memory_models';
  @override
  VerificationContext validateIntegrity(Insertable<MemoryModel> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('button_algorithm_a')) {
      context.handle(
          _button_algorithm_aMeta,
          button_algorithm_a.isAcceptableOrUnknown(
              data['button_algorithm_a']!, _button_algorithm_aMeta));
    }
    if (data.containsKey('button_algorithm_b')) {
      context.handle(
          _button_algorithm_bMeta,
          button_algorithm_b.isAcceptableOrUnknown(
              data['button_algorithm_b']!, _button_algorithm_bMeta));
    }
    if (data.containsKey('button_algorithm_c')) {
      context.handle(
          _button_algorithm_cMeta,
          button_algorithm_c.isAcceptableOrUnknown(
              data['button_algorithm_c']!, _button_algorithm_cMeta));
    }
    if (data.containsKey('button_algorithm_remark')) {
      context.handle(
          _button_algorithm_remarkMeta,
          button_algorithm_remark.isAcceptableOrUnknown(
              data['button_algorithm_remark']!, _button_algorithm_remarkMeta));
    }
    context.handle(
        _button_algorithm_usage_statusMeta, const VerificationResult.success());
    if (data.containsKey('creator_user_id')) {
      context.handle(
          _creator_user_idMeta,
          creator_user_id.isAcceptableOrUnknown(
              data['creator_user_id']!, _creator_user_idMeta));
    } else if (isInserting) {
      context.missing(_creator_user_idMeta);
    }
    if (data.containsKey('familiarity_algorithm_a')) {
      context.handle(
          _familiarity_algorithm_aMeta,
          familiarity_algorithm_a.isAcceptableOrUnknown(
              data['familiarity_algorithm_a']!, _familiarity_algorithm_aMeta));
    }
    if (data.containsKey('familiarity_algorithm_b')) {
      context.handle(
          _familiarity_algorithm_bMeta,
          familiarity_algorithm_b.isAcceptableOrUnknown(
              data['familiarity_algorithm_b']!, _familiarity_algorithm_bMeta));
    }
    if (data.containsKey('familiarity_algorithm_c')) {
      context.handle(
          _familiarity_algorithm_cMeta,
          familiarity_algorithm_c.isAcceptableOrUnknown(
              data['familiarity_algorithm_c']!, _familiarity_algorithm_cMeta));
    }
    if (data.containsKey('familiarity_algorithm_remark')) {
      context.handle(
          _familiarity_algorithm_remarkMeta,
          familiarity_algorithm_remark.isAcceptableOrUnknown(
              data['familiarity_algorithm_remark']!,
              _familiarity_algorithm_remarkMeta));
    }
    context.handle(_familiarity_algorithm_usage_statusMeta,
        const VerificationResult.success());
    if (data.containsKey('father_memory_model_id')) {
      context.handle(
          _father_memory_model_idMeta,
          father_memory_model_id.isAcceptableOrUnknown(
              data['father_memory_model_id']!, _father_memory_model_idMeta));
    }
    if (data.containsKey('next_time_algorithm_a')) {
      context.handle(
          _next_time_algorithm_aMeta,
          next_time_algorithm_a.isAcceptableOrUnknown(
              data['next_time_algorithm_a']!, _next_time_algorithm_aMeta));
    }
    if (data.containsKey('next_time_algorithm_b')) {
      context.handle(
          _next_time_algorithm_bMeta,
          next_time_algorithm_b.isAcceptableOrUnknown(
              data['next_time_algorithm_b']!, _next_time_algorithm_bMeta));
    }
    if (data.containsKey('next_time_algorithm_c')) {
      context.handle(
          _next_time_algorithm_cMeta,
          next_time_algorithm_c.isAcceptableOrUnknown(
              data['next_time_algorithm_c']!, _next_time_algorithm_cMeta));
    }
    if (data.containsKey('next_time_algorithm_remark')) {
      context.handle(
          _next_time_algorithm_remarkMeta,
          next_time_algorithm_remark.isAcceptableOrUnknown(
              data['next_time_algorithm_remark']!,
              _next_time_algorithm_remarkMeta));
    }
    context.handle(_next_time_algorithm_usage_statusMeta,
        const VerificationResult.success());
    if (data.containsKey('title')) {
      context.handle(
          _titleMeta, title.isAcceptableOrUnknown(data['title']!, _titleMeta));
    } else if (isInserting) {
      context.missing(_titleMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(
          _created_atMeta,
          created_at.isAcceptableOrUnknown(
              data['created_at']!, _created_atMeta));
    } else if (isInserting) {
      context.missing(_created_atMeta);
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
          _updated_atMeta,
          updated_at.isAcceptableOrUnknown(
              data['updated_at']!, _updated_atMeta));
    } else if (isInserting) {
      context.missing(_updated_atMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  MemoryModel map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return MemoryModel(
      button_algorithm_a: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}button_algorithm_a']),
      button_algorithm_b: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}button_algorithm_b']),
      button_algorithm_c: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}button_algorithm_c']),
      button_algorithm_remark: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}button_algorithm_remark']),
      button_algorithm_usage_status: $MemoryModelsTable
          .$converterbutton_algorithm_usage_status
          .fromSql(attachedDatabase.typeMapping.read(DriftSqlType.int,
              data['${effectivePrefix}button_algorithm_usage_status'])!),
      creator_user_id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}creator_user_id'])!,
      familiarity_algorithm_a: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}familiarity_algorithm_a']),
      familiarity_algorithm_b: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}familiarity_algorithm_b']),
      familiarity_algorithm_c: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}familiarity_algorithm_c']),
      familiarity_algorithm_remark: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}familiarity_algorithm_remark']),
      familiarity_algorithm_usage_status: $MemoryModelsTable
          .$converterfamiliarity_algorithm_usage_status
          .fromSql(attachedDatabase.typeMapping.read(DriftSqlType.int,
              data['${effectivePrefix}familiarity_algorithm_usage_status'])!),
      father_memory_model_id: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}father_memory_model_id']),
      next_time_algorithm_a: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}next_time_algorithm_a']),
      next_time_algorithm_b: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}next_time_algorithm_b']),
      next_time_algorithm_c: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}next_time_algorithm_c']),
      next_time_algorithm_remark: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}next_time_algorithm_remark']),
      next_time_algorithm_usage_status: $MemoryModelsTable
          .$converternext_time_algorithm_usage_status
          .fromSql(attachedDatabase.typeMapping.read(DriftSqlType.int,
              data['${effectivePrefix}next_time_algorithm_usage_status'])!),
      title: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}title'])!,
      created_at: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_at'])!,
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id'])!,
      updated_at: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}updated_at'])!,
    );
  }

  @override
  $MemoryModelsTable createAlias(String alias) {
    return $MemoryModelsTable(attachedDatabase, alias);
  }

  static JsonTypeConverter2<AlgorithmUsageStatus, int, int>
      $converterbutton_algorithm_usage_status =
      const EnumIndexConverter<AlgorithmUsageStatus>(
          AlgorithmUsageStatus.values);
  static JsonTypeConverter2<AlgorithmUsageStatus, int, int>
      $converterfamiliarity_algorithm_usage_status =
      const EnumIndexConverter<AlgorithmUsageStatus>(
          AlgorithmUsageStatus.values);
  static JsonTypeConverter2<AlgorithmUsageStatus, int, int>
      $converternext_time_algorithm_usage_status =
      const EnumIndexConverter<AlgorithmUsageStatus>(
          AlgorithmUsageStatus.values);
  @override
  bool get withoutRowId => true;
}

class MemoryModel extends DataClass implements Insertable<MemoryModel> {
  String? button_algorithm_a;
  String? button_algorithm_b;
  String? button_algorithm_c;
  String? button_algorithm_remark;
  AlgorithmUsageStatus button_algorithm_usage_status;
  int creator_user_id;
  String? familiarity_algorithm_a;
  String? familiarity_algorithm_b;
  String? familiarity_algorithm_c;
  String? familiarity_algorithm_remark;
  AlgorithmUsageStatus familiarity_algorithm_usage_status;
  String? father_memory_model_id;
  String? next_time_algorithm_a;
  String? next_time_algorithm_b;
  String? next_time_algorithm_c;
  String? next_time_algorithm_remark;
  AlgorithmUsageStatus next_time_algorithm_usage_status;
  String title;
  DateTime created_at;
  String id;
  DateTime updated_at;
  MemoryModel(
      {this.button_algorithm_a,
      this.button_algorithm_b,
      this.button_algorithm_c,
      this.button_algorithm_remark,
      required this.button_algorithm_usage_status,
      required this.creator_user_id,
      this.familiarity_algorithm_a,
      this.familiarity_algorithm_b,
      this.familiarity_algorithm_c,
      this.familiarity_algorithm_remark,
      required this.familiarity_algorithm_usage_status,
      this.father_memory_model_id,
      this.next_time_algorithm_a,
      this.next_time_algorithm_b,
      this.next_time_algorithm_c,
      this.next_time_algorithm_remark,
      required this.next_time_algorithm_usage_status,
      required this.title,
      required this.created_at,
      required this.id,
      required this.updated_at});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || button_algorithm_a != null) {
      map['button_algorithm_a'] = Variable<String>(button_algorithm_a);
    }
    if (!nullToAbsent || button_algorithm_b != null) {
      map['button_algorithm_b'] = Variable<String>(button_algorithm_b);
    }
    if (!nullToAbsent || button_algorithm_c != null) {
      map['button_algorithm_c'] = Variable<String>(button_algorithm_c);
    }
    if (!nullToAbsent || button_algorithm_remark != null) {
      map['button_algorithm_remark'] =
          Variable<String>(button_algorithm_remark);
    }
    {
      final converter =
          $MemoryModelsTable.$converterbutton_algorithm_usage_status;
      map['button_algorithm_usage_status'] =
          Variable<int>(converter.toSql(button_algorithm_usage_status));
    }
    map['creator_user_id'] = Variable<int>(creator_user_id);
    if (!nullToAbsent || familiarity_algorithm_a != null) {
      map['familiarity_algorithm_a'] =
          Variable<String>(familiarity_algorithm_a);
    }
    if (!nullToAbsent || familiarity_algorithm_b != null) {
      map['familiarity_algorithm_b'] =
          Variable<String>(familiarity_algorithm_b);
    }
    if (!nullToAbsent || familiarity_algorithm_c != null) {
      map['familiarity_algorithm_c'] =
          Variable<String>(familiarity_algorithm_c);
    }
    if (!nullToAbsent || familiarity_algorithm_remark != null) {
      map['familiarity_algorithm_remark'] =
          Variable<String>(familiarity_algorithm_remark);
    }
    {
      final converter =
          $MemoryModelsTable.$converterfamiliarity_algorithm_usage_status;
      map['familiarity_algorithm_usage_status'] =
          Variable<int>(converter.toSql(familiarity_algorithm_usage_status));
    }
    if (!nullToAbsent || father_memory_model_id != null) {
      map['father_memory_model_id'] = Variable<String>(father_memory_model_id);
    }
    if (!nullToAbsent || next_time_algorithm_a != null) {
      map['next_time_algorithm_a'] = Variable<String>(next_time_algorithm_a);
    }
    if (!nullToAbsent || next_time_algorithm_b != null) {
      map['next_time_algorithm_b'] = Variable<String>(next_time_algorithm_b);
    }
    if (!nullToAbsent || next_time_algorithm_c != null) {
      map['next_time_algorithm_c'] = Variable<String>(next_time_algorithm_c);
    }
    if (!nullToAbsent || next_time_algorithm_remark != null) {
      map['next_time_algorithm_remark'] =
          Variable<String>(next_time_algorithm_remark);
    }
    {
      final converter =
          $MemoryModelsTable.$converternext_time_algorithm_usage_status;
      map['next_time_algorithm_usage_status'] =
          Variable<int>(converter.toSql(next_time_algorithm_usage_status));
    }
    map['title'] = Variable<String>(title);
    map['created_at'] = Variable<DateTime>(created_at);
    map['id'] = Variable<String>(id);
    map['updated_at'] = Variable<DateTime>(updated_at);
    return map;
  }

  MemoryModelsCompanion toCompanion(bool nullToAbsent) {
    return MemoryModelsCompanion(
      button_algorithm_a: button_algorithm_a == null && nullToAbsent
          ? const Value.absent()
          : Value(button_algorithm_a),
      button_algorithm_b: button_algorithm_b == null && nullToAbsent
          ? const Value.absent()
          : Value(button_algorithm_b),
      button_algorithm_c: button_algorithm_c == null && nullToAbsent
          ? const Value.absent()
          : Value(button_algorithm_c),
      button_algorithm_remark: button_algorithm_remark == null && nullToAbsent
          ? const Value.absent()
          : Value(button_algorithm_remark),
      button_algorithm_usage_status: Value(button_algorithm_usage_status),
      creator_user_id: Value(creator_user_id),
      familiarity_algorithm_a: familiarity_algorithm_a == null && nullToAbsent
          ? const Value.absent()
          : Value(familiarity_algorithm_a),
      familiarity_algorithm_b: familiarity_algorithm_b == null && nullToAbsent
          ? const Value.absent()
          : Value(familiarity_algorithm_b),
      familiarity_algorithm_c: familiarity_algorithm_c == null && nullToAbsent
          ? const Value.absent()
          : Value(familiarity_algorithm_c),
      familiarity_algorithm_remark:
          familiarity_algorithm_remark == null && nullToAbsent
              ? const Value.absent()
              : Value(familiarity_algorithm_remark),
      familiarity_algorithm_usage_status:
          Value(familiarity_algorithm_usage_status),
      father_memory_model_id: father_memory_model_id == null && nullToAbsent
          ? const Value.absent()
          : Value(father_memory_model_id),
      next_time_algorithm_a: next_time_algorithm_a == null && nullToAbsent
          ? const Value.absent()
          : Value(next_time_algorithm_a),
      next_time_algorithm_b: next_time_algorithm_b == null && nullToAbsent
          ? const Value.absent()
          : Value(next_time_algorithm_b),
      next_time_algorithm_c: next_time_algorithm_c == null && nullToAbsent
          ? const Value.absent()
          : Value(next_time_algorithm_c),
      next_time_algorithm_remark:
          next_time_algorithm_remark == null && nullToAbsent
              ? const Value.absent()
              : Value(next_time_algorithm_remark),
      next_time_algorithm_usage_status: Value(next_time_algorithm_usage_status),
      title: Value(title),
      created_at: Value(created_at),
      id: Value(id),
      updated_at: Value(updated_at),
    );
  }

  factory MemoryModel.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return MemoryModel(
      button_algorithm_a:
          serializer.fromJson<String?>(json['button_algorithm_a']),
      button_algorithm_b:
          serializer.fromJson<String?>(json['button_algorithm_b']),
      button_algorithm_c:
          serializer.fromJson<String?>(json['button_algorithm_c']),
      button_algorithm_remark:
          serializer.fromJson<String?>(json['button_algorithm_remark']),
      button_algorithm_usage_status:
          $MemoryModelsTable.$converterbutton_algorithm_usage_status.fromJson(
              serializer.fromJson<int>(json['button_algorithm_usage_status'])),
      creator_user_id: serializer.fromJson<int>(json['creator_user_id']),
      familiarity_algorithm_a:
          serializer.fromJson<String?>(json['familiarity_algorithm_a']),
      familiarity_algorithm_b:
          serializer.fromJson<String?>(json['familiarity_algorithm_b']),
      familiarity_algorithm_c:
          serializer.fromJson<String?>(json['familiarity_algorithm_c']),
      familiarity_algorithm_remark:
          serializer.fromJson<String?>(json['familiarity_algorithm_remark']),
      familiarity_algorithm_usage_status: $MemoryModelsTable
          .$converterfamiliarity_algorithm_usage_status
          .fromJson(serializer
              .fromJson<int>(json['familiarity_algorithm_usage_status'])),
      father_memory_model_id:
          serializer.fromJson<String?>(json['father_memory_model_id']),
      next_time_algorithm_a:
          serializer.fromJson<String?>(json['next_time_algorithm_a']),
      next_time_algorithm_b:
          serializer.fromJson<String?>(json['next_time_algorithm_b']),
      next_time_algorithm_c:
          serializer.fromJson<String?>(json['next_time_algorithm_c']),
      next_time_algorithm_remark:
          serializer.fromJson<String?>(json['next_time_algorithm_remark']),
      next_time_algorithm_usage_status: $MemoryModelsTable
          .$converternext_time_algorithm_usage_status
          .fromJson(serializer
              .fromJson<int>(json['next_time_algorithm_usage_status'])),
      title: serializer.fromJson<String>(json['title']),
      created_at: serializer.fromJson<DateTime>(json['created_at']),
      id: serializer.fromJson<String>(json['id']),
      updated_at: serializer.fromJson<DateTime>(json['updated_at']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'button_algorithm_a': serializer.toJson<String?>(button_algorithm_a),
      'button_algorithm_b': serializer.toJson<String?>(button_algorithm_b),
      'button_algorithm_c': serializer.toJson<String?>(button_algorithm_c),
      'button_algorithm_remark':
          serializer.toJson<String?>(button_algorithm_remark),
      'button_algorithm_usage_status': serializer.toJson<int>($MemoryModelsTable
          .$converterbutton_algorithm_usage_status
          .toJson(button_algorithm_usage_status)),
      'creator_user_id': serializer.toJson<int>(creator_user_id),
      'familiarity_algorithm_a':
          serializer.toJson<String?>(familiarity_algorithm_a),
      'familiarity_algorithm_b':
          serializer.toJson<String?>(familiarity_algorithm_b),
      'familiarity_algorithm_c':
          serializer.toJson<String?>(familiarity_algorithm_c),
      'familiarity_algorithm_remark':
          serializer.toJson<String?>(familiarity_algorithm_remark),
      'familiarity_algorithm_usage_status': serializer.toJson<int>(
          $MemoryModelsTable.$converterfamiliarity_algorithm_usage_status
              .toJson(familiarity_algorithm_usage_status)),
      'father_memory_model_id':
          serializer.toJson<String?>(father_memory_model_id),
      'next_time_algorithm_a':
          serializer.toJson<String?>(next_time_algorithm_a),
      'next_time_algorithm_b':
          serializer.toJson<String?>(next_time_algorithm_b),
      'next_time_algorithm_c':
          serializer.toJson<String?>(next_time_algorithm_c),
      'next_time_algorithm_remark':
          serializer.toJson<String?>(next_time_algorithm_remark),
      'next_time_algorithm_usage_status': serializer.toJson<int>(
          $MemoryModelsTable.$converternext_time_algorithm_usage_status
              .toJson(next_time_algorithm_usage_status)),
      'title': serializer.toJson<String>(title),
      'created_at': serializer.toJson<DateTime>(created_at),
      'id': serializer.toJson<String>(id),
      'updated_at': serializer.toJson<DateTime>(updated_at),
    };
  }

  MemoryModel copyWith(
          {Value<String?> button_algorithm_a = const Value.absent(),
          Value<String?> button_algorithm_b = const Value.absent(),
          Value<String?> button_algorithm_c = const Value.absent(),
          Value<String?> button_algorithm_remark = const Value.absent(),
          AlgorithmUsageStatus? button_algorithm_usage_status,
          int? creator_user_id,
          Value<String?> familiarity_algorithm_a = const Value.absent(),
          Value<String?> familiarity_algorithm_b = const Value.absent(),
          Value<String?> familiarity_algorithm_c = const Value.absent(),
          Value<String?> familiarity_algorithm_remark = const Value.absent(),
          AlgorithmUsageStatus? familiarity_algorithm_usage_status,
          Value<String?> father_memory_model_id = const Value.absent(),
          Value<String?> next_time_algorithm_a = const Value.absent(),
          Value<String?> next_time_algorithm_b = const Value.absent(),
          Value<String?> next_time_algorithm_c = const Value.absent(),
          Value<String?> next_time_algorithm_remark = const Value.absent(),
          AlgorithmUsageStatus? next_time_algorithm_usage_status,
          String? title,
          DateTime? created_at,
          String? id,
          DateTime? updated_at}) =>
      MemoryModel(
        button_algorithm_a: button_algorithm_a.present
            ? button_algorithm_a.value
            : this.button_algorithm_a,
        button_algorithm_b: button_algorithm_b.present
            ? button_algorithm_b.value
            : this.button_algorithm_b,
        button_algorithm_c: button_algorithm_c.present
            ? button_algorithm_c.value
            : this.button_algorithm_c,
        button_algorithm_remark: button_algorithm_remark.present
            ? button_algorithm_remark.value
            : this.button_algorithm_remark,
        button_algorithm_usage_status:
            button_algorithm_usage_status ?? this.button_algorithm_usage_status,
        creator_user_id: creator_user_id ?? this.creator_user_id,
        familiarity_algorithm_a: familiarity_algorithm_a.present
            ? familiarity_algorithm_a.value
            : this.familiarity_algorithm_a,
        familiarity_algorithm_b: familiarity_algorithm_b.present
            ? familiarity_algorithm_b.value
            : this.familiarity_algorithm_b,
        familiarity_algorithm_c: familiarity_algorithm_c.present
            ? familiarity_algorithm_c.value
            : this.familiarity_algorithm_c,
        familiarity_algorithm_remark: familiarity_algorithm_remark.present
            ? familiarity_algorithm_remark.value
            : this.familiarity_algorithm_remark,
        familiarity_algorithm_usage_status:
            familiarity_algorithm_usage_status ??
                this.familiarity_algorithm_usage_status,
        father_memory_model_id: father_memory_model_id.present
            ? father_memory_model_id.value
            : this.father_memory_model_id,
        next_time_algorithm_a: next_time_algorithm_a.present
            ? next_time_algorithm_a.value
            : this.next_time_algorithm_a,
        next_time_algorithm_b: next_time_algorithm_b.present
            ? next_time_algorithm_b.value
            : this.next_time_algorithm_b,
        next_time_algorithm_c: next_time_algorithm_c.present
            ? next_time_algorithm_c.value
            : this.next_time_algorithm_c,
        next_time_algorithm_remark: next_time_algorithm_remark.present
            ? next_time_algorithm_remark.value
            : this.next_time_algorithm_remark,
        next_time_algorithm_usage_status: next_time_algorithm_usage_status ??
            this.next_time_algorithm_usage_status,
        title: title ?? this.title,
        created_at: created_at ?? this.created_at,
        id: id ?? this.id,
        updated_at: updated_at ?? this.updated_at,
      );
  @override
  String toString() {
    return (StringBuffer('MemoryModel(')
          ..write('button_algorithm_a: $button_algorithm_a, ')
          ..write('button_algorithm_b: $button_algorithm_b, ')
          ..write('button_algorithm_c: $button_algorithm_c, ')
          ..write('button_algorithm_remark: $button_algorithm_remark, ')
          ..write(
              'button_algorithm_usage_status: $button_algorithm_usage_status, ')
          ..write('creator_user_id: $creator_user_id, ')
          ..write('familiarity_algorithm_a: $familiarity_algorithm_a, ')
          ..write('familiarity_algorithm_b: $familiarity_algorithm_b, ')
          ..write('familiarity_algorithm_c: $familiarity_algorithm_c, ')
          ..write(
              'familiarity_algorithm_remark: $familiarity_algorithm_remark, ')
          ..write(
              'familiarity_algorithm_usage_status: $familiarity_algorithm_usage_status, ')
          ..write('father_memory_model_id: $father_memory_model_id, ')
          ..write('next_time_algorithm_a: $next_time_algorithm_a, ')
          ..write('next_time_algorithm_b: $next_time_algorithm_b, ')
          ..write('next_time_algorithm_c: $next_time_algorithm_c, ')
          ..write('next_time_algorithm_remark: $next_time_algorithm_remark, ')
          ..write(
              'next_time_algorithm_usage_status: $next_time_algorithm_usage_status, ')
          ..write('title: $title, ')
          ..write('created_at: $created_at, ')
          ..write('id: $id, ')
          ..write('updated_at: $updated_at')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
        button_algorithm_a,
        button_algorithm_b,
        button_algorithm_c,
        button_algorithm_remark,
        button_algorithm_usage_status,
        creator_user_id,
        familiarity_algorithm_a,
        familiarity_algorithm_b,
        familiarity_algorithm_c,
        familiarity_algorithm_remark,
        familiarity_algorithm_usage_status,
        father_memory_model_id,
        next_time_algorithm_a,
        next_time_algorithm_b,
        next_time_algorithm_c,
        next_time_algorithm_remark,
        next_time_algorithm_usage_status,
        title,
        created_at,
        id,
        updated_at
      ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is MemoryModel &&
          other.button_algorithm_a == this.button_algorithm_a &&
          other.button_algorithm_b == this.button_algorithm_b &&
          other.button_algorithm_c == this.button_algorithm_c &&
          other.button_algorithm_remark == this.button_algorithm_remark &&
          other.button_algorithm_usage_status ==
              this.button_algorithm_usage_status &&
          other.creator_user_id == this.creator_user_id &&
          other.familiarity_algorithm_a == this.familiarity_algorithm_a &&
          other.familiarity_algorithm_b == this.familiarity_algorithm_b &&
          other.familiarity_algorithm_c == this.familiarity_algorithm_c &&
          other.familiarity_algorithm_remark ==
              this.familiarity_algorithm_remark &&
          other.familiarity_algorithm_usage_status ==
              this.familiarity_algorithm_usage_status &&
          other.father_memory_model_id == this.father_memory_model_id &&
          other.next_time_algorithm_a == this.next_time_algorithm_a &&
          other.next_time_algorithm_b == this.next_time_algorithm_b &&
          other.next_time_algorithm_c == this.next_time_algorithm_c &&
          other.next_time_algorithm_remark == this.next_time_algorithm_remark &&
          other.next_time_algorithm_usage_status ==
              this.next_time_algorithm_usage_status &&
          other.title == this.title &&
          other.created_at == this.created_at &&
          other.id == this.id &&
          other.updated_at == this.updated_at);
}

class MemoryModelsCompanion extends UpdateCompanion<MemoryModel> {
  Value<String?> button_algorithm_a;
  Value<String?> button_algorithm_b;
  Value<String?> button_algorithm_c;
  Value<String?> button_algorithm_remark;
  Value<AlgorithmUsageStatus> button_algorithm_usage_status;
  Value<int> creator_user_id;
  Value<String?> familiarity_algorithm_a;
  Value<String?> familiarity_algorithm_b;
  Value<String?> familiarity_algorithm_c;
  Value<String?> familiarity_algorithm_remark;
  Value<AlgorithmUsageStatus> familiarity_algorithm_usage_status;
  Value<String?> father_memory_model_id;
  Value<String?> next_time_algorithm_a;
  Value<String?> next_time_algorithm_b;
  Value<String?> next_time_algorithm_c;
  Value<String?> next_time_algorithm_remark;
  Value<AlgorithmUsageStatus> next_time_algorithm_usage_status;
  Value<String> title;
  Value<DateTime> created_at;
  Value<String> id;
  Value<DateTime> updated_at;
  MemoryModelsCompanion({
    this.button_algorithm_a = const Value.absent(),
    this.button_algorithm_b = const Value.absent(),
    this.button_algorithm_c = const Value.absent(),
    this.button_algorithm_remark = const Value.absent(),
    this.button_algorithm_usage_status = const Value.absent(),
    this.creator_user_id = const Value.absent(),
    this.familiarity_algorithm_a = const Value.absent(),
    this.familiarity_algorithm_b = const Value.absent(),
    this.familiarity_algorithm_c = const Value.absent(),
    this.familiarity_algorithm_remark = const Value.absent(),
    this.familiarity_algorithm_usage_status = const Value.absent(),
    this.father_memory_model_id = const Value.absent(),
    this.next_time_algorithm_a = const Value.absent(),
    this.next_time_algorithm_b = const Value.absent(),
    this.next_time_algorithm_c = const Value.absent(),
    this.next_time_algorithm_remark = const Value.absent(),
    this.next_time_algorithm_usage_status = const Value.absent(),
    this.title = const Value.absent(),
    this.created_at = const Value.absent(),
    this.id = const Value.absent(),
    this.updated_at = const Value.absent(),
  });
  MemoryModelsCompanion.insert({
    this.button_algorithm_a = const Value.absent(),
    this.button_algorithm_b = const Value.absent(),
    this.button_algorithm_c = const Value.absent(),
    this.button_algorithm_remark = const Value.absent(),
    required AlgorithmUsageStatus button_algorithm_usage_status,
    required int creator_user_id,
    this.familiarity_algorithm_a = const Value.absent(),
    this.familiarity_algorithm_b = const Value.absent(),
    this.familiarity_algorithm_c = const Value.absent(),
    this.familiarity_algorithm_remark = const Value.absent(),
    required AlgorithmUsageStatus familiarity_algorithm_usage_status,
    this.father_memory_model_id = const Value.absent(),
    this.next_time_algorithm_a = const Value.absent(),
    this.next_time_algorithm_b = const Value.absent(),
    this.next_time_algorithm_c = const Value.absent(),
    this.next_time_algorithm_remark = const Value.absent(),
    required AlgorithmUsageStatus next_time_algorithm_usage_status,
    required String title,
    required DateTime created_at,
    required String id,
    required DateTime updated_at,
  })  : button_algorithm_usage_status = Value(button_algorithm_usage_status),
        creator_user_id = Value(creator_user_id),
        familiarity_algorithm_usage_status =
            Value(familiarity_algorithm_usage_status),
        next_time_algorithm_usage_status =
            Value(next_time_algorithm_usage_status),
        title = Value(title),
        created_at = Value(created_at),
        id = Value(id),
        updated_at = Value(updated_at);
  static Insertable<MemoryModel> custom({
    Expression<String>? button_algorithm_a,
    Expression<String>? button_algorithm_b,
    Expression<String>? button_algorithm_c,
    Expression<String>? button_algorithm_remark,
    Expression<int>? button_algorithm_usage_status,
    Expression<int>? creator_user_id,
    Expression<String>? familiarity_algorithm_a,
    Expression<String>? familiarity_algorithm_b,
    Expression<String>? familiarity_algorithm_c,
    Expression<String>? familiarity_algorithm_remark,
    Expression<int>? familiarity_algorithm_usage_status,
    Expression<String>? father_memory_model_id,
    Expression<String>? next_time_algorithm_a,
    Expression<String>? next_time_algorithm_b,
    Expression<String>? next_time_algorithm_c,
    Expression<String>? next_time_algorithm_remark,
    Expression<int>? next_time_algorithm_usage_status,
    Expression<String>? title,
    Expression<DateTime>? created_at,
    Expression<String>? id,
    Expression<DateTime>? updated_at,
  }) {
    return RawValuesInsertable({
      if (button_algorithm_a != null) 'button_algorithm_a': button_algorithm_a,
      if (button_algorithm_b != null) 'button_algorithm_b': button_algorithm_b,
      if (button_algorithm_c != null) 'button_algorithm_c': button_algorithm_c,
      if (button_algorithm_remark != null)
        'button_algorithm_remark': button_algorithm_remark,
      if (button_algorithm_usage_status != null)
        'button_algorithm_usage_status': button_algorithm_usage_status,
      if (creator_user_id != null) 'creator_user_id': creator_user_id,
      if (familiarity_algorithm_a != null)
        'familiarity_algorithm_a': familiarity_algorithm_a,
      if (familiarity_algorithm_b != null)
        'familiarity_algorithm_b': familiarity_algorithm_b,
      if (familiarity_algorithm_c != null)
        'familiarity_algorithm_c': familiarity_algorithm_c,
      if (familiarity_algorithm_remark != null)
        'familiarity_algorithm_remark': familiarity_algorithm_remark,
      if (familiarity_algorithm_usage_status != null)
        'familiarity_algorithm_usage_status':
            familiarity_algorithm_usage_status,
      if (father_memory_model_id != null)
        'father_memory_model_id': father_memory_model_id,
      if (next_time_algorithm_a != null)
        'next_time_algorithm_a': next_time_algorithm_a,
      if (next_time_algorithm_b != null)
        'next_time_algorithm_b': next_time_algorithm_b,
      if (next_time_algorithm_c != null)
        'next_time_algorithm_c': next_time_algorithm_c,
      if (next_time_algorithm_remark != null)
        'next_time_algorithm_remark': next_time_algorithm_remark,
      if (next_time_algorithm_usage_status != null)
        'next_time_algorithm_usage_status': next_time_algorithm_usage_status,
      if (title != null) 'title': title,
      if (created_at != null) 'created_at': created_at,
      if (id != null) 'id': id,
      if (updated_at != null) 'updated_at': updated_at,
    });
  }

  MemoryModelsCompanion copyWith(
      {Value<String?>? button_algorithm_a,
      Value<String?>? button_algorithm_b,
      Value<String?>? button_algorithm_c,
      Value<String?>? button_algorithm_remark,
      Value<AlgorithmUsageStatus>? button_algorithm_usage_status,
      Value<int>? creator_user_id,
      Value<String?>? familiarity_algorithm_a,
      Value<String?>? familiarity_algorithm_b,
      Value<String?>? familiarity_algorithm_c,
      Value<String?>? familiarity_algorithm_remark,
      Value<AlgorithmUsageStatus>? familiarity_algorithm_usage_status,
      Value<String?>? father_memory_model_id,
      Value<String?>? next_time_algorithm_a,
      Value<String?>? next_time_algorithm_b,
      Value<String?>? next_time_algorithm_c,
      Value<String?>? next_time_algorithm_remark,
      Value<AlgorithmUsageStatus>? next_time_algorithm_usage_status,
      Value<String>? title,
      Value<DateTime>? created_at,
      Value<String>? id,
      Value<DateTime>? updated_at}) {
    return MemoryModelsCompanion(
      button_algorithm_a: button_algorithm_a ?? this.button_algorithm_a,
      button_algorithm_b: button_algorithm_b ?? this.button_algorithm_b,
      button_algorithm_c: button_algorithm_c ?? this.button_algorithm_c,
      button_algorithm_remark:
          button_algorithm_remark ?? this.button_algorithm_remark,
      button_algorithm_usage_status:
          button_algorithm_usage_status ?? this.button_algorithm_usage_status,
      creator_user_id: creator_user_id ?? this.creator_user_id,
      familiarity_algorithm_a:
          familiarity_algorithm_a ?? this.familiarity_algorithm_a,
      familiarity_algorithm_b:
          familiarity_algorithm_b ?? this.familiarity_algorithm_b,
      familiarity_algorithm_c:
          familiarity_algorithm_c ?? this.familiarity_algorithm_c,
      familiarity_algorithm_remark:
          familiarity_algorithm_remark ?? this.familiarity_algorithm_remark,
      familiarity_algorithm_usage_status: familiarity_algorithm_usage_status ??
          this.familiarity_algorithm_usage_status,
      father_memory_model_id:
          father_memory_model_id ?? this.father_memory_model_id,
      next_time_algorithm_a:
          next_time_algorithm_a ?? this.next_time_algorithm_a,
      next_time_algorithm_b:
          next_time_algorithm_b ?? this.next_time_algorithm_b,
      next_time_algorithm_c:
          next_time_algorithm_c ?? this.next_time_algorithm_c,
      next_time_algorithm_remark:
          next_time_algorithm_remark ?? this.next_time_algorithm_remark,
      next_time_algorithm_usage_status: next_time_algorithm_usage_status ??
          this.next_time_algorithm_usage_status,
      title: title ?? this.title,
      created_at: created_at ?? this.created_at,
      id: id ?? this.id,
      updated_at: updated_at ?? this.updated_at,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (button_algorithm_a.present) {
      map['button_algorithm_a'] = Variable<String>(button_algorithm_a.value);
    }
    if (button_algorithm_b.present) {
      map['button_algorithm_b'] = Variable<String>(button_algorithm_b.value);
    }
    if (button_algorithm_c.present) {
      map['button_algorithm_c'] = Variable<String>(button_algorithm_c.value);
    }
    if (button_algorithm_remark.present) {
      map['button_algorithm_remark'] =
          Variable<String>(button_algorithm_remark.value);
    }
    if (button_algorithm_usage_status.present) {
      final converter =
          $MemoryModelsTable.$converterbutton_algorithm_usage_status;
      map['button_algorithm_usage_status'] =
          Variable<int>(converter.toSql(button_algorithm_usage_status.value));
    }
    if (creator_user_id.present) {
      map['creator_user_id'] = Variable<int>(creator_user_id.value);
    }
    if (familiarity_algorithm_a.present) {
      map['familiarity_algorithm_a'] =
          Variable<String>(familiarity_algorithm_a.value);
    }
    if (familiarity_algorithm_b.present) {
      map['familiarity_algorithm_b'] =
          Variable<String>(familiarity_algorithm_b.value);
    }
    if (familiarity_algorithm_c.present) {
      map['familiarity_algorithm_c'] =
          Variable<String>(familiarity_algorithm_c.value);
    }
    if (familiarity_algorithm_remark.present) {
      map['familiarity_algorithm_remark'] =
          Variable<String>(familiarity_algorithm_remark.value);
    }
    if (familiarity_algorithm_usage_status.present) {
      final converter =
          $MemoryModelsTable.$converterfamiliarity_algorithm_usage_status;
      map['familiarity_algorithm_usage_status'] = Variable<int>(
          converter.toSql(familiarity_algorithm_usage_status.value));
    }
    if (father_memory_model_id.present) {
      map['father_memory_model_id'] =
          Variable<String>(father_memory_model_id.value);
    }
    if (next_time_algorithm_a.present) {
      map['next_time_algorithm_a'] =
          Variable<String>(next_time_algorithm_a.value);
    }
    if (next_time_algorithm_b.present) {
      map['next_time_algorithm_b'] =
          Variable<String>(next_time_algorithm_b.value);
    }
    if (next_time_algorithm_c.present) {
      map['next_time_algorithm_c'] =
          Variable<String>(next_time_algorithm_c.value);
    }
    if (next_time_algorithm_remark.present) {
      map['next_time_algorithm_remark'] =
          Variable<String>(next_time_algorithm_remark.value);
    }
    if (next_time_algorithm_usage_status.present) {
      final converter =
          $MemoryModelsTable.$converternext_time_algorithm_usage_status;
      map['next_time_algorithm_usage_status'] = Variable<int>(
          converter.toSql(next_time_algorithm_usage_status.value));
    }
    if (title.present) {
      map['title'] = Variable<String>(title.value);
    }
    if (created_at.present) {
      map['created_at'] = Variable<DateTime>(created_at.value);
    }
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (updated_at.present) {
      map['updated_at'] = Variable<DateTime>(updated_at.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('MemoryModelsCompanion(')
          ..write('button_algorithm_a: $button_algorithm_a, ')
          ..write('button_algorithm_b: $button_algorithm_b, ')
          ..write('button_algorithm_c: $button_algorithm_c, ')
          ..write('button_algorithm_remark: $button_algorithm_remark, ')
          ..write(
              'button_algorithm_usage_status: $button_algorithm_usage_status, ')
          ..write('creator_user_id: $creator_user_id, ')
          ..write('familiarity_algorithm_a: $familiarity_algorithm_a, ')
          ..write('familiarity_algorithm_b: $familiarity_algorithm_b, ')
          ..write('familiarity_algorithm_c: $familiarity_algorithm_c, ')
          ..write(
              'familiarity_algorithm_remark: $familiarity_algorithm_remark, ')
          ..write(
              'familiarity_algorithm_usage_status: $familiarity_algorithm_usage_status, ')
          ..write('father_memory_model_id: $father_memory_model_id, ')
          ..write('next_time_algorithm_a: $next_time_algorithm_a, ')
          ..write('next_time_algorithm_b: $next_time_algorithm_b, ')
          ..write('next_time_algorithm_c: $next_time_algorithm_c, ')
          ..write('next_time_algorithm_remark: $next_time_algorithm_remark, ')
          ..write(
              'next_time_algorithm_usage_status: $next_time_algorithm_usage_status, ')
          ..write('title: $title, ')
          ..write('created_at: $created_at, ')
          ..write('id: $id, ')
          ..write('updated_at: $updated_at')
          ..write(')'))
        .toString();
  }
}

class $ShorthandsTable extends Shorthands
    with TableInfo<$ShorthandsTable, Shorthand> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ShorthandsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _contentMeta =
      const VerificationMeta('content');
  @override
  late final GeneratedColumn<String> content = GeneratedColumn<String>(
      'content', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _creator_user_idMeta =
      const VerificationMeta('creator_user_id');
  @override
  late final GeneratedColumn<int> creator_user_id = GeneratedColumn<int>(
      'creator_user_id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _created_atMeta =
      const VerificationMeta('created_at');
  @override
  late final GeneratedColumn<DateTime> created_at = GeneratedColumn<DateTime>(
      'created_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _updated_atMeta =
      const VerificationMeta('updated_at');
  @override
  late final GeneratedColumn<DateTime> updated_at = GeneratedColumn<DateTime>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns =>
      [content, creator_user_id, created_at, id, updated_at];
  @override
  String get aliasedName => _alias ?? 'shorthands';
  @override
  String get actualTableName => 'shorthands';
  @override
  VerificationContext validateIntegrity(Insertable<Shorthand> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('content')) {
      context.handle(_contentMeta,
          content.isAcceptableOrUnknown(data['content']!, _contentMeta));
    } else if (isInserting) {
      context.missing(_contentMeta);
    }
    if (data.containsKey('creator_user_id')) {
      context.handle(
          _creator_user_idMeta,
          creator_user_id.isAcceptableOrUnknown(
              data['creator_user_id']!, _creator_user_idMeta));
    } else if (isInserting) {
      context.missing(_creator_user_idMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(
          _created_atMeta,
          created_at.isAcceptableOrUnknown(
              data['created_at']!, _created_atMeta));
    } else if (isInserting) {
      context.missing(_created_atMeta);
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
          _updated_atMeta,
          updated_at.isAcceptableOrUnknown(
              data['updated_at']!, _updated_atMeta));
    } else if (isInserting) {
      context.missing(_updated_atMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Shorthand map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Shorthand(
      content: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}content'])!,
      creator_user_id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}creator_user_id'])!,
      created_at: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_at'])!,
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id'])!,
      updated_at: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}updated_at'])!,
    );
  }

  @override
  $ShorthandsTable createAlias(String alias) {
    return $ShorthandsTable(attachedDatabase, alias);
  }

  @override
  bool get withoutRowId => true;
}

class Shorthand extends DataClass implements Insertable<Shorthand> {
  String content;
  int creator_user_id;
  DateTime created_at;
  String id;
  DateTime updated_at;
  Shorthand(
      {required this.content,
      required this.creator_user_id,
      required this.created_at,
      required this.id,
      required this.updated_at});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['content'] = Variable<String>(content);
    map['creator_user_id'] = Variable<int>(creator_user_id);
    map['created_at'] = Variable<DateTime>(created_at);
    map['id'] = Variable<String>(id);
    map['updated_at'] = Variable<DateTime>(updated_at);
    return map;
  }

  ShorthandsCompanion toCompanion(bool nullToAbsent) {
    return ShorthandsCompanion(
      content: Value(content),
      creator_user_id: Value(creator_user_id),
      created_at: Value(created_at),
      id: Value(id),
      updated_at: Value(updated_at),
    );
  }

  factory Shorthand.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Shorthand(
      content: serializer.fromJson<String>(json['content']),
      creator_user_id: serializer.fromJson<int>(json['creator_user_id']),
      created_at: serializer.fromJson<DateTime>(json['created_at']),
      id: serializer.fromJson<String>(json['id']),
      updated_at: serializer.fromJson<DateTime>(json['updated_at']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'content': serializer.toJson<String>(content),
      'creator_user_id': serializer.toJson<int>(creator_user_id),
      'created_at': serializer.toJson<DateTime>(created_at),
      'id': serializer.toJson<String>(id),
      'updated_at': serializer.toJson<DateTime>(updated_at),
    };
  }

  Shorthand copyWith(
          {String? content,
          int? creator_user_id,
          DateTime? created_at,
          String? id,
          DateTime? updated_at}) =>
      Shorthand(
        content: content ?? this.content,
        creator_user_id: creator_user_id ?? this.creator_user_id,
        created_at: created_at ?? this.created_at,
        id: id ?? this.id,
        updated_at: updated_at ?? this.updated_at,
      );
  @override
  String toString() {
    return (StringBuffer('Shorthand(')
          ..write('content: $content, ')
          ..write('creator_user_id: $creator_user_id, ')
          ..write('created_at: $created_at, ')
          ..write('id: $id, ')
          ..write('updated_at: $updated_at')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(content, creator_user_id, created_at, id, updated_at);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Shorthand &&
          other.content == this.content &&
          other.creator_user_id == this.creator_user_id &&
          other.created_at == this.created_at &&
          other.id == this.id &&
          other.updated_at == this.updated_at);
}

class ShorthandsCompanion extends UpdateCompanion<Shorthand> {
  Value<String> content;
  Value<int> creator_user_id;
  Value<DateTime> created_at;
  Value<String> id;
  Value<DateTime> updated_at;
  ShorthandsCompanion({
    this.content = const Value.absent(),
    this.creator_user_id = const Value.absent(),
    this.created_at = const Value.absent(),
    this.id = const Value.absent(),
    this.updated_at = const Value.absent(),
  });
  ShorthandsCompanion.insert({
    required String content,
    required int creator_user_id,
    required DateTime created_at,
    required String id,
    required DateTime updated_at,
  })  : content = Value(content),
        creator_user_id = Value(creator_user_id),
        created_at = Value(created_at),
        id = Value(id),
        updated_at = Value(updated_at);
  static Insertable<Shorthand> custom({
    Expression<String>? content,
    Expression<int>? creator_user_id,
    Expression<DateTime>? created_at,
    Expression<String>? id,
    Expression<DateTime>? updated_at,
  }) {
    return RawValuesInsertable({
      if (content != null) 'content': content,
      if (creator_user_id != null) 'creator_user_id': creator_user_id,
      if (created_at != null) 'created_at': created_at,
      if (id != null) 'id': id,
      if (updated_at != null) 'updated_at': updated_at,
    });
  }

  ShorthandsCompanion copyWith(
      {Value<String>? content,
      Value<int>? creator_user_id,
      Value<DateTime>? created_at,
      Value<String>? id,
      Value<DateTime>? updated_at}) {
    return ShorthandsCompanion(
      content: content ?? this.content,
      creator_user_id: creator_user_id ?? this.creator_user_id,
      created_at: created_at ?? this.created_at,
      id: id ?? this.id,
      updated_at: updated_at ?? this.updated_at,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (content.present) {
      map['content'] = Variable<String>(content.value);
    }
    if (creator_user_id.present) {
      map['creator_user_id'] = Variable<int>(creator_user_id.value);
    }
    if (created_at.present) {
      map['created_at'] = Variable<DateTime>(created_at.value);
    }
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (updated_at.present) {
      map['updated_at'] = Variable<DateTime>(updated_at.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ShorthandsCompanion(')
          ..write('content: $content, ')
          ..write('creator_user_id: $creator_user_id, ')
          ..write('created_at: $created_at, ')
          ..write('id: $id, ')
          ..write('updated_at: $updated_at')
          ..write(')'))
        .toString();
  }
}

class $FragmentGroupsTable extends FragmentGroups
    with TableInfo<$FragmentGroupsTable, FragmentGroup> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $FragmentGroupsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _be_privateMeta =
      const VerificationMeta('be_private');
  @override
  late final GeneratedColumn<bool> be_private =
      GeneratedColumn<bool>('be_private', aliasedName, false,
          type: DriftSqlType.bool,
          requiredDuringInsert: true,
          defaultConstraints: GeneratedColumn.constraintsDependsOnDialect({
            SqlDialect.sqlite: 'CHECK ("be_private" IN (0, 1))',
            SqlDialect.mysql: '',
            SqlDialect.postgres: '',
          }));
  static const VerificationMeta _be_publishMeta =
      const VerificationMeta('be_publish');
  @override
  late final GeneratedColumn<bool> be_publish =
      GeneratedColumn<bool>('be_publish', aliasedName, false,
          type: DriftSqlType.bool,
          requiredDuringInsert: true,
          defaultConstraints: GeneratedColumn.constraintsDependsOnDialect({
            SqlDialect.sqlite: 'CHECK ("be_publish" IN (0, 1))',
            SqlDialect.mysql: '',
            SqlDialect.postgres: '',
          }));
  static const VerificationMeta _client_be_selectedMeta =
      const VerificationMeta('client_be_selected');
  @override
  late final GeneratedColumn<bool> client_be_selected =
      GeneratedColumn<bool>('client_be_selected', aliasedName, false,
          type: DriftSqlType.bool,
          requiredDuringInsert: true,
          defaultConstraints: GeneratedColumn.constraintsDependsOnDialect({
            SqlDialect.sqlite: 'CHECK ("client_be_selected" IN (0, 1))',
            SqlDialect.mysql: '',
            SqlDialect.postgres: '',
          }));
  static const VerificationMeta _creator_user_idMeta =
      const VerificationMeta('creator_user_id');
  @override
  late final GeneratedColumn<int> creator_user_id = GeneratedColumn<int>(
      'creator_user_id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _father_fragment_groups_idMeta =
      const VerificationMeta('father_fragment_groups_id');
  @override
  late final GeneratedColumn<String> father_fragment_groups_id =
      GeneratedColumn<String>('father_fragment_groups_id', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _profileMeta =
      const VerificationMeta('profile');
  @override
  late final GeneratedColumn<String> profile = GeneratedColumn<String>(
      'profile', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _titleMeta = const VerificationMeta('title');
  @override
  late final GeneratedColumn<String> title = GeneratedColumn<String>(
      'title', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _created_atMeta =
      const VerificationMeta('created_at');
  @override
  late final GeneratedColumn<DateTime> created_at = GeneratedColumn<DateTime>(
      'created_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _updated_atMeta =
      const VerificationMeta('updated_at');
  @override
  late final GeneratedColumn<DateTime> updated_at = GeneratedColumn<DateTime>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns => [
        be_private,
        be_publish,
        client_be_selected,
        creator_user_id,
        father_fragment_groups_id,
        profile,
        title,
        created_at,
        id,
        updated_at
      ];
  @override
  String get aliasedName => _alias ?? 'fragment_groups';
  @override
  String get actualTableName => 'fragment_groups';
  @override
  VerificationContext validateIntegrity(Insertable<FragmentGroup> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('be_private')) {
      context.handle(
          _be_privateMeta,
          be_private.isAcceptableOrUnknown(
              data['be_private']!, _be_privateMeta));
    } else if (isInserting) {
      context.missing(_be_privateMeta);
    }
    if (data.containsKey('be_publish')) {
      context.handle(
          _be_publishMeta,
          be_publish.isAcceptableOrUnknown(
              data['be_publish']!, _be_publishMeta));
    } else if (isInserting) {
      context.missing(_be_publishMeta);
    }
    if (data.containsKey('client_be_selected')) {
      context.handle(
          _client_be_selectedMeta,
          client_be_selected.isAcceptableOrUnknown(
              data['client_be_selected']!, _client_be_selectedMeta));
    } else if (isInserting) {
      context.missing(_client_be_selectedMeta);
    }
    if (data.containsKey('creator_user_id')) {
      context.handle(
          _creator_user_idMeta,
          creator_user_id.isAcceptableOrUnknown(
              data['creator_user_id']!, _creator_user_idMeta));
    } else if (isInserting) {
      context.missing(_creator_user_idMeta);
    }
    if (data.containsKey('father_fragment_groups_id')) {
      context.handle(
          _father_fragment_groups_idMeta,
          father_fragment_groups_id.isAcceptableOrUnknown(
              data['father_fragment_groups_id']!,
              _father_fragment_groups_idMeta));
    }
    if (data.containsKey('profile')) {
      context.handle(_profileMeta,
          profile.isAcceptableOrUnknown(data['profile']!, _profileMeta));
    } else if (isInserting) {
      context.missing(_profileMeta);
    }
    if (data.containsKey('title')) {
      context.handle(
          _titleMeta, title.isAcceptableOrUnknown(data['title']!, _titleMeta));
    } else if (isInserting) {
      context.missing(_titleMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(
          _created_atMeta,
          created_at.isAcceptableOrUnknown(
              data['created_at']!, _created_atMeta));
    } else if (isInserting) {
      context.missing(_created_atMeta);
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
          _updated_atMeta,
          updated_at.isAcceptableOrUnknown(
              data['updated_at']!, _updated_atMeta));
    } else if (isInserting) {
      context.missing(_updated_atMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  FragmentGroup map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return FragmentGroup(
      be_private: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}be_private'])!,
      be_publish: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}be_publish'])!,
      client_be_selected: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}client_be_selected'])!,
      creator_user_id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}creator_user_id'])!,
      father_fragment_groups_id: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}father_fragment_groups_id']),
      profile: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}profile'])!,
      title: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}title'])!,
      created_at: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_at'])!,
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id'])!,
      updated_at: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}updated_at'])!,
    );
  }

  @override
  $FragmentGroupsTable createAlias(String alias) {
    return $FragmentGroupsTable(attachedDatabase, alias);
  }

  @override
  bool get withoutRowId => true;
}

class FragmentGroup extends DataClass implements Insertable<FragmentGroup> {
  bool be_private;
  bool be_publish;
  bool client_be_selected;
  int creator_user_id;
  String? father_fragment_groups_id;
  String profile;
  String title;
  DateTime created_at;
  String id;
  DateTime updated_at;
  FragmentGroup(
      {required this.be_private,
      required this.be_publish,
      required this.client_be_selected,
      required this.creator_user_id,
      this.father_fragment_groups_id,
      required this.profile,
      required this.title,
      required this.created_at,
      required this.id,
      required this.updated_at});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['be_private'] = Variable<bool>(be_private);
    map['be_publish'] = Variable<bool>(be_publish);
    map['client_be_selected'] = Variable<bool>(client_be_selected);
    map['creator_user_id'] = Variable<int>(creator_user_id);
    if (!nullToAbsent || father_fragment_groups_id != null) {
      map['father_fragment_groups_id'] =
          Variable<String>(father_fragment_groups_id);
    }
    map['profile'] = Variable<String>(profile);
    map['title'] = Variable<String>(title);
    map['created_at'] = Variable<DateTime>(created_at);
    map['id'] = Variable<String>(id);
    map['updated_at'] = Variable<DateTime>(updated_at);
    return map;
  }

  FragmentGroupsCompanion toCompanion(bool nullToAbsent) {
    return FragmentGroupsCompanion(
      be_private: Value(be_private),
      be_publish: Value(be_publish),
      client_be_selected: Value(client_be_selected),
      creator_user_id: Value(creator_user_id),
      father_fragment_groups_id:
          father_fragment_groups_id == null && nullToAbsent
              ? const Value.absent()
              : Value(father_fragment_groups_id),
      profile: Value(profile),
      title: Value(title),
      created_at: Value(created_at),
      id: Value(id),
      updated_at: Value(updated_at),
    );
  }

  factory FragmentGroup.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return FragmentGroup(
      be_private: serializer.fromJson<bool>(json['be_private']),
      be_publish: serializer.fromJson<bool>(json['be_publish']),
      client_be_selected: serializer.fromJson<bool>(json['client_be_selected']),
      creator_user_id: serializer.fromJson<int>(json['creator_user_id']),
      father_fragment_groups_id:
          serializer.fromJson<String?>(json['father_fragment_groups_id']),
      profile: serializer.fromJson<String>(json['profile']),
      title: serializer.fromJson<String>(json['title']),
      created_at: serializer.fromJson<DateTime>(json['created_at']),
      id: serializer.fromJson<String>(json['id']),
      updated_at: serializer.fromJson<DateTime>(json['updated_at']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'be_private': serializer.toJson<bool>(be_private),
      'be_publish': serializer.toJson<bool>(be_publish),
      'client_be_selected': serializer.toJson<bool>(client_be_selected),
      'creator_user_id': serializer.toJson<int>(creator_user_id),
      'father_fragment_groups_id':
          serializer.toJson<String?>(father_fragment_groups_id),
      'profile': serializer.toJson<String>(profile),
      'title': serializer.toJson<String>(title),
      'created_at': serializer.toJson<DateTime>(created_at),
      'id': serializer.toJson<String>(id),
      'updated_at': serializer.toJson<DateTime>(updated_at),
    };
  }

  FragmentGroup copyWith(
          {bool? be_private,
          bool? be_publish,
          bool? client_be_selected,
          int? creator_user_id,
          Value<String?> father_fragment_groups_id = const Value.absent(),
          String? profile,
          String? title,
          DateTime? created_at,
          String? id,
          DateTime? updated_at}) =>
      FragmentGroup(
        be_private: be_private ?? this.be_private,
        be_publish: be_publish ?? this.be_publish,
        client_be_selected: client_be_selected ?? this.client_be_selected,
        creator_user_id: creator_user_id ?? this.creator_user_id,
        father_fragment_groups_id: father_fragment_groups_id.present
            ? father_fragment_groups_id.value
            : this.father_fragment_groups_id,
        profile: profile ?? this.profile,
        title: title ?? this.title,
        created_at: created_at ?? this.created_at,
        id: id ?? this.id,
        updated_at: updated_at ?? this.updated_at,
      );
  @override
  String toString() {
    return (StringBuffer('FragmentGroup(')
          ..write('be_private: $be_private, ')
          ..write('be_publish: $be_publish, ')
          ..write('client_be_selected: $client_be_selected, ')
          ..write('creator_user_id: $creator_user_id, ')
          ..write('father_fragment_groups_id: $father_fragment_groups_id, ')
          ..write('profile: $profile, ')
          ..write('title: $title, ')
          ..write('created_at: $created_at, ')
          ..write('id: $id, ')
          ..write('updated_at: $updated_at')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      be_private,
      be_publish,
      client_be_selected,
      creator_user_id,
      father_fragment_groups_id,
      profile,
      title,
      created_at,
      id,
      updated_at);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is FragmentGroup &&
          other.be_private == this.be_private &&
          other.be_publish == this.be_publish &&
          other.client_be_selected == this.client_be_selected &&
          other.creator_user_id == this.creator_user_id &&
          other.father_fragment_groups_id == this.father_fragment_groups_id &&
          other.profile == this.profile &&
          other.title == this.title &&
          other.created_at == this.created_at &&
          other.id == this.id &&
          other.updated_at == this.updated_at);
}

class FragmentGroupsCompanion extends UpdateCompanion<FragmentGroup> {
  Value<bool> be_private;
  Value<bool> be_publish;
  Value<bool> client_be_selected;
  Value<int> creator_user_id;
  Value<String?> father_fragment_groups_id;
  Value<String> profile;
  Value<String> title;
  Value<DateTime> created_at;
  Value<String> id;
  Value<DateTime> updated_at;
  FragmentGroupsCompanion({
    this.be_private = const Value.absent(),
    this.be_publish = const Value.absent(),
    this.client_be_selected = const Value.absent(),
    this.creator_user_id = const Value.absent(),
    this.father_fragment_groups_id = const Value.absent(),
    this.profile = const Value.absent(),
    this.title = const Value.absent(),
    this.created_at = const Value.absent(),
    this.id = const Value.absent(),
    this.updated_at = const Value.absent(),
  });
  FragmentGroupsCompanion.insert({
    required bool be_private,
    required bool be_publish,
    required bool client_be_selected,
    required int creator_user_id,
    this.father_fragment_groups_id = const Value.absent(),
    required String profile,
    required String title,
    required DateTime created_at,
    required String id,
    required DateTime updated_at,
  })  : be_private = Value(be_private),
        be_publish = Value(be_publish),
        client_be_selected = Value(client_be_selected),
        creator_user_id = Value(creator_user_id),
        profile = Value(profile),
        title = Value(title),
        created_at = Value(created_at),
        id = Value(id),
        updated_at = Value(updated_at);
  static Insertable<FragmentGroup> custom({
    Expression<bool>? be_private,
    Expression<bool>? be_publish,
    Expression<bool>? client_be_selected,
    Expression<int>? creator_user_id,
    Expression<String>? father_fragment_groups_id,
    Expression<String>? profile,
    Expression<String>? title,
    Expression<DateTime>? created_at,
    Expression<String>? id,
    Expression<DateTime>? updated_at,
  }) {
    return RawValuesInsertable({
      if (be_private != null) 'be_private': be_private,
      if (be_publish != null) 'be_publish': be_publish,
      if (client_be_selected != null) 'client_be_selected': client_be_selected,
      if (creator_user_id != null) 'creator_user_id': creator_user_id,
      if (father_fragment_groups_id != null)
        'father_fragment_groups_id': father_fragment_groups_id,
      if (profile != null) 'profile': profile,
      if (title != null) 'title': title,
      if (created_at != null) 'created_at': created_at,
      if (id != null) 'id': id,
      if (updated_at != null) 'updated_at': updated_at,
    });
  }

  FragmentGroupsCompanion copyWith(
      {Value<bool>? be_private,
      Value<bool>? be_publish,
      Value<bool>? client_be_selected,
      Value<int>? creator_user_id,
      Value<String?>? father_fragment_groups_id,
      Value<String>? profile,
      Value<String>? title,
      Value<DateTime>? created_at,
      Value<String>? id,
      Value<DateTime>? updated_at}) {
    return FragmentGroupsCompanion(
      be_private: be_private ?? this.be_private,
      be_publish: be_publish ?? this.be_publish,
      client_be_selected: client_be_selected ?? this.client_be_selected,
      creator_user_id: creator_user_id ?? this.creator_user_id,
      father_fragment_groups_id:
          father_fragment_groups_id ?? this.father_fragment_groups_id,
      profile: profile ?? this.profile,
      title: title ?? this.title,
      created_at: created_at ?? this.created_at,
      id: id ?? this.id,
      updated_at: updated_at ?? this.updated_at,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (be_private.present) {
      map['be_private'] = Variable<bool>(be_private.value);
    }
    if (be_publish.present) {
      map['be_publish'] = Variable<bool>(be_publish.value);
    }
    if (client_be_selected.present) {
      map['client_be_selected'] = Variable<bool>(client_be_selected.value);
    }
    if (creator_user_id.present) {
      map['creator_user_id'] = Variable<int>(creator_user_id.value);
    }
    if (father_fragment_groups_id.present) {
      map['father_fragment_groups_id'] =
          Variable<String>(father_fragment_groups_id.value);
    }
    if (profile.present) {
      map['profile'] = Variable<String>(profile.value);
    }
    if (title.present) {
      map['title'] = Variable<String>(title.value);
    }
    if (created_at.present) {
      map['created_at'] = Variable<DateTime>(created_at.value);
    }
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (updated_at.present) {
      map['updated_at'] = Variable<DateTime>(updated_at.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('FragmentGroupsCompanion(')
          ..write('be_private: $be_private, ')
          ..write('be_publish: $be_publish, ')
          ..write('client_be_selected: $client_be_selected, ')
          ..write('creator_user_id: $creator_user_id, ')
          ..write('father_fragment_groups_id: $father_fragment_groups_id, ')
          ..write('profile: $profile, ')
          ..write('title: $title, ')
          ..write('created_at: $created_at, ')
          ..write('id: $id, ')
          ..write('updated_at: $updated_at')
          ..write(')'))
        .toString();
  }
}

class $UserCommentsTable extends UserComments
    with TableInfo<$UserCommentsTable, UserComment> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $UserCommentsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _comment_contentMeta =
      const VerificationMeta('comment_content');
  @override
  late final GeneratedColumn<String> comment_content = GeneratedColumn<String>(
      'comment_content', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _commentator_user_idMeta =
      const VerificationMeta('commentator_user_id');
  @override
  late final GeneratedColumn<int> commentator_user_id = GeneratedColumn<int>(
      'commentator_user_id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _fragment_group_idMeta =
      const VerificationMeta('fragment_group_id');
  @override
  late final GeneratedColumn<String> fragment_group_id =
      GeneratedColumn<String>('fragment_group_id', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _fragment_idMeta =
      const VerificationMeta('fragment_id');
  @override
  late final GeneratedColumn<String> fragment_id = GeneratedColumn<String>(
      'fragment_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _created_atMeta =
      const VerificationMeta('created_at');
  @override
  late final GeneratedColumn<DateTime> created_at = GeneratedColumn<DateTime>(
      'created_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _updated_atMeta =
      const VerificationMeta('updated_at');
  @override
  late final GeneratedColumn<DateTime> updated_at = GeneratedColumn<DateTime>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns => [
        comment_content,
        commentator_user_id,
        fragment_group_id,
        fragment_id,
        created_at,
        id,
        updated_at
      ];
  @override
  String get aliasedName => _alias ?? 'user_comments';
  @override
  String get actualTableName => 'user_comments';
  @override
  VerificationContext validateIntegrity(Insertable<UserComment> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('comment_content')) {
      context.handle(
          _comment_contentMeta,
          comment_content.isAcceptableOrUnknown(
              data['comment_content']!, _comment_contentMeta));
    } else if (isInserting) {
      context.missing(_comment_contentMeta);
    }
    if (data.containsKey('commentator_user_id')) {
      context.handle(
          _commentator_user_idMeta,
          commentator_user_id.isAcceptableOrUnknown(
              data['commentator_user_id']!, _commentator_user_idMeta));
    } else if (isInserting) {
      context.missing(_commentator_user_idMeta);
    }
    if (data.containsKey('fragment_group_id')) {
      context.handle(
          _fragment_group_idMeta,
          fragment_group_id.isAcceptableOrUnknown(
              data['fragment_group_id']!, _fragment_group_idMeta));
    }
    if (data.containsKey('fragment_id')) {
      context.handle(
          _fragment_idMeta,
          fragment_id.isAcceptableOrUnknown(
              data['fragment_id']!, _fragment_idMeta));
    }
    if (data.containsKey('created_at')) {
      context.handle(
          _created_atMeta,
          created_at.isAcceptableOrUnknown(
              data['created_at']!, _created_atMeta));
    } else if (isInserting) {
      context.missing(_created_atMeta);
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('updated_at')) {
      context.handle(
          _updated_atMeta,
          updated_at.isAcceptableOrUnknown(
              data['updated_at']!, _updated_atMeta));
    } else if (isInserting) {
      context.missing(_updated_atMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  UserComment map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return UserComment(
      comment_content: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}comment_content'])!,
      commentator_user_id: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}commentator_user_id'])!,
      fragment_group_id: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}fragment_group_id']),
      fragment_id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}fragment_id']),
      created_at: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_at'])!,
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      updated_at: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}updated_at'])!,
    );
  }

  @override
  $UserCommentsTable createAlias(String alias) {
    return $UserCommentsTable(attachedDatabase, alias);
  }
}

class UserComment extends DataClass implements Insertable<UserComment> {
  String comment_content;
  int commentator_user_id;
  String? fragment_group_id;
  String? fragment_id;
  DateTime created_at;
  int id;
  DateTime updated_at;
  UserComment(
      {required this.comment_content,
      required this.commentator_user_id,
      this.fragment_group_id,
      this.fragment_id,
      required this.created_at,
      required this.id,
      required this.updated_at});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['comment_content'] = Variable<String>(comment_content);
    map['commentator_user_id'] = Variable<int>(commentator_user_id);
    if (!nullToAbsent || fragment_group_id != null) {
      map['fragment_group_id'] = Variable<String>(fragment_group_id);
    }
    if (!nullToAbsent || fragment_id != null) {
      map['fragment_id'] = Variable<String>(fragment_id);
    }
    map['created_at'] = Variable<DateTime>(created_at);
    map['id'] = Variable<int>(id);
    map['updated_at'] = Variable<DateTime>(updated_at);
    return map;
  }

  UserCommentsCompanion toCompanion(bool nullToAbsent) {
    return UserCommentsCompanion(
      comment_content: Value(comment_content),
      commentator_user_id: Value(commentator_user_id),
      fragment_group_id: fragment_group_id == null && nullToAbsent
          ? const Value.absent()
          : Value(fragment_group_id),
      fragment_id: fragment_id == null && nullToAbsent
          ? const Value.absent()
          : Value(fragment_id),
      created_at: Value(created_at),
      id: Value(id),
      updated_at: Value(updated_at),
    );
  }

  factory UserComment.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return UserComment(
      comment_content: serializer.fromJson<String>(json['comment_content']),
      commentator_user_id:
          serializer.fromJson<int>(json['commentator_user_id']),
      fragment_group_id:
          serializer.fromJson<String?>(json['fragment_group_id']),
      fragment_id: serializer.fromJson<String?>(json['fragment_id']),
      created_at: serializer.fromJson<DateTime>(json['created_at']),
      id: serializer.fromJson<int>(json['id']),
      updated_at: serializer.fromJson<DateTime>(json['updated_at']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'comment_content': serializer.toJson<String>(comment_content),
      'commentator_user_id': serializer.toJson<int>(commentator_user_id),
      'fragment_group_id': serializer.toJson<String?>(fragment_group_id),
      'fragment_id': serializer.toJson<String?>(fragment_id),
      'created_at': serializer.toJson<DateTime>(created_at),
      'id': serializer.toJson<int>(id),
      'updated_at': serializer.toJson<DateTime>(updated_at),
    };
  }

  UserComment copyWith(
          {String? comment_content,
          int? commentator_user_id,
          Value<String?> fragment_group_id = const Value.absent(),
          Value<String?> fragment_id = const Value.absent(),
          DateTime? created_at,
          int? id,
          DateTime? updated_at}) =>
      UserComment(
        comment_content: comment_content ?? this.comment_content,
        commentator_user_id: commentator_user_id ?? this.commentator_user_id,
        fragment_group_id: fragment_group_id.present
            ? fragment_group_id.value
            : this.fragment_group_id,
        fragment_id: fragment_id.present ? fragment_id.value : this.fragment_id,
        created_at: created_at ?? this.created_at,
        id: id ?? this.id,
        updated_at: updated_at ?? this.updated_at,
      );
  @override
  String toString() {
    return (StringBuffer('UserComment(')
          ..write('comment_content: $comment_content, ')
          ..write('commentator_user_id: $commentator_user_id, ')
          ..write('fragment_group_id: $fragment_group_id, ')
          ..write('fragment_id: $fragment_id, ')
          ..write('created_at: $created_at, ')
          ..write('id: $id, ')
          ..write('updated_at: $updated_at')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(comment_content, commentator_user_id,
      fragment_group_id, fragment_id, created_at, id, updated_at);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is UserComment &&
          other.comment_content == this.comment_content &&
          other.commentator_user_id == this.commentator_user_id &&
          other.fragment_group_id == this.fragment_group_id &&
          other.fragment_id == this.fragment_id &&
          other.created_at == this.created_at &&
          other.id == this.id &&
          other.updated_at == this.updated_at);
}

class UserCommentsCompanion extends UpdateCompanion<UserComment> {
  Value<String> comment_content;
  Value<int> commentator_user_id;
  Value<String?> fragment_group_id;
  Value<String?> fragment_id;
  Value<DateTime> created_at;
  Value<int> id;
  Value<DateTime> updated_at;
  UserCommentsCompanion({
    this.comment_content = const Value.absent(),
    this.commentator_user_id = const Value.absent(),
    this.fragment_group_id = const Value.absent(),
    this.fragment_id = const Value.absent(),
    this.created_at = const Value.absent(),
    this.id = const Value.absent(),
    this.updated_at = const Value.absent(),
  });
  UserCommentsCompanion.insert({
    required String comment_content,
    required int commentator_user_id,
    this.fragment_group_id = const Value.absent(),
    this.fragment_id = const Value.absent(),
    required DateTime created_at,
    this.id = const Value.absent(),
    required DateTime updated_at,
  })  : comment_content = Value(comment_content),
        commentator_user_id = Value(commentator_user_id),
        created_at = Value(created_at),
        updated_at = Value(updated_at);
  static Insertable<UserComment> custom({
    Expression<String>? comment_content,
    Expression<int>? commentator_user_id,
    Expression<String>? fragment_group_id,
    Expression<String>? fragment_id,
    Expression<DateTime>? created_at,
    Expression<int>? id,
    Expression<DateTime>? updated_at,
  }) {
    return RawValuesInsertable({
      if (comment_content != null) 'comment_content': comment_content,
      if (commentator_user_id != null)
        'commentator_user_id': commentator_user_id,
      if (fragment_group_id != null) 'fragment_group_id': fragment_group_id,
      if (fragment_id != null) 'fragment_id': fragment_id,
      if (created_at != null) 'created_at': created_at,
      if (id != null) 'id': id,
      if (updated_at != null) 'updated_at': updated_at,
    });
  }

  UserCommentsCompanion copyWith(
      {Value<String>? comment_content,
      Value<int>? commentator_user_id,
      Value<String?>? fragment_group_id,
      Value<String?>? fragment_id,
      Value<DateTime>? created_at,
      Value<int>? id,
      Value<DateTime>? updated_at}) {
    return UserCommentsCompanion(
      comment_content: comment_content ?? this.comment_content,
      commentator_user_id: commentator_user_id ?? this.commentator_user_id,
      fragment_group_id: fragment_group_id ?? this.fragment_group_id,
      fragment_id: fragment_id ?? this.fragment_id,
      created_at: created_at ?? this.created_at,
      id: id ?? this.id,
      updated_at: updated_at ?? this.updated_at,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (comment_content.present) {
      map['comment_content'] = Variable<String>(comment_content.value);
    }
    if (commentator_user_id.present) {
      map['commentator_user_id'] = Variable<int>(commentator_user_id.value);
    }
    if (fragment_group_id.present) {
      map['fragment_group_id'] = Variable<String>(fragment_group_id.value);
    }
    if (fragment_id.present) {
      map['fragment_id'] = Variable<String>(fragment_id.value);
    }
    if (created_at.present) {
      map['created_at'] = Variable<DateTime>(created_at.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (updated_at.present) {
      map['updated_at'] = Variable<DateTime>(updated_at.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('UserCommentsCompanion(')
          ..write('comment_content: $comment_content, ')
          ..write('commentator_user_id: $commentator_user_id, ')
          ..write('fragment_group_id: $fragment_group_id, ')
          ..write('fragment_id: $fragment_id, ')
          ..write('created_at: $created_at, ')
          ..write('id: $id, ')
          ..write('updated_at: $updated_at')
          ..write(')'))
        .toString();
  }
}

class $UserLikesTable extends UserLikes
    with TableInfo<$UserLikesTable, UserLike> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $UserLikesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _fragment_group_idMeta =
      const VerificationMeta('fragment_group_id');
  @override
  late final GeneratedColumn<String> fragment_group_id =
      GeneratedColumn<String>('fragment_group_id', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _fragment_idMeta =
      const VerificationMeta('fragment_id');
  @override
  late final GeneratedColumn<String> fragment_id = GeneratedColumn<String>(
      'fragment_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _liker_user_idMeta =
      const VerificationMeta('liker_user_id');
  @override
  late final GeneratedColumn<int> liker_user_id = GeneratedColumn<int>(
      'liker_user_id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _created_atMeta =
      const VerificationMeta('created_at');
  @override
  late final GeneratedColumn<DateTime> created_at = GeneratedColumn<DateTime>(
      'created_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _updated_atMeta =
      const VerificationMeta('updated_at');
  @override
  late final GeneratedColumn<DateTime> updated_at = GeneratedColumn<DateTime>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns => [
        fragment_group_id,
        fragment_id,
        liker_user_id,
        created_at,
        id,
        updated_at
      ];
  @override
  String get aliasedName => _alias ?? 'user_likes';
  @override
  String get actualTableName => 'user_likes';
  @override
  VerificationContext validateIntegrity(Insertable<UserLike> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('fragment_group_id')) {
      context.handle(
          _fragment_group_idMeta,
          fragment_group_id.isAcceptableOrUnknown(
              data['fragment_group_id']!, _fragment_group_idMeta));
    }
    if (data.containsKey('fragment_id')) {
      context.handle(
          _fragment_idMeta,
          fragment_id.isAcceptableOrUnknown(
              data['fragment_id']!, _fragment_idMeta));
    }
    if (data.containsKey('liker_user_id')) {
      context.handle(
          _liker_user_idMeta,
          liker_user_id.isAcceptableOrUnknown(
              data['liker_user_id']!, _liker_user_idMeta));
    } else if (isInserting) {
      context.missing(_liker_user_idMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(
          _created_atMeta,
          created_at.isAcceptableOrUnknown(
              data['created_at']!, _created_atMeta));
    } else if (isInserting) {
      context.missing(_created_atMeta);
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('updated_at')) {
      context.handle(
          _updated_atMeta,
          updated_at.isAcceptableOrUnknown(
              data['updated_at']!, _updated_atMeta));
    } else if (isInserting) {
      context.missing(_updated_atMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  UserLike map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return UserLike(
      fragment_group_id: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}fragment_group_id']),
      fragment_id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}fragment_id']),
      liker_user_id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}liker_user_id'])!,
      created_at: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_at'])!,
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      updated_at: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}updated_at'])!,
    );
  }

  @override
  $UserLikesTable createAlias(String alias) {
    return $UserLikesTable(attachedDatabase, alias);
  }
}

class UserLike extends DataClass implements Insertable<UserLike> {
  String? fragment_group_id;
  String? fragment_id;
  int liker_user_id;
  DateTime created_at;
  int id;
  DateTime updated_at;
  UserLike(
      {this.fragment_group_id,
      this.fragment_id,
      required this.liker_user_id,
      required this.created_at,
      required this.id,
      required this.updated_at});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || fragment_group_id != null) {
      map['fragment_group_id'] = Variable<String>(fragment_group_id);
    }
    if (!nullToAbsent || fragment_id != null) {
      map['fragment_id'] = Variable<String>(fragment_id);
    }
    map['liker_user_id'] = Variable<int>(liker_user_id);
    map['created_at'] = Variable<DateTime>(created_at);
    map['id'] = Variable<int>(id);
    map['updated_at'] = Variable<DateTime>(updated_at);
    return map;
  }

  UserLikesCompanion toCompanion(bool nullToAbsent) {
    return UserLikesCompanion(
      fragment_group_id: fragment_group_id == null && nullToAbsent
          ? const Value.absent()
          : Value(fragment_group_id),
      fragment_id: fragment_id == null && nullToAbsent
          ? const Value.absent()
          : Value(fragment_id),
      liker_user_id: Value(liker_user_id),
      created_at: Value(created_at),
      id: Value(id),
      updated_at: Value(updated_at),
    );
  }

  factory UserLike.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return UserLike(
      fragment_group_id:
          serializer.fromJson<String?>(json['fragment_group_id']),
      fragment_id: serializer.fromJson<String?>(json['fragment_id']),
      liker_user_id: serializer.fromJson<int>(json['liker_user_id']),
      created_at: serializer.fromJson<DateTime>(json['created_at']),
      id: serializer.fromJson<int>(json['id']),
      updated_at: serializer.fromJson<DateTime>(json['updated_at']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'fragment_group_id': serializer.toJson<String?>(fragment_group_id),
      'fragment_id': serializer.toJson<String?>(fragment_id),
      'liker_user_id': serializer.toJson<int>(liker_user_id),
      'created_at': serializer.toJson<DateTime>(created_at),
      'id': serializer.toJson<int>(id),
      'updated_at': serializer.toJson<DateTime>(updated_at),
    };
  }

  UserLike copyWith(
          {Value<String?> fragment_group_id = const Value.absent(),
          Value<String?> fragment_id = const Value.absent(),
          int? liker_user_id,
          DateTime? created_at,
          int? id,
          DateTime? updated_at}) =>
      UserLike(
        fragment_group_id: fragment_group_id.present
            ? fragment_group_id.value
            : this.fragment_group_id,
        fragment_id: fragment_id.present ? fragment_id.value : this.fragment_id,
        liker_user_id: liker_user_id ?? this.liker_user_id,
        created_at: created_at ?? this.created_at,
        id: id ?? this.id,
        updated_at: updated_at ?? this.updated_at,
      );
  @override
  String toString() {
    return (StringBuffer('UserLike(')
          ..write('fragment_group_id: $fragment_group_id, ')
          ..write('fragment_id: $fragment_id, ')
          ..write('liker_user_id: $liker_user_id, ')
          ..write('created_at: $created_at, ')
          ..write('id: $id, ')
          ..write('updated_at: $updated_at')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(fragment_group_id, fragment_id, liker_user_id,
      created_at, id, updated_at);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is UserLike &&
          other.fragment_group_id == this.fragment_group_id &&
          other.fragment_id == this.fragment_id &&
          other.liker_user_id == this.liker_user_id &&
          other.created_at == this.created_at &&
          other.id == this.id &&
          other.updated_at == this.updated_at);
}

class UserLikesCompanion extends UpdateCompanion<UserLike> {
  Value<String?> fragment_group_id;
  Value<String?> fragment_id;
  Value<int> liker_user_id;
  Value<DateTime> created_at;
  Value<int> id;
  Value<DateTime> updated_at;
  UserLikesCompanion({
    this.fragment_group_id = const Value.absent(),
    this.fragment_id = const Value.absent(),
    this.liker_user_id = const Value.absent(),
    this.created_at = const Value.absent(),
    this.id = const Value.absent(),
    this.updated_at = const Value.absent(),
  });
  UserLikesCompanion.insert({
    this.fragment_group_id = const Value.absent(),
    this.fragment_id = const Value.absent(),
    required int liker_user_id,
    required DateTime created_at,
    this.id = const Value.absent(),
    required DateTime updated_at,
  })  : liker_user_id = Value(liker_user_id),
        created_at = Value(created_at),
        updated_at = Value(updated_at);
  static Insertable<UserLike> custom({
    Expression<String>? fragment_group_id,
    Expression<String>? fragment_id,
    Expression<int>? liker_user_id,
    Expression<DateTime>? created_at,
    Expression<int>? id,
    Expression<DateTime>? updated_at,
  }) {
    return RawValuesInsertable({
      if (fragment_group_id != null) 'fragment_group_id': fragment_group_id,
      if (fragment_id != null) 'fragment_id': fragment_id,
      if (liker_user_id != null) 'liker_user_id': liker_user_id,
      if (created_at != null) 'created_at': created_at,
      if (id != null) 'id': id,
      if (updated_at != null) 'updated_at': updated_at,
    });
  }

  UserLikesCompanion copyWith(
      {Value<String?>? fragment_group_id,
      Value<String?>? fragment_id,
      Value<int>? liker_user_id,
      Value<DateTime>? created_at,
      Value<int>? id,
      Value<DateTime>? updated_at}) {
    return UserLikesCompanion(
      fragment_group_id: fragment_group_id ?? this.fragment_group_id,
      fragment_id: fragment_id ?? this.fragment_id,
      liker_user_id: liker_user_id ?? this.liker_user_id,
      created_at: created_at ?? this.created_at,
      id: id ?? this.id,
      updated_at: updated_at ?? this.updated_at,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (fragment_group_id.present) {
      map['fragment_group_id'] = Variable<String>(fragment_group_id.value);
    }
    if (fragment_id.present) {
      map['fragment_id'] = Variable<String>(fragment_id.value);
    }
    if (liker_user_id.present) {
      map['liker_user_id'] = Variable<int>(liker_user_id.value);
    }
    if (created_at.present) {
      map['created_at'] = Variable<DateTime>(created_at.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (updated_at.present) {
      map['updated_at'] = Variable<DateTime>(updated_at.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('UserLikesCompanion(')
          ..write('fragment_group_id: $fragment_group_id, ')
          ..write('fragment_id: $fragment_id, ')
          ..write('liker_user_id: $liker_user_id, ')
          ..write('created_at: $created_at, ')
          ..write('id: $id, ')
          ..write('updated_at: $updated_at')
          ..write(')'))
        .toString();
  }
}

class $UsersTable extends Users with TableInfo<$UsersTable, User> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $UsersTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _ageMeta = const VerificationMeta('age');
  @override
  late final GeneratedColumn<int> age = GeneratedColumn<int>(
      'age', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _emailMeta = const VerificationMeta('email');
  @override
  late final GeneratedColumn<String> email = GeneratedColumn<String>(
      'email', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _passwordMeta =
      const VerificationMeta('password');
  @override
  late final GeneratedColumn<String> password = GeneratedColumn<String>(
      'password', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _phoneMeta = const VerificationMeta('phone');
  @override
  late final GeneratedColumn<String> phone = GeneratedColumn<String>(
      'phone', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _usernameMeta =
      const VerificationMeta('username');
  @override
  late final GeneratedColumn<String> username = GeneratedColumn<String>(
      'username', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _created_atMeta =
      const VerificationMeta('created_at');
  @override
  late final GeneratedColumn<DateTime> created_at = GeneratedColumn<DateTime>(
      'created_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _updated_atMeta =
      const VerificationMeta('updated_at');
  @override
  late final GeneratedColumn<DateTime> updated_at = GeneratedColumn<DateTime>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns =>
      [age, email, password, phone, username, created_at, id, updated_at];
  @override
  String get aliasedName => _alias ?? 'users';
  @override
  String get actualTableName => 'users';
  @override
  VerificationContext validateIntegrity(Insertable<User> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('age')) {
      context.handle(
          _ageMeta, age.isAcceptableOrUnknown(data['age']!, _ageMeta));
    }
    if (data.containsKey('email')) {
      context.handle(
          _emailMeta, email.isAcceptableOrUnknown(data['email']!, _emailMeta));
    }
    if (data.containsKey('password')) {
      context.handle(_passwordMeta,
          password.isAcceptableOrUnknown(data['password']!, _passwordMeta));
    }
    if (data.containsKey('phone')) {
      context.handle(
          _phoneMeta, phone.isAcceptableOrUnknown(data['phone']!, _phoneMeta));
    }
    if (data.containsKey('username')) {
      context.handle(_usernameMeta,
          username.isAcceptableOrUnknown(data['username']!, _usernameMeta));
    } else if (isInserting) {
      context.missing(_usernameMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(
          _created_atMeta,
          created_at.isAcceptableOrUnknown(
              data['created_at']!, _created_atMeta));
    } else if (isInserting) {
      context.missing(_created_atMeta);
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('updated_at')) {
      context.handle(
          _updated_atMeta,
          updated_at.isAcceptableOrUnknown(
              data['updated_at']!, _updated_atMeta));
    } else if (isInserting) {
      context.missing(_updated_atMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  User map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return User(
      age: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}age']),
      email: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}email']),
      password: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}password']),
      phone: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}phone']),
      username: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}username'])!,
      created_at: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_at'])!,
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      updated_at: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}updated_at'])!,
    );
  }

  @override
  $UsersTable createAlias(String alias) {
    return $UsersTable(attachedDatabase, alias);
  }
}

class User extends DataClass implements Insertable<User> {
  int? age;
  String? email;
  String? password;
  String? phone;
  String username;
  DateTime created_at;
  int id;
  DateTime updated_at;
  User(
      {this.age,
      this.email,
      this.password,
      this.phone,
      required this.username,
      required this.created_at,
      required this.id,
      required this.updated_at});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || age != null) {
      map['age'] = Variable<int>(age);
    }
    if (!nullToAbsent || email != null) {
      map['email'] = Variable<String>(email);
    }
    if (!nullToAbsent || password != null) {
      map['password'] = Variable<String>(password);
    }
    if (!nullToAbsent || phone != null) {
      map['phone'] = Variable<String>(phone);
    }
    map['username'] = Variable<String>(username);
    map['created_at'] = Variable<DateTime>(created_at);
    map['id'] = Variable<int>(id);
    map['updated_at'] = Variable<DateTime>(updated_at);
    return map;
  }

  UsersCompanion toCompanion(bool nullToAbsent) {
    return UsersCompanion(
      age: age == null && nullToAbsent ? const Value.absent() : Value(age),
      email:
          email == null && nullToAbsent ? const Value.absent() : Value(email),
      password: password == null && nullToAbsent
          ? const Value.absent()
          : Value(password),
      phone:
          phone == null && nullToAbsent ? const Value.absent() : Value(phone),
      username: Value(username),
      created_at: Value(created_at),
      id: Value(id),
      updated_at: Value(updated_at),
    );
  }

  factory User.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return User(
      age: serializer.fromJson<int?>(json['age']),
      email: serializer.fromJson<String?>(json['email']),
      password: serializer.fromJson<String?>(json['password']),
      phone: serializer.fromJson<String?>(json['phone']),
      username: serializer.fromJson<String>(json['username']),
      created_at: serializer.fromJson<DateTime>(json['created_at']),
      id: serializer.fromJson<int>(json['id']),
      updated_at: serializer.fromJson<DateTime>(json['updated_at']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'age': serializer.toJson<int?>(age),
      'email': serializer.toJson<String?>(email),
      'password': serializer.toJson<String?>(password),
      'phone': serializer.toJson<String?>(phone),
      'username': serializer.toJson<String>(username),
      'created_at': serializer.toJson<DateTime>(created_at),
      'id': serializer.toJson<int>(id),
      'updated_at': serializer.toJson<DateTime>(updated_at),
    };
  }

  User copyWith(
          {Value<int?> age = const Value.absent(),
          Value<String?> email = const Value.absent(),
          Value<String?> password = const Value.absent(),
          Value<String?> phone = const Value.absent(),
          String? username,
          DateTime? created_at,
          int? id,
          DateTime? updated_at}) =>
      User(
        age: age.present ? age.value : this.age,
        email: email.present ? email.value : this.email,
        password: password.present ? password.value : this.password,
        phone: phone.present ? phone.value : this.phone,
        username: username ?? this.username,
        created_at: created_at ?? this.created_at,
        id: id ?? this.id,
        updated_at: updated_at ?? this.updated_at,
      );
  @override
  String toString() {
    return (StringBuffer('User(')
          ..write('age: $age, ')
          ..write('email: $email, ')
          ..write('password: $password, ')
          ..write('phone: $phone, ')
          ..write('username: $username, ')
          ..write('created_at: $created_at, ')
          ..write('id: $id, ')
          ..write('updated_at: $updated_at')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      age, email, password, phone, username, created_at, id, updated_at);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is User &&
          other.age == this.age &&
          other.email == this.email &&
          other.password == this.password &&
          other.phone == this.phone &&
          other.username == this.username &&
          other.created_at == this.created_at &&
          other.id == this.id &&
          other.updated_at == this.updated_at);
}

class UsersCompanion extends UpdateCompanion<User> {
  Value<int?> age;
  Value<String?> email;
  Value<String?> password;
  Value<String?> phone;
  Value<String> username;
  Value<DateTime> created_at;
  Value<int> id;
  Value<DateTime> updated_at;
  UsersCompanion({
    this.age = const Value.absent(),
    this.email = const Value.absent(),
    this.password = const Value.absent(),
    this.phone = const Value.absent(),
    this.username = const Value.absent(),
    this.created_at = const Value.absent(),
    this.id = const Value.absent(),
    this.updated_at = const Value.absent(),
  });
  UsersCompanion.insert({
    this.age = const Value.absent(),
    this.email = const Value.absent(),
    this.password = const Value.absent(),
    this.phone = const Value.absent(),
    required String username,
    required DateTime created_at,
    this.id = const Value.absent(),
    required DateTime updated_at,
  })  : username = Value(username),
        created_at = Value(created_at),
        updated_at = Value(updated_at);
  static Insertable<User> custom({
    Expression<int>? age,
    Expression<String>? email,
    Expression<String>? password,
    Expression<String>? phone,
    Expression<String>? username,
    Expression<DateTime>? created_at,
    Expression<int>? id,
    Expression<DateTime>? updated_at,
  }) {
    return RawValuesInsertable({
      if (age != null) 'age': age,
      if (email != null) 'email': email,
      if (password != null) 'password': password,
      if (phone != null) 'phone': phone,
      if (username != null) 'username': username,
      if (created_at != null) 'created_at': created_at,
      if (id != null) 'id': id,
      if (updated_at != null) 'updated_at': updated_at,
    });
  }

  UsersCompanion copyWith(
      {Value<int?>? age,
      Value<String?>? email,
      Value<String?>? password,
      Value<String?>? phone,
      Value<String>? username,
      Value<DateTime>? created_at,
      Value<int>? id,
      Value<DateTime>? updated_at}) {
    return UsersCompanion(
      age: age ?? this.age,
      email: email ?? this.email,
      password: password ?? this.password,
      phone: phone ?? this.phone,
      username: username ?? this.username,
      created_at: created_at ?? this.created_at,
      id: id ?? this.id,
      updated_at: updated_at ?? this.updated_at,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (age.present) {
      map['age'] = Variable<int>(age.value);
    }
    if (email.present) {
      map['email'] = Variable<String>(email.value);
    }
    if (password.present) {
      map['password'] = Variable<String>(password.value);
    }
    if (phone.present) {
      map['phone'] = Variable<String>(phone.value);
    }
    if (username.present) {
      map['username'] = Variable<String>(username.value);
    }
    if (created_at.present) {
      map['created_at'] = Variable<DateTime>(created_at.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (updated_at.present) {
      map['updated_at'] = Variable<DateTime>(updated_at.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('UsersCompanion(')
          ..write('age: $age, ')
          ..write('email: $email, ')
          ..write('password: $password, ')
          ..write('phone: $phone, ')
          ..write('username: $username, ')
          ..write('created_at: $created_at, ')
          ..write('id: $id, ')
          ..write('updated_at: $updated_at')
          ..write(')'))
        .toString();
  }
}

abstract class _$DriftDb extends GeneratedDatabase {
  _$DriftDb(QueryExecutor e) : super(e);
  late final $ClientSyncInfosTable clientSyncInfos =
      $ClientSyncInfosTable(this);
  late final $SyncsTable syncs = $SyncsTable(this);
  late final $FragmentMemoryInfosTable fragmentMemoryInfos =
      $FragmentMemoryInfosTable(this);
  late final $FragmentGroupTagsTable fragmentGroupTags =
      $FragmentGroupTagsTable(this);
  late final $RFragment2FragmentGroupsTable rFragment2FragmentGroups =
      $RFragment2FragmentGroupsTable(this);
  late final $Test2sTable test2s = $Test2sTable(this);
  late final $TestsTable tests = $TestsTable(this);
  late final $FragmentsTable fragments = $FragmentsTable(this);
  late final $MemoryGroupsTable memoryGroups = $MemoryGroupsTable(this);
  late final $MemoryModelsTable memoryModels = $MemoryModelsTable(this);
  late final $ShorthandsTable shorthands = $ShorthandsTable(this);
  late final $FragmentGroupsTable fragmentGroups = $FragmentGroupsTable(this);
  late final $UserCommentsTable userComments = $UserCommentsTable(this);
  late final $UserLikesTable userLikes = $UserLikesTable(this);
  late final $UsersTable users = $UsersTable(this);
  late final InsertDAO insertDAO = InsertDAO(this as DriftDb);
  late final RawDAO rawDAO = RawDAO(this as DriftDb);
  late final RegisterOrLoginDAO registerOrLoginDAO =
      RegisterOrLoginDAO(this as DriftDb);
  late final UpdateDAO updateDAO = UpdateDAO(this as DriftDb);
  late final DeleteDAO deleteDAO = DeleteDAO(this as DriftDb);
  late final GeneralQueryDAO generalQueryDAO = GeneralQueryDAO(this as DriftDb);
  @override
  Iterable<TableInfo<Table, Object?>> get allTables =>
      allSchemaEntities.whereType<TableInfo<Table, Object?>>();
  @override
  List<DatabaseSchemaEntity> get allSchemaEntities => [
        clientSyncInfos,
        syncs,
        fragmentMemoryInfos,
        fragmentGroupTags,
        rFragment2FragmentGroups,
        test2s,
        tests,
        fragments,
        memoryGroups,
        memoryModels,
        shorthands,
        fragmentGroups,
        userComments,
        userLikes,
        users
      ];
}
